:js
:llir
:cpp

:global

:sllir
:intl
:scpp
fun add(x) = y => x + y
fun add_curried(x)(y) = x + y
add(1)(2)
//│ = 3
//│ LLIR:
//│   class Lambda(x$200) extends Callable {
//│     def apply1$221(y$201) =
//│       let x$222 = +(x$200,y$201) in
//│       x$222
//│   }
//│   class Lambda(x$204) extends Callable {
//│     def apply1$221(y$205) =
//│       let x$226 = +(x$204,y$205) in
//│       x$226
//│   }
//│   def add$198(x$200) =
//│     let x$223 = Lambda$219(x$200) in
//│     x$223
//│   def add_curried$199(x$204) =
//│     let x$227 = Lambda$224(x$204) in
//│     x$227
//│   let* (x$228) = add(1) in
//│   let x$229 = Callable.apply1$221(x$228,2) in
//│   x$229
//│ 
//│ Cpp:
//│ #include "mlsprelude.h"
//│ struct Lambda;
//│ _mlsValue add(_mlsValue);
//│ _mlsValue add_curried(_mlsValue);
//│ _mlsValue _mlsMain();
//│ struct Lambda: public Callable {
//│   _mlsValue x;
//│   constexpr static inline const char *typeName = "Lambda";
//│   constexpr static inline uint32_t typeTag = nextTypeTag();
//│   virtual void print() const override { std::printf("%s", typeName); std::printf("("); this->x.print();  std::printf(")"); }
//│   virtual void destroy() override { _mlsValue::destroy(this->x);  operator delete (this, std::align_val_t(_mlsAlignment)); }
//│   static _mlsValue create(_mlsValue x) { auto _mlsVal = new (std::align_val_t(_mlsAlignment)) Lambda; _mlsVal->refCount = 1; _mlsVal->tag = typeTag; _mlsVal->x = x;  return _mlsValue(_mlsVal); }
//│   virtual _mlsValue apply1(_mlsValue y) {
//│     _mlsValue _mls_retval;
//│     auto x1 = (x + y);
//│     _mls_retval = x1;
//│     return _mls_retval;
//│   }
//│ };
//│ _mlsValue add(_mlsValue x) {
//│   _mlsValue _mls_retval;
//│   auto x2 = _mlsValue::create<Lambda>(x);
//│   _mls_retval = x2;
//│   return _mls_retval;
//│ }
//│ _mlsValue add_curried(_mlsValue x4) {
//│   _mlsValue _mls_retval;
//│   auto x3 = _mlsValue::create<Lambda>(x4);
//│   _mls_retval = x3;
//│   return _mls_retval;
//│ }
//│ _mlsValue _mlsMain() {
//│   _mlsValue _mls_retval;
//│   auto x5 = add(_mlsValue::fromIntLit(1));
//│   auto x6 = _mlsMethodCall<Callable>(x5)->apply1(_mlsValue::fromIntLit(2));
//│   _mls_retval = x6;
//│   return _mls_retval;
//│ }
//│ int main() { return _mlsLargeStack(_mlsMainWrapper); }
//│ 
//│ Interpreted:
//│ 3

:sllir
:intl
:scpp
fun add4(a, b) = (c, d) => a + b + c + d
fun add4_curried(a, b)(c, d) = a + b + c + d
add4(1, 2)(3, 4)
//│ = 10
//│ LLIR:
//│   class Lambda(b$233,a$232) extends Callable {
//│     def apply2$269(c$234,d$235) =
//│       let x$270 = +(a$232,b$233) in
//│       let x$271 = +(x$270,c$234) in
//│       let x$272 = +(x$271,d$235) in
//│       x$272
//│   }
//│   class Lambda(a$240,b$241) extends Callable {
//│     def apply2$269(c$242,d$243) =
//│       let x$276 = +(a$240,b$241) in
//│       let x$277 = +(x$276,c$242) in
//│       let x$278 = +(x$277,d$243) in
//│       x$278
//│   }
//│   def add4$231(a$232,b$233) =
//│     let x$273 = Lambda$267(b$233,a$232) in
//│     x$273
//│   def add4_curried$230(a$240,b$241) =
//│     let x$279 = Lambda$274(a$240,b$241) in
//│     x$279
//│   let* (x$280) = add4(1,2) in
//│   let x$281 = Callable.apply2$269(x$280,3,4) in
//│   x$281
//│ 
//│ Cpp:
//│ #include "mlsprelude.h"
//│ struct Lambda;
//│ _mlsValue add4(_mlsValue, _mlsValue);
//│ _mlsValue add4_curried(_mlsValue, _mlsValue);
//│ _mlsValue _mlsMain();
//│ struct Lambda: public Callable {
//│   _mlsValue b;
//│   _mlsValue a;
//│   constexpr static inline const char *typeName = "Lambda";
//│   constexpr static inline uint32_t typeTag = nextTypeTag();
//│   virtual void print() const override { std::printf("%s", typeName); std::printf("("); this->b.print(); std::printf(", "); this->a.print();  std::printf(")"); }
//│   virtual void destroy() override { _mlsValue::destroy(this->b); _mlsValue::destroy(this->a);  operator delete (this, std::align_val_t(_mlsAlignment)); }
//│   static _mlsValue create(_mlsValue b, _mlsValue a) { auto _mlsVal = new (std::align_val_t(_mlsAlignment)) Lambda; _mlsVal->refCount = 1; _mlsVal->tag = typeTag; _mlsVal->b = b; _mlsVal->a = a;  return _mlsValue(_mlsVal); }
//│   virtual _mlsValue apply2(_mlsValue c, _mlsValue d) {
//│     _mlsValue _mls_retval;
//│     auto x = (a + b);
//│     auto x1 = (x + c);
//│     auto x2 = (x1 + d);
//│     _mls_retval = x2;
//│     return _mls_retval;
//│   }
//│ };
//│ _mlsValue add4(_mlsValue a, _mlsValue b) {
//│   _mlsValue _mls_retval;
//│   auto x3 = _mlsValue::create<Lambda>(b, a);
//│   _mls_retval = x3;
//│   return _mls_retval;
//│ }
//│ _mlsValue add4_curried(_mlsValue a1, _mlsValue b1) {
//│   _mlsValue _mls_retval;
//│   auto x4 = _mlsValue::create<Lambda>(a1, b1);
//│   _mls_retval = x4;
//│   return _mls_retval;
//│ }
//│ _mlsValue _mlsMain() {
//│   _mlsValue _mls_retval;
//│   auto x5 = add4(_mlsValue::fromIntLit(1), _mlsValue::fromIntLit(2));
//│   auto x6 = _mlsMethodCall<Callable>(x5)->apply2(_mlsValue::fromIntLit(3), _mlsValue::fromIntLit(4));
//│   _mls_retval = x6;
//│   return _mls_retval;
//│ }
//│ int main() { return _mlsLargeStack(_mlsMainWrapper); }
//│ 
//│ Interpreted:
//│ 10

:sllir
:intl
:scpp
fun add(a, b) = a + b
fun dummy() = add
dummy()(1, 2)
//│ = 3
//│ LLIR:
//│   class Lambda_add() extends Callable {
//│     def apply2$305(arg$301,arg$302) =
//│       let* (x$306) = add(arg$301,arg$302) in
//│       x$306
//│   }
//│   def add$282(a$284,b$285) =
//│     let x$300 = +(a$284,b$285) in
//│     x$300
//│   def dummy$283() =
//│     let x$307 = Lambda_add$303() in
//│     x$307
//│   let* (x$308) = dummy() in
//│   let x$309 = Callable.apply2$305(x$308,1,2) in
//│   x$309
//│ 
//│ Cpp:
//│ #include "mlsprelude.h"
//│ struct Lambda_add;
//│ _mlsValue add(_mlsValue, _mlsValue);
//│ _mlsValue dummy();
//│ _mlsValue _mlsMain();
//│ struct Lambda_add: public Callable {
//│   
//│   constexpr static inline const char *typeName = "Lambda_add";
//│   constexpr static inline uint32_t typeTag = nextTypeTag();
//│   virtual void print() const override { std::printf("%s", typeName); }
//│   virtual void destroy() override {  operator delete (this, std::align_val_t(_mlsAlignment)); }
//│   static _mlsValue create() { auto _mlsVal = new (std::align_val_t(_mlsAlignment)) Lambda_add; _mlsVal->refCount = 1; _mlsVal->tag = typeTag;  return _mlsValue(_mlsVal); }
//│   virtual _mlsValue apply2(_mlsValue arg, _mlsValue arg1) {
//│     _mlsValue _mls_retval;
//│     auto x = add(arg, arg1);
//│     _mls_retval = x;
//│     return _mls_retval;
//│   }
//│ };
//│ _mlsValue add(_mlsValue a, _mlsValue b) {
//│   _mlsValue _mls_retval;
//│   auto x1 = (a + b);
//│   _mls_retval = x1;
//│   return _mls_retval;
//│ }
//│ _mlsValue dummy() {
//│   _mlsValue _mls_retval;
//│   auto x2 = _mlsValue::create<Lambda_add>();
//│   _mls_retval = x2;
//│   return _mls_retval;
//│ }
//│ _mlsValue _mlsMain() {
//│   _mlsValue _mls_retval;
//│   auto x3 = dummy();
//│   auto x4 = _mlsMethodCall<Callable>(x3)->apply2(_mlsValue::fromIntLit(1), _mlsValue::fromIntLit(2));
//│   _mls_retval = x4;
//│   return _mls_retval;
//│ }
//│ int main() { return _mlsLargeStack(_mlsMainWrapper); }
//│ 
//│ Interpreted:
//│ 3

:sllir
:intl
abstract class List[out T]: Cons[T] | Nil
class (::) Cons[out T](head: T, tail: List[T]) extends List[T]
object Nil extends List
fun map(f, l) =
  if l is
    Cons(h, t) then Cons(f(h), map(f, t))
    Nil then Nil
fun inc(x) = x + 1
fun main() =
  map(x => inc(x), 1 :: 2 :: Nil)
  map(inc, 3 :: 4 :: Nil)
main()
//│ = Cons(4, Cons(5, Nil))
//│ LLIR:
//│   class List()
//│   class Cons(head$322,tail$323) extends List
//│   class Nil() extends List
//│   class Lambda() extends Callable {
//│     def apply1$395(x$340) =
//│       let* (x$406) = inc(x$340) in
//│       x$406
//│   }
//│   class Lambda_inc() extends Callable {
//│     def apply1$395(arg$412) =
//│       let* (x$415) = inc(arg$412) in
//│       x$415
//│   }
//│   def map$311(f$326,l$327) =
//│     case l$327 of
//│       Cons$319 =>
//│         let x$392 = l$327.<Cons$319:head> in
//│         let x$393 = l$327.<Cons$319:tail> in
//│         let x$394 = Callable.apply1$395(f$326,x$392) in
//│         let* (x$396) = map(f$326,x$393) in
//│         let x$397 = Cons$319(x$394,x$396) in
//│         x$397
//│       _ =>
//│         case l$327 of
//│           Nil$324 =>
//│             let x$399 = Nil$324() in
//│             x$399
//│           _ =>
//│             panic "match error"
//│   def j$398() =
//│     jump j$391()
//│   def j$391() =
//│     null
//│   def inc$314(x$336) =
//│     let x$400 = +(x$336,1) in
//│     x$400
//│   def main$312() =
//│     let x$401 = Nil$324() in
//│     let x$402 = Cons$319(2,x$401) in
//│     let x$403 = Cons$319(1,x$402) in
//│     let x$407 = Lambda$404() in
//│     let* (x$408) = map(x$407,x$403) in
//│     let x$409 = Nil$324() in
//│     let x$410 = Cons$319(4,x$409) in
//│     let x$411 = Cons$319(3,x$410) in
//│     let x$416 = Lambda_inc$413() in
//│     let* (x$417) = map(x$416,x$411) in
//│     x$417
//│   let* (x$418) = main() in
//│   x$418
//│ 
//│ Interpreted:
//│ Cons(4,Cons(5,Nil()))

