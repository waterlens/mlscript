:js

:import PredefJS.mls
//│ Imported 2 member(s)


fun foo() =
  1 + 2

foo
//│ = [Function: foo]

foo()
//│ = 3

fun foo(x) =
  x + 1

foo(123)
//│ = 124

fun foo(x) =
  x + 1 + 2

foo(123)
//│ = 126

fun foo() = bar()
fun bar() = 42

bar()
//│ = 42

foo()
//│ = 42

fun foo() = bar()
let r = foo()
fun bar() = 42
r
//│ = 42
//│ r = 42

// * This fails to properly initialize, as expected
fun foo() = bar()
let r = foo()
fun bar() = r

// * Similar
:re
object Outer with
  fun foo() = bar()
  val r = foo()
  fun bar() = r
Outer.r
//│ ═══[RUNTIME ERROR] Error: Access to required field 'r' yielded 'undefined'


fun outerfun(x) =
  let r = x + 1
  fun nested(y) =
    r + x + y
  log(nested(x))
  nested

let f = outerfun(100)
f(200)
//│ > 301
//│ = 401
//│ f = [Function: nested]

// f(200)

outerfun(100)
//│ > 301
//│ = [Function: nested]

outerfun(100)(200)
//│ > 301
//│ = 401


// * Notice this strange JS phenomenon:
// * functions leak from the `try` scope, although things like classes do not...

:showRepl
fun test1(x) = test2(x)
fun test2(y) = y + 1
//│ REPL> Sending: let test2, test1;try { test1 = function test1(...args) {   globalThis.Predef.checkArgs("test1", 1, true, args.length);   let x = args[0];   return test2(x); }; test2 = function test2(...args) {   globalThis.Predef.checkArgs("test2", 1, true, args.length);   let y = args[0];   return y + 1; }; null } catch (e) { console.log('\u200B' + e.stack + '\u200B'); }
//│ REPL> Collected:
//│ >  null
//│ REPL> Parsed:
//│ >  null

test1(1)
//│ = 2


