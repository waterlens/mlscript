:js
:llir

:global

:sllir
:intl
:scpp
fun add(x) = y => x + y
add(1)(2)
//│ = 3
//│ LLIR:
//│   class Lambda$0(x) extends Callable {
//│     def apply1(y) =
//│       let x$0 = +(x,y) in
//│       x$0
//│   }
//│   def add(x) =
//│     let x$1 = Lambda$0(x) in
//│     x$1
//│   let* (x$2) = add(1) in
//│   let x$3 = Callable.apply1(x$2,2) in
//│   x$3
//│ 
//│ Cpp:
//│ #include "mlsprelude.h"
//│ struct _mls_Lambda_0;
//│ _mlsValue _mls_add(_mlsValue);
//│ _mlsValue _mlsMain();
//│ struct _mls_Lambda_0: public _mls_Callable {
//│   _mlsValue _mls_x;
//│   constexpr static inline const char *typeName = "Lambda$0";
//│   constexpr static inline uint32_t typeTag = nextTypeTag();
//│   virtual void print() const override { std::printf("%s", typeName); std::printf("("); this->_mls_x.print();  std::printf(")"); }
//│   virtual void destroy() override { _mlsValue::destroy(this->_mls_x);  operator delete (this, std::align_val_t(_mlsAlignment)); }
//│   static _mlsValue create(_mlsValue _mls_x) { auto _mlsVal = new (std::align_val_t(_mlsAlignment)) _mls_Lambda_0; _mlsVal->refCount = 1; _mlsVal->tag = typeTag; _mlsVal->_mls_x = _mls_x;  return _mlsValue(_mlsVal); }
//│   virtual _mlsValue _mls_apply1(_mlsValue _mls_y) {
//│     _mlsValue _mls_retval;
//│     auto _mls_x_0 = (_mls_x + _mls_y);
//│     _mls_retval = _mls_x_0;
//│     return _mls_retval;
//│   }
//│ };
//│ _mlsValue _mls_add(_mlsValue _mls_x) {
//│   _mlsValue _mls_retval;
//│   auto _mls_x_1 = _mlsValue::create<_mls_Lambda_0>(_mls_x);
//│   _mls_retval = _mls_x_1;
//│   return _mls_retval;
//│ }
//│ _mlsValue _mlsMain() {
//│   _mlsValue _mls_retval;
//│   auto _mls_x_2 = _mls_add(_mlsValue::fromIntLit(1));
//│   auto _mls_x_3 = _mlsMethodCall<_mls_Callable>(_mls_x_2)->_mls_apply1(_mlsValue::fromIntLit(2));
//│   _mls_retval = _mls_x_3;
//│   return _mls_retval;
//│ }
//│ int main() { return _mlsLargeStack(_mlsMainWrapper); }
//│ 
//│ Interpreted:
//│ 3

:sllir
:intl
:scpp
fun add4(a, b) = (c, d) => a + b + c + d
add4(1, 2)(3, 4)
//│ = 10
//│ LLIR:
//│   class Lambda$0(a,b) extends Callable {
//│     def apply2(c,d) =
//│       let x$0 = +(a,b) in
//│       let x$1 = +(x$0,c) in
//│       let x$2 = +(x$1,d) in
//│       x$2
//│   }
//│   def add4(a,b) =
//│     let x$3 = Lambda$0(a,b) in
//│     x$3
//│   let* (x$4) = add4(1,2) in
//│   let x$5 = Callable.apply2(x$4,3,4) in
//│   x$5
//│ 
//│ Cpp:
//│ #include "mlsprelude.h"
//│ struct _mls_Lambda_0;
//│ _mlsValue _mls_add4(_mlsValue, _mlsValue);
//│ _mlsValue _mlsMain();
//│ struct _mls_Lambda_0: public _mls_Callable {
//│   _mlsValue _mls_a;
//│   _mlsValue _mls_b;
//│   constexpr static inline const char *typeName = "Lambda$0";
//│   constexpr static inline uint32_t typeTag = nextTypeTag();
//│   virtual void print() const override { std::printf("%s", typeName); std::printf("("); this->_mls_a.print(); std::printf(", "); this->_mls_b.print();  std::printf(")"); }
//│   virtual void destroy() override { _mlsValue::destroy(this->_mls_a); _mlsValue::destroy(this->_mls_b);  operator delete (this, std::align_val_t(_mlsAlignment)); }
//│   static _mlsValue create(_mlsValue _mls_a, _mlsValue _mls_b) { auto _mlsVal = new (std::align_val_t(_mlsAlignment)) _mls_Lambda_0; _mlsVal->refCount = 1; _mlsVal->tag = typeTag; _mlsVal->_mls_a = _mls_a; _mlsVal->_mls_b = _mls_b;  return _mlsValue(_mlsVal); }
//│   virtual _mlsValue _mls_apply2(_mlsValue _mls_c, _mlsValue _mls_d) {
//│     _mlsValue _mls_retval;
//│     auto _mls_x_0 = (_mls_a + _mls_b);
//│     auto _mls_x_1 = (_mls_x_0 + _mls_c);
//│     auto _mls_x_2 = (_mls_x_1 + _mls_d);
//│     _mls_retval = _mls_x_2;
//│     return _mls_retval;
//│   }
//│ };
//│ _mlsValue _mls_add4(_mlsValue _mls_a, _mlsValue _mls_b) {
//│   _mlsValue _mls_retval;
//│   auto _mls_x_3 = _mlsValue::create<_mls_Lambda_0>(_mls_a, _mls_b);
//│   _mls_retval = _mls_x_3;
//│   return _mls_retval;
//│ }
//│ _mlsValue _mlsMain() {
//│   _mlsValue _mls_retval;
//│   auto _mls_x_4 = _mls_add4(_mlsValue::fromIntLit(1), _mlsValue::fromIntLit(2));
//│   auto _mls_x_5 = _mlsMethodCall<_mls_Callable>(_mls_x_4)->_mls_apply2(_mlsValue::fromIntLit(3), _mlsValue::fromIntLit(4));
//│   _mls_retval = _mls_x_5;
//│   return _mls_retval;
//│ }
//│ int main() { return _mlsLargeStack(_mlsMainWrapper); }
//│ 
//│ Interpreted:
//│ 10

:sllir
:intl
:scpp
fun add(a, b) = a + b
fun dummy() = add
dummy()(1, 2)
//│ = 3
//│ LLIR:
//│   class Lambda$0() extends Callable {
//│     def apply2(arg$0,arg$1) =
//│       let* (x$1) = add(arg$0,arg$1) in
//│       x$1
//│   }
//│   def add(a,b) =
//│     let x$0 = +(a,b) in
//│     x$0
//│   def dummy() =
//│     let x$2 = Lambda$0() in
//│     x$2
//│   let* (x$3) = dummy() in
//│   let x$4 = Callable.apply2(x$3,1,2) in
//│   x$4
//│ 
//│ Cpp:
//│ #include "mlsprelude.h"
//│ struct _mls_Lambda_0;
//│ _mlsValue _mls_add(_mlsValue, _mlsValue);
//│ _mlsValue _mls_dummy();
//│ _mlsValue _mlsMain();
//│ struct _mls_Lambda_0: public _mls_Callable {
//│   
//│   constexpr static inline const char *typeName = "Lambda$0";
//│   constexpr static inline uint32_t typeTag = nextTypeTag();
//│   virtual void print() const override { std::printf("%s", typeName); }
//│   virtual void destroy() override {  operator delete (this, std::align_val_t(_mlsAlignment)); }
//│   static _mlsValue create() { auto _mlsVal = new (std::align_val_t(_mlsAlignment)) _mls_Lambda_0; _mlsVal->refCount = 1; _mlsVal->tag = typeTag;  return _mlsValue(_mlsVal); }
//│   virtual _mlsValue _mls_apply2(_mlsValue _mls_arg_0, _mlsValue _mls_arg_1) {
//│     _mlsValue _mls_retval;
//│     auto _mls_x_1 = _mls_add(_mls_arg_0, _mls_arg_1);
//│     _mls_retval = _mls_x_1;
//│     return _mls_retval;
//│   }
//│ };
//│ _mlsValue _mls_add(_mlsValue _mls_a, _mlsValue _mls_b) {
//│   _mlsValue _mls_retval;
//│   auto _mls_x_0 = (_mls_a + _mls_b);
//│   _mls_retval = _mls_x_0;
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_dummy() {
//│   _mlsValue _mls_retval;
//│   auto _mls_x_2 = _mlsValue::create<_mls_Lambda_0>();
//│   _mls_retval = _mls_x_2;
//│   return _mls_retval;
//│ }
//│ _mlsValue _mlsMain() {
//│   _mlsValue _mls_retval;
//│   auto _mls_x_3 = _mls_dummy();
//│   auto _mls_x_4 = _mlsMethodCall<_mls_Callable>(_mls_x_3)->_mls_apply2(_mlsValue::fromIntLit(1), _mlsValue::fromIntLit(2));
//│   _mls_retval = _mls_x_4;
//│   return _mls_retval;
//│ }
//│ int main() { return _mlsLargeStack(_mlsMainWrapper); }
//│ 
//│ Interpreted:
//│ 3

:sllir
:intl
abstract class List[out T]: Cons[T] | Nil
class (::) Cons[out T](head: T, tail: List[T]) extends List[T]
object Nil extends List
fun map(f, l) =
  if l is
    Cons(h, t) then Cons(f(h), map(f, t))
    Nil then Nil
fun inc(x) = x + 1
fun main() =
  map(x => inc(x), 1 :: 2 :: Nil)
  map(inc, 3 :: 4 :: Nil)
main()
//│ = Cons(4, Cons(5, Nil))
//│ LLIR:
//│   class List()
//│   class Cons(head,tail) extends List
//│   class Nil() extends List
//│   class Lambda$0() extends Callable {
//│     def apply1(x1) =
//│       let* (x$10) = inc(x1) in
//│       x$10
//│   }
//│   class Lambda$1() extends Callable {
//│     def apply1(arg$0) =
//│       let* (x$16) = inc(arg$0) in
//│       x$16
//│   }
//│   def map(f,l) =
//│     case l of
//│       Cons =>
//│         let x$0 = l.<Cons:head> in
//│         let x$1 = l.<Cons:tail> in
//│         let x$2 = Callable.apply1(f,x$0) in
//│         let* (x$3) = map(f,x$1) in
//│         let x$4 = Cons(x$2,x$3) in
//│         x$4
//│       _ =>
//│         case l of
//│           Nil =>
//│             let x$5 = Nil() in
//│             x$5
//│           _ =>
//│             panic "match error"
//│   def j$1() =
//│     jump j$0()
//│   def j$0() =
//│     null
//│   def inc(x) =
//│     let x$6 = +(x,1) in
//│     x$6
//│   def main() =
//│     let x$7 = Nil() in
//│     let x$8 = Cons(2,x$7) in
//│     let x$9 = Cons(1,x$8) in
//│     let x$11 = Lambda$0() in
//│     let* (x$12) = map(x$11,x$9) in
//│     let x$13 = Nil() in
//│     let x$14 = Cons(4,x$13) in
//│     let x$15 = Cons(3,x$14) in
//│     let x$17 = Lambda$1() in
//│     let* (x$18) = map(x$17,x$15) in
//│     x$18
//│   let* (x$19) = main() in
//│   x$19
//│ 
//│ Interpreted:
//│ Cons(4,Cons(5,Nil()))

