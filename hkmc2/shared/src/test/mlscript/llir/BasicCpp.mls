
:global
:llir
:cpp


:scpp
:sllir
fun foo(a) =
  let x
  if a > 0 do
    x = 1
  x + 1
//│ LLIR:
//│   
//│   def foo$195(a$196) =
//│     let x$204 = null in
//│     let x$205 = >(a$196,0) in
//│     case x$205 of
//│       BoolLit(true) =>
//│         let x$207 = 1 in
//│         let x$208 = undefined in
//│         jump j$206(x$207)
//│       _ =>
//│         let x$209 = undefined in
//│         jump j$206(x$204)
//│   def j$206(x$197) =
//│     let x$210 = +(x$197,1) in
//│     x$210
//│   undefined
//│ 
//│ Cpp:
//│ #include "mlsprelude.h"
//│ _mlsValue j(_mlsValue);
//│ _mlsValue foo(_mlsValue);
//│ _mlsValue _mlsMain();
//│ _mlsValue j(_mlsValue x1) {
//│   _mlsValue _mls_retval;
//│   auto x = (x1 + _mlsValue::fromIntLit(1));
//│   _mls_retval = x;
//│   return _mls_retval;
//│ }
//│ _mlsValue foo(_mlsValue a) {
//│   _mlsValue _mls_retval;
//│   auto x2 = _mlsValue::create<_mls_Unit>();
//│   auto x3 = (a > _mlsValue::fromIntLit(0));
//│   if (_mlsValue::isIntLit(x3, 1)) {
//│     auto x5 = _mlsValue::fromIntLit(1);
//│     auto x6 = _mlsValue::create<_mls_Unit>();
//│     _mls_retval = j(x5);
//│   } else {
//│     auto x4 = _mlsValue::create<_mls_Unit>();
//│     _mls_retval = j(x2);
//│   }
//│   return _mls_retval;
//│ }
//│ _mlsValue _mlsMain() {
//│   _mlsValue _mls_retval;
//│   _mls_retval = _mlsValue::create<_mls_Unit>();
//│   return _mls_retval;
//│ }
//│ int main() { return _mlsLargeStack(_mlsMainWrapper); }


