
:global
:llir
:cpp

:sllir
fun foo(a) =
  let x
  if a > 0 do
    x = 1
  x + 1
//│ LLIR:
//│   
//│   def foo$216(a$217) =
//│     let x$224 = null in
//│     let x$225 = >(a$217,0) in
//│     case x$225 of
//│       BoolLit(true) =>
//│         let x$227 = 1 in
//│         let x$228 = undefined in
//│         jump j$226(x$227)
//│       _ =>
//│         let x$229 = undefined in
//│         jump j$226(x$224)
//│   def j$226(x$218) =
//│     let x$230 = +(x$218,1) in
//│     x$230
//│   undefined

:showWholeCpp
fun bar(x) =
  x + 1
foo(1)
//│ 
//│ WholeProgramCpp:
//│ #include "mlsprelude.h"
//│ _mlsValue _mls_j(_mlsValue);
//│ _mlsValue _mls_foo(_mlsValue);
//│ _mlsValue _mls_bar(_mlsValue);
//│ _mlsValue _mlsMain();
//│ _mlsValue _mls_j(_mlsValue _mls_x1) {
//│   _mlsValue _mls_retval;
//│   auto _mls_x = (_mls_x1 + _mlsValue::fromIntLit(1));
//│   _mls_retval = _mls_x;
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_foo(_mlsValue _mls_a) {
//│   _mlsValue _mls_retval;
//│   auto _mls_x2 = _mlsValue::create<_mls_Unit>();
//│   auto _mls_x3 = (_mls_a > _mlsValue::fromIntLit(0));
//│   if (_mlsValue::isIntLit(_mls_x3, 1)) {
//│     auto _mls_x5 = _mlsValue::fromIntLit(1);
//│     auto _mls_x6 = _mlsValue::create<_mls_Unit>();
//│     _mls_retval = _mls_j(_mls_x5);
//│   } else {
//│     auto _mls_x4 = _mlsValue::create<_mls_Unit>();
//│     _mls_retval = _mls_j(_mls_x2);
//│   }
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_bar(_mlsValue _mls_x8) {
//│   _mlsValue _mls_retval;
//│   auto _mls_x7 = (_mls_x8 + _mlsValue::fromIntLit(1));
//│   _mls_retval = _mls_x7;
//│   return _mls_retval;
//│ }
//│ _mlsValue _mlsMain() {
//│   _mlsValue _mls_retval;
//│   auto _mls_x9 = _mls_foo(_mlsValue::fromIntLit(1));
//│   _mls_retval = _mls_x9;
//│   return _mls_retval;
//│ }
//│ int main() { return _mlsLargeStack(_mlsMainWrapper); }
