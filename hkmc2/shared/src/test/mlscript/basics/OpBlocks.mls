:js


:todo
fun f(x) = x
  + 1
//│ /!!!\ Uncaught error: scala.MatchError: OpBlock(List((Ident(+),IntLit(1)))) (of class hkmc2.syntax.Tree$OpBlock)

:todo
fun f(x) = x
  * 2
  + 1
//│ /!!!\ Uncaught error: scala.MatchError: OpBlock(List((Ident(*),IntLit(2)), (Ident(+),IntLit(1)))) (of class hkmc2.syntax.Tree$OpBlock)

:pt
:todo
fun f(x) = x
  + 1
  * 2
//│ Parsed tree:
//│ TermDef:
//│   k = Fun
//│   head = App:
//│     lhs = Ident of "f"
//│     rhs = Tup of Ls of 
//│       Ident of "x"
//│   rhs = S of App:
//│     lhs = Ident of "x"
//│     rhs = OpBlock of Ls of 
//│       Tuple2:
//│         _1 = Ident of "+"
//│         _2 = IntLit of 1
//│       Tuple2:
//│         _1 = Ident of "*"
//│         _2 = IntLit of 2
//│ /!!!\ Uncaught error: scala.MatchError: OpBlock(List((Ident(+),IntLit(1)), (Ident(*),IntLit(2)))) (of class hkmc2.syntax.Tree$OpBlock)

:pt
:todo
fun f(x) = x
  + 1
    * 2
//│ Parsed tree:
//│ TermDef:
//│   k = Fun
//│   head = App:
//│     lhs = Ident of "f"
//│     rhs = Tup of Ls of 
//│       Ident of "x"
//│   rhs = S of App:
//│     lhs = Ident of "x"
//│     rhs = OpBlock of Ls of 
//│       Tuple2:
//│         _1 = Ident of "+"
//│         _2 = App:
//│           lhs = IntLit of 1
//│           rhs = OpBlock of Ls of 
//│             Tuple2:
//│               _1 = Ident of "*"
//│               _2 = IntLit of 2
//│ /!!!\ Uncaught error: scala.MatchError: OpBlock(List((Ident(+),App(IntLit(1),OpBlock(List((Ident(*),IntLit(2)))))))) (of class hkmc2.syntax.Tree$OpBlock)


:pe
:fixme
fun f(x) = x { + 1, * 2 }
//│ ╔══[PARSE ERROR] Unexpected comma in this position
//│ ║  l.66: 	fun f(x) = x { + 1, * 2 }
//│ ╙──      	                  ^
//│ ╔══[PARSE ERROR] Unexpected operator here
//│ ║  l.66: 	fun f(x) = x { + 1, * 2 }
//│ ╙──      	                    ^
//│ /!!!\ Uncaught error: scala.MatchError: OpBlock(List((Ident(+),IntLit(1)))) (of class hkmc2.syntax.Tree$OpBlock)


:pt
fun f(x) = if x
  == 0 then "a"
  > 1 then "b"
//│ Parsed tree:
//│ TermDef:
//│   k = Fun
//│   head = App:
//│     lhs = Ident of "f"
//│     rhs = Tup of Ls of 
//│       Ident of "x"
//│   rhs = S of If of App:
//│     lhs = Ident of "x"
//│     rhs = OpBlock of Ls of 
//│       Tuple2:
//│         _1 = Ident of "=="
//│         _2 = InfixApp:
//│           lhs = IntLit of 0
//│           kw = keyword 'then'
//│           rhs = StrLit of "a"
//│       Tuple2:
//│         _1 = Ident of ">"
//│         _2 = InfixApp:
//│           lhs = IntLit of 1
//│           kw = keyword 'then'
//│           rhs = StrLit of "b"

f(0)
//│ = 'a'

:re
f(1)
//│ ═══[RUNTIME ERROR] Error: match error

f(2)
//│ = 'b'


:pe
:pt
:e
fun f(x) = if x
  > 0 then "a"
  is 0 then "b"
//│ ╔══[PARSE ERROR] Expect an operator instead of 'is' keyword
//│ ║  l.119: 	  is 0 then "b"
//│ ╙──       	  ^^
//│ ╔══[PARSE ERROR] Unexpected 'is' keyword here
//│ ║  l.119: 	  is 0 then "b"
//│ ╙──       	  ^^
//│ Parsed tree:
//│ TermDef:
//│   k = Fun
//│   head = App:
//│     lhs = Ident of "f"
//│     rhs = Tup of Ls of 
//│       Ident of "x"
//│   rhs = S of If of App:
//│     lhs = Ident of "x"
//│     rhs = OpBlock of Ls of 
//│       Tuple2:
//│         _1 = Ident of ">"
//│         _2 = InfixApp:
//│           lhs = IntLit of 0
//│           kw = keyword 'then'
//│           rhs = StrLit of "a"
//│       Tuple2:
//│         _1 = Error
//│         _2 = Error
//│ ═══[ERROR] Unrecognized operator branch.


:todo
:pt
:e
fun f(x) = if x
  foo(A) then a
  bar(B) then b
//│ Parsed tree:
//│ TermDef:
//│   k = Fun
//│   head = App:
//│     lhs = Ident of "f"
//│     rhs = Tup of Ls of 
//│       Ident of "x"
//│   rhs = S of If of Jux:
//│     lhs = Ident of "x"
//│     rhs = Block of Ls of 
//│       InfixApp:
//│         lhs = App:
//│           lhs = Ident of "foo"
//│           rhs = Tup of Ls of 
//│             Ident of "A"
//│         kw = keyword 'then'
//│         rhs = Ident of "a"
//│       InfixApp:
//│         lhs = App:
//│           lhs = Ident of "bar"
//│           rhs = Tup of Ls of 
//│             Ident of "B"
//│         kw = keyword 'then'
//│         rhs = Ident of "b"
//│ ╔══[ERROR] Unrecognized term split (juxtaposition).
//│ ║  l.151: 	fun f(x) = if x
//│ ║         	              ^
//│ ║  l.152: 	  foo(A) then a
//│ ║         	^^^^^^^^^^^^^^^
//│ ║  l.153: 	  bar(B) then b
//│ ╙──       	^^^^^^^^^^^^^^^


:pe
fun f(x) = if x
  is 0 then "a"
  is 1 then "b"
//│ ╔══[PARSE ERROR] Expected 'let' keyword, 'set' keyword, 'new' keyword, 'in' keyword, 'if' keyword, 'else' keyword, 'case' keyword, 'region' keyword, 'fun' keyword, 'val' keyword, 'type' keyword, 'class' keyword, 'trait' keyword, 'module' keyword, 'open' keyword, 'abstract' keyword, 'mut' keyword, 'virtual' keyword, 'override' keyword, 'declare' keyword, 'public' keyword, 'private' keyword, 'out' keyword, 'return' keyword, 'import' keyword, 'true' keyword, 'false' keyword, 'undefined' keyword, 'null' keyword, 'this' keyword, or expression after start of statement; found 'is' keyword instead
//│ ║  l.190: 	  is 1 then "b"
//│ ╙──       	  ^^
//│ ╔══[PARSE ERROR] Expected end of input; found literal instead
//│ ║  l.190: 	  is 1 then "b"
//│ ╙──       	     ^
//│ = [Function: f]


