:NewParser
:ParseOnly

_LUMBERHACK_EVAL
fun inter(xs) = if xs is
  N then ys => ys
  C(h, t) then ys => C(h, inter(ys)(t))
inter(N)(N)
//│ |_LUMBERHACK_EVAL|↵|#fun| |inter|(|xs|)| |#=| |#if| |xs| |is|→|N| |#then| |ys| |=>| |ys|↵|C|(|h|,| |t|)| |#then| |ys| |=>| |C|(|h|,| |inter|(|ys|)|(|t|)|)|←|↵|inter|(|N|)|(|N|)|
//│ Parsed: {_LUMBERHACK_EVAL; fun inter = xs, => if xs is ‹(N) then ys, => ys; (C (h, t,)) then ys, => C (h, inter (ys,) (t,),)›; inter (N,) (N,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ inter^14([N], [N])
//│ def inter(xs⁰) = case xs⁰ of {
//│ 	N  => (fun ys⁰ -> ys⁰)
//│ 	| C h⁰ t⁰ => (fun ys¹ -> [C h⁰ inter^5(ys¹, t⁰)])}
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>>>>> Original Eval Res >>>>>>>>>>
//│ [N]
//│ <<<<<<<<<< Original Eval Res <<<<<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [N]: 15 --->
//│ 	case xs⁰ of {N  => (fun ys⁰ -> ys⁰) | C h⁰ t⁰ => (fun ys¹ -> [C h⁰ inter(ys¹, t⁰)])}: 12
//│ [N]: 17 --->
//│ 	NoCons
//│ 	case xs⁰ of {N  => (fun ys⁰ -> ys⁰) | C h⁰ t⁰ => (fun ys¹ -> [C h⁰ inter(ys¹, t⁰)])}: 12
//│ ------------------
//│ case xs⁰ of {N  => (fun ys⁰ -> ys⁰) | C h⁰ t⁰ => (fun ys¹ -> [C h⁰ inter(ys¹, t⁰)])}: 12 --->
//│ 	DeadCodeProd
//│ 	[N]: 15
//│ 	[N]: 17
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ 
//│ ------------------
//│ 
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ inter([N], [N])
//│ def inter(xs¹) = case xs¹ of {
//│ 	N  => (fun ys² -> ys²)
//│ 	| C h⁰ t⁰ => (fun ys³ -> [C h⁰ inter(ys³, t⁰)])}
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>> evaluate >>>>>>>
//│ [N]
//│ <<<<<<< evaluate <<<<<<<
//│ 
//│ >>>>>>> consumer ids >>>>>>>
//│ 
//│ <<<<<<< consumer ids <<<<<<<
//│ 
//│ >>>>>>> floating out info >>>>>>>
//│ 
//│ <<<<<<< floating out info <<<<<<<
//│ 
//│ >>>>>>> after inlining >>>>>>>
//│ inter([N], [N])
//│ def inter(xs⁰) = case xs⁰ of {
//│ 	N  => (fun ys⁰ -> ys⁰)
//│ 	| C h⁰ t⁰ => (fun ys¹ -> [C h⁰ inter(ys¹, t⁰)])}
//│ <<<<<<< after inlining <<<<<<<
//│ 
//│ >>>>>>> after floating out >>>>>>>
//│ inter([N], [N])
//│ def inter(xs⁰) = case xs⁰ of {
//│ 	N  => (fun ys⁰ -> ys⁰)
//│ 	| C h⁰ t⁰ => (fun ys¹ -> [C h⁰ inter(ys¹, t⁰)])}
//│ <<<<<<< after floating out <<<<<<<


_LUMBERHACK_EVAL
fun inter(xs) = if xs is
  N then ys => ys
  C(h, t) then ys => C(h, inter(ys)(t))
let l1 = C(1, C(2, N))
let l2 = C(9, C(10, N))
inter(l1)(l2)
//│ |_LUMBERHACK_EVAL|↵|#fun| |inter|(|xs|)| |#=| |#if| |xs| |is|→|N| |#then| |ys| |=>| |ys|↵|C|(|h|,| |t|)| |#then| |ys| |=>| |C|(|h|,| |inter|(|ys|)|(|t|)|)|←|↵|#let| |l1| |#=| |C|(|1|,| |C|(|2|,| |N|)|)|↵|#let| |l2| |#=| |C|(|9|,| |C|(|10|,| |N|)|)|↵|inter|(|l1|)|(|l2|)|
//│ Parsed: {_LUMBERHACK_EVAL; fun inter = xs, => if xs is ‹(N) then ys, => ys; (C (h, t,)) then ys, => C (h, inter (ys,) (t,),)›; let l1 = C (1, C (2, N,),); let l2 = C (9, C (10, N,),); inter (l1,) (l2,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ inter^24(l1^25, l2^27)
//│ def inter(xs⁰) = case xs⁰ of {
//│ 	N  => (fun ys⁰ -> ys⁰)
//│ 	| C h⁰ t⁰ => (fun ys¹ -> [C h⁰ inter^5(ys¹, t⁰)])}
//│ def l1 = [C 1 [C 2 [N]]]
//│ def l2 = [C 9 [C 10 [N]]]
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>>>>> Original Eval Res >>>>>>>>>>
//│ [C 1 [C 9 [C 2 [C 10 [N]]]]]
//│ <<<<<<<<<< Original Eval Res <<<<<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [N]: 16 --->
//│ 	NoCons
//│ 	case xs⁰ of {N  => (fun ys⁰ -> ys⁰) | C h⁰ t⁰ => (fun ys¹ -> [C h⁰ inter(ys¹, t⁰)])}: 12
//│ [C 2 [N]]: 17 --->
//│ 	NoCons
//│ 	case xs⁰ of {N  => (fun ys⁰ -> ys⁰) | C h⁰ t⁰ => (fun ys¹ -> [C h⁰ inter(ys¹, t⁰)])}: 12
//│ [C 1 [C 2 [N]]]: 18 --->
//│ 	case xs⁰ of {N  => (fun ys⁰ -> ys⁰) | C h⁰ t⁰ => (fun ys¹ -> [C h⁰ inter(ys¹, t⁰)])}: 12
//│ [N]: 21 --->
//│ 	NoCons
//│ 	case xs⁰ of {N  => (fun ys⁰ -> ys⁰) | C h⁰ t⁰ => (fun ys¹ -> [C h⁰ inter(ys¹, t⁰)])}: 12
//│ [C 10 [N]]: 22 --->
//│ 	NoCons
//│ 	case xs⁰ of {N  => (fun ys⁰ -> ys⁰) | C h⁰ t⁰ => (fun ys¹ -> [C h⁰ inter(ys¹, t⁰)])}: 12
//│ [C 9 [C 10 [N]]]: 23 --->
//│ 	NoCons
//│ 	case xs⁰ of {N  => (fun ys⁰ -> ys⁰) | C h⁰ t⁰ => (fun ys¹ -> [C h⁰ inter(ys¹, t⁰)])}: 12
//│ ------------------
//│ case xs⁰ of {N  => (fun ys⁰ -> ys⁰) | C h⁰ t⁰ => (fun ys¹ -> [C h⁰ inter(ys¹, t⁰)])}: 12 --->
//│ 	[N]: 16
//│ 	[C 2 [N]]: 17
//│ 	[C 1 [C 2 [N]]]: 18
//│ 	[N]: 21
//│ 	[C 10 [N]]: 22
//│ 	[C 9 [C 10 [N]]]: 23
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ 
//│ ------------------
//│ 
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ inter(l1, l2)
//│ def inter(xs¹) = case xs¹ of {
//│ 	N  => (fun ys² -> ys²)
//│ 	| C h⁰ t⁰ => (fun ys³ -> [C h⁰ inter(ys³, t⁰)])}
//│ def l1 = [C 1 [C 2 [N]]]
//│ def l2 = [C 9 [C 10 [N]]]
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>> evaluate >>>>>>>
//│ [C 1 [C 9 [C 2 [C 10 [N]]]]]
//│ <<<<<<< evaluate <<<<<<<
//│ 
//│ >>>>>>> consumer ids >>>>>>>
//│ 
//│ <<<<<<< consumer ids <<<<<<<
//│ 
//│ >>>>>>> floating out info >>>>>>>
//│ 
//│ <<<<<<< floating out info <<<<<<<
//│ 
//│ >>>>>>> after inlining >>>>>>>
//│ inter(l1, l2)
//│ def inter(xs⁰) = case xs⁰ of {
//│ 	N  => (fun ys⁰ -> ys⁰)
//│ 	| C h⁰ t⁰ => (fun ys¹ -> [C h⁰ inter(ys¹, t⁰)])}
//│ def l1 = [C 1 [C 2 [N]]]
//│ def l2 = [C 9 [C 10 [N]]]
//│ <<<<<<< after inlining <<<<<<<
//│ 
//│ >>>>>>> after floating out >>>>>>>
//│ inter(l1, l2)
//│ def inter(xs⁰) = case xs⁰ of {
//│ 	N  => (fun ys⁰ -> ys⁰)
//│ 	| C h⁰ t⁰ => (fun ys¹ -> [C h⁰ inter(ys¹, t⁰)])}
//│ def l1 = [C 1 [C 2 [N]]]
//│ def l2 = [C 9 [C 10 [N]]]
//│ <<<<<<< after floating out <<<<<<<

fun inter(xs) = if xs is
  N then ys => ys
  C(h, t) then ys => C(h, inter(ys)(t))
let l1 = C(1, C(2, l1))
let l2 = C(9, l2)
inter(l1)(l2)
//│ |#fun| |inter|(|xs|)| |#=| |#if| |xs| |is|→|N| |#then| |ys| |=>| |ys|↵|C|(|h|,| |t|)| |#then| |ys| |=>| |C|(|h|,| |inter|(|ys|)|(|t|)|)|←|↵|#let| |l1| |#=| |C|(|1|,| |C|(|2|,| |l1|)|)|↵|#let| |l2| |#=| |C|(|9|,| |l2|)|↵|inter|(|l1|)|(|l2|)|
//│ Parsed: {fun inter = xs, => if xs is ‹(N) then ys, => ys; (C (h, t,)) then ys, => C (h, inter (ys,) (t,),)›; let l1 = C (1, C (2, l1,),); let l2 = C (9, l2,); inter (l1,) (l2,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ inter^22(l1^23, l2^25)
//│ def inter(xs⁰) = case xs⁰ of {
//│ 	N  => (fun ys⁰ -> ys⁰)
//│ 	| C h⁰ t⁰ => (fun ys¹ -> [C h⁰ inter^5(ys¹, t⁰)])}
//│ def l1 = [C 1 [C 2 l1^16]]
//│ def l2 = [C 9 l2^20]
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C 2 l1]: 17 --->
//│ 	NoCons
//│ 	case xs⁰ of {N  => (fun ys⁰ -> ys⁰) | C h⁰ t⁰ => (fun ys¹ -> [C h⁰ inter(ys¹, t⁰)])}: 12
//│ [C 1 [C 2 l1]]: 18 --->
//│ 	NoCons
//│ 	case xs⁰ of {N  => (fun ys⁰ -> ys⁰) | C h⁰ t⁰ => (fun ys¹ -> [C h⁰ inter(ys¹, t⁰)])}: 12
//│ [C 9 l2]: 21 --->
//│ 	NoCons
//│ 	case xs⁰ of {N  => (fun ys⁰ -> ys⁰) | C h⁰ t⁰ => (fun ys¹ -> [C h⁰ inter(ys¹, t⁰)])}: 12
//│ ------------------
//│ case xs⁰ of {N  => (fun ys⁰ -> ys⁰) | C h⁰ t⁰ => (fun ys¹ -> [C h⁰ inter(ys¹, t⁰)])}: 12 --->
//│ 	[C 2 l1]: 17
//│ 	[C 1 [C 2 l1]]: 18
//│ 	[C 9 l2]: 21
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ 
//│ ------------------
//│ 
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ inter(l1, l2)
//│ def inter(xs¹) = case xs¹ of {
//│ 	N  => (fun ys² -> ys²)
//│ 	| C h⁰ t⁰ => (fun ys³ -> [C h⁰ inter(ys³, t⁰)])}
//│ def l1 = [C 1 [C 2 l1]]
//│ def l2 = [C 9 l2]
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>> consumer ids >>>>>>>
//│ 
//│ <<<<<<< consumer ids <<<<<<<
//│ 
//│ >>>>>>> floating out info >>>>>>>
//│ 
//│ <<<<<<< floating out info <<<<<<<
//│ 
//│ >>>>>>> after inlining >>>>>>>
//│ inter(l1, l2)
//│ def inter(xs⁰) = case xs⁰ of {
//│ 	N  => (fun ys⁰ -> ys⁰)
//│ 	| C h⁰ t⁰ => (fun ys¹ -> [C h⁰ inter(ys¹, t⁰)])}
//│ def l1 = [C 1 [C 2 l1]]
//│ def l2 = [C 9 l2]
//│ <<<<<<< after inlining <<<<<<<
//│ 
//│ >>>>>>> after floating out >>>>>>>
//│ inter(l1, l2)
//│ def inter(xs⁰) = case xs⁰ of {
//│ 	N  => (fun ys⁰ -> ys⁰)
//│ 	| C h⁰ t⁰ => (fun ys¹ -> [C h⁰ inter(ys¹, t⁰)])}
//│ def l1 = [C 1 [C 2 l1]]
//│ def l2 = [C 9 l2]
//│ <<<<<<< after floating out <<<<<<<


// NOTE: maybe more fusion can be done
fun f(x) = if x is
  C(a) then
    if a is
      A then N
      B then g(D(a))
fun g(y) = if y is
  D(b) then
    if b is
      A then N
      B then f(C(b))
f(C(A))
//│ |#fun| |f|(|x|)| |#=| |#if| |x| |is|→|C|(|a|)| |#then|→|#if| |a| |is|→|A| |#then| |N|↵|B| |#then| |g|(|D|(|a|)|)|←|←|←|↵|#fun| |g|(|y|)| |#=| |#if| |y| |is|→|D|(|b|)| |#then|→|#if| |b| |is|→|A| |#then| |N|↵|B| |#then| |f|(|C|(|b|)|)|←|←|←|↵|f|(|C|(|A|)|)|
//│ Parsed: {fun f = x, => if x is ‹(C (a,)) then {if a is ‹(A) then N; (B) then g (D (a,),)›}›; fun g = y, => if y is ‹(D (b,)) then {if b is ‹(A) then N; (B) then f (C (b,),)›}›; f (C (A,),)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ f^21([C [A]])
//│ def f(x⁰) = case x⁰ of {
//│ 	C a⁰ => case a⁰ of {
//│ 		A  => [N]
//│ 		| B  => g^4([D a⁰])}}
//│ def g(y⁰) = case y⁰ of {
//│ 	D b⁰ => case b⁰ of {
//│ 		A  => [N]
//│ 		| B  => f^14([C b⁰])}}
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [D a⁰]: 6 --->
//│ 	case y⁰ of {D b⁰ => case b⁰ of {A  => [N] | B  => f([C b⁰])}}: 19
//│ [C b⁰]: 16 --->
//│ 	case x⁰ of {C a⁰ => case a⁰ of {A  => [N] | B  => g([D a⁰])}}: 9
//│ [A]: 22 --->
//│ 	case a⁰ of {A  => [N] | B  => g([D a⁰])}: 8
//│ 	case b⁰ of {A  => [N] | B  => f([C b⁰])}: 18
//│ [C [A]]: 23 --->
//│ 	case x⁰ of {C a⁰ => case a⁰ of {A  => [N] | B  => g([D a⁰])}}: 9
//│ ------------------
//│ case a⁰ of {A  => [N] | B  => g([D a⁰])}: 8 --->
//│ 	[A]: 22
//│ case x⁰ of {C a⁰ => case a⁰ of {A  => [N] | B  => g([D a⁰])}}: 9 --->
//│ 	[C b⁰]: 16
//│ 	[C [A]]: 23
//│ case b⁰ of {A  => [N] | B  => f([C b⁰])}: 18 --->
//│ 	[A]: 22
//│ case y⁰ of {D b⁰ => case b⁰ of {A  => [N] | B  => f([C b⁰])}}: 19 --->
//│ 	[D a⁰]: 6
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ 
//│ ------------------
//│ 
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ f([C [A]])
//│ def f(x¹) = case x¹ of {
//│ 	C a⁰ => case a⁰ of {
//│ 		A  => [N]
//│ 		| B  => g([D a⁰])}}
//│ def g(y¹) = case y¹ of {
//│ 	D b⁰ => case b⁰ of {
//│ 		A  => [N]
//│ 		| B  => f([C b⁰])}}
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>> consumer ids >>>>>>>
//│ 
//│ <<<<<<< consumer ids <<<<<<<
//│ 
//│ >>>>>>> floating out info >>>>>>>
//│ 
//│ <<<<<<< floating out info <<<<<<<
//│ 
//│ >>>>>>> after inlining >>>>>>>
//│ f([C [A]])
//│ def f(x⁰) = case x⁰ of {
//│ 	C a⁰ => case a⁰ of {
//│ 		A  => [N]
//│ 		| B  => g([D a⁰])}}
//│ def g(y⁰) = case y⁰ of {
//│ 	D b⁰ => case b⁰ of {
//│ 		A  => [N]
//│ 		| B  => f([C b⁰])}}
//│ <<<<<<< after inlining <<<<<<<
//│ 
//│ >>>>>>> after floating out >>>>>>>
//│ f([C [A]])
//│ def f(x⁰) = case x⁰ of {
//│ 	C a⁰ => case a⁰ of {
//│ 		A  => [N]
//│ 		| B  => g([D a⁰])}}
//│ def g(y⁰) = case y⁰ of {
//│ 	D b⁰ => case b⁰ of {
//│ 		A  => [N]
//│ 		| B  => f([C b⁰])}}
//│ <<<<<<< after floating out <<<<<<<


// NOTE: problem resolved by thunking the computation inside the branch
fun c(x) = if x is
  C(a) then primitive(a) // print(a)
fun f(a) = if False then c(a) else Unit
f(C(A))
//│ |#fun| |c|(|x|)| |#=| |#if| |x| |is|→|C|(|a|)| |#then| |primitive|(|a|)| |/* print(a)*/|←|↵|#fun| |f|(|a|)| |#=| |#if| |False| |#then| |c|(|a|)| |#else| |Unit|↵|f|(|C|(|A|)|)|
//│ Parsed: {fun c = x, => if x is ‹(C (a,)) then primitive (a,)›; fun f = a, => if (False) then c (a,) else Unit; f (C (A,),)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ f^14([C [A]])
//│ def c(x⁰) = case x⁰ of {
//│ 	C a⁰ => primitive⁰(a⁰)}
//│ def f(a¹) = if [False] then c^8(a¹) else [Unit]
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C [A]]: 16 --->
//│ 	case x⁰ of {C a⁰ => primitive⁰(a⁰)}: 5
//│ ------------------
//│ case x⁰ of {C a⁰ => primitive⁰(a⁰)}: 5 --->
//│ 	[C [A]]: 16
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [C [A]]: 16 --->
//│ 	case x⁰ of {C a⁰ => primitive⁰(a⁰)}: 5
//│ ------------------
//│ case x⁰ of {C a⁰ => primitive⁰(a⁰)}: 5 --->
//│ 	[C [A]]: 16
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ f(
//│ 	let a² = [A]
//│ 	in (fun _lh_dummy⁰ -> primitive⁰(a²)))
//│ def c(x¹) = x¹(99)
//│ def f(a³) = if [False] then c(a³) else [Unit]
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>> consumer ids >>>>>>>
//│ c
//│ <<<<<<< consumer ids <<<<<<<
//│ 
//│ >>>>>>> floating out info >>>>>>>
//│ 
//│ <<<<<<< floating out info <<<<<<<
//│ 
//│ >>>>>>> after inlining >>>>>>>
//│ f(
//│ 	let a⁰ = [A]
//│ 	in (fun _lh_dummy⁰ -> primitive⁰(a⁰)))
//│ def c(x⁰) = x⁰(99)
//│ def f(a¹) = if [False] then a¹(99) else [Unit]
//│ <<<<<<< after inlining <<<<<<<
//│ 
//│ >>>>>>> after floating out >>>>>>>
//│ f(
//│ 	let a⁰ = [A]
//│ 	in (fun _lh_dummy⁰ -> primitive⁰(a⁰)))
//│ def c(x⁰) = x⁰(99)
//│ def f(a¹) = if [False] then a¹(99) else [Unit]
//│ <<<<<<< after floating out <<<<<<<


fun f(xs, ys) = if xs is
  N then 0
  _ then if xs is
    C(h, t) then if ys is
      C(hh, yt) then h + hh
      _ then h
    _ then error
f(C(1, N), C(2, N))
//│ |#fun| |f|(|xs|,| |ys|)| |#=| |#if| |xs| |is|→|N| |#then| |0|↵|_| |#then| |#if| |xs| |is|→|C|(|h|,| |t|)| |#then| |#if| |ys| |is|→|C|(|hh|,| |yt|)| |#then| |h| |+| |hh|↵|_| |#then| |h|←|↵|_| |#then| |error|←|←|↵|f|(|C|(|1|,| |N|)|,| |C|(|2|,| |N|)|)|
//│ Parsed: {fun f = xs, ys, => if xs is ‹(N) then 0; (_) then if xs is ‹(C (h, t,)) then if ys is ‹(C (hh, yt,)) then + (h,) (hh,); (_) then h›; (_) then error››; f (C (1, N,), C (2, N,),)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ f^17([C 1 [N]], [C 2 [N]])
//│ def f(xs⁰, ys⁰) = case xs⁰ of {
//│ 	N  => 0
//│ 	| _  => case xs⁰ of {
//│ 		C h⁰ t⁰ => case ys⁰ of {
//│ 			C hh⁰ yt⁰ => (h⁰ + hh⁰)
//│ 			| _  => h⁰}
//│ 		| _  => error⁰}}
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C 1 [N]]: 20 --->
//│ 	case xs⁰ of {C h⁰ t⁰ => case ys⁰ of {C hh⁰ yt⁰ => (h⁰ + hh⁰) | _  => h⁰} | _  => error⁰}: 13
//│ 	case xs⁰ of {N  => 0 | _  => case xs⁰ of {C h⁰ t⁰ => case ys⁰ of {C hh⁰ yt⁰ => (h⁰ + hh⁰) | _  => h⁰} | _  => error⁰}}: 14
//│ [C 2 [N]]: 24 --->
//│ 	case ys⁰ of {C hh⁰ yt⁰ => (h⁰ + hh⁰) | _  => h⁰}: 11
//│ ------------------
//│ case ys⁰ of {C hh⁰ yt⁰ => (h⁰ + hh⁰) | _  => h⁰}: 11 --->
//│ 	[C 2 [N]]: 24
//│ case xs⁰ of {C h⁰ t⁰ => case ys⁰ of {C hh⁰ yt⁰ => (h⁰ + hh⁰) | _  => h⁰} | _  => error⁰}: 13 --->
//│ 	[C 1 [N]]: 20
//│ case xs⁰ of {N  => 0 | _  => case xs⁰ of {C h⁰ t⁰ => case ys⁰ of {C hh⁰ yt⁰ => (h⁰ + hh⁰) | _  => h⁰} | _  => error⁰}}: 14 --->
//│ 	[C 1 [N]]: 20
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [C 2 [N]]: 24 --->
//│ 	case ys⁰ of {C hh⁰ yt⁰ => (h⁰ + hh⁰) | _  => h⁰}: 11
//│ ------------------
//│ case ys⁰ of {C hh⁰ yt⁰ => (h⁰ + hh⁰) | _  => h⁰}: 11 --->
//│ 	[C 2 [N]]: 24
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ f([C 1 [N]], 
//│ 	let yt¹ = [N]
//│ 	in let hh¹ = 2
//│ 	in (fun h¹ -> (h¹ + hh¹)))
//│ def f(xs¹, ys¹) = case xs¹ of {
//│ 	N  => 0
//│ 	| _  => case xs¹ of {
//│ 		C h⁰ t⁰ => ys¹(h⁰)
//│ 		| _  => error⁰}}
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>> consumer ids >>>>>>>
//│ f
//│ <<<<<<< consumer ids <<<<<<<
//│ 
//│ >>>>>>> floating out info >>>>>>>
//│ 
//│ <<<<<<< floating out info <<<<<<<
//│ 
//│ >>>>>>> after inlining >>>>>>>
//│ case [C 1 [N]] of {
//│ 	N  => 0
//│ 	| _  => case [C 1 [N]] of {
//│ 		C h⁰ t⁰ => 
//│ 			let yt⁰ = [N]
//│ 			in let hh⁰ = 2
//│ 			in (fun h¹ -> (h¹ + hh⁰))(h⁰)
//│ 		| _  => error⁰}}
//│ def f(xs⁰, ys⁰) = case xs⁰ of {
//│ 	N  => 0
//│ 	| _  => case xs⁰ of {
//│ 		C h² t¹ => ys⁰(h²)
//│ 		| _  => error⁰}}
//│ <<<<<<< after inlining <<<<<<<
//│ 
//│ >>>>>>> after floating out >>>>>>>
//│ case [C 1 [N]] of {
//│ 	N  => 0
//│ 	| _  => case [C 1 [N]] of {
//│ 		C h⁰ t⁰ => 
//│ 			let yt⁰ = [N]
//│ 			in let hh⁰ = 2
//│ 			in (fun h¹ -> (h¹ + hh⁰))(h⁰)
//│ 		| _  => error⁰}}
//│ def f(xs⁰, ys⁰) = case xs⁰ of {
//│ 	N  => 0
//│ 	| _  => case xs⁰ of {
//│ 		C h² t¹ => ys⁰(h²)
//│ 		| _  => error⁰}}
//│ <<<<<<< after floating out <<<<<<<


fun f(xs) = if xs is
  N then 0
  _ then if xs is
    C(h, t) then h
    _ then error("match error")
f(C(1, N))
//│ |#fun| |f|(|xs|)| |#=| |#if| |xs| |is|→|N| |#then| |0|↵|_| |#then| |#if| |xs| |is|→|C|(|h|,| |t|)| |#then| |h|↵|_| |#then| |error|(|"match error"|)|←|←|↵|f|(|C|(|1|,| |N|)|)|
//│ Parsed: {fun f = xs, => if xs is ‹(N) then 0; (_) then if xs is ‹(C (h, t,)) then h; (_) then error ("match error",)››; f (C (1, N,),)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ f^33([C 1 [N]])
//│ def f(xs⁰) = case xs⁰ of {
//│ 	N  => 0
//│ 	| _  => case xs⁰ of {
//│ 		C h⁰ t⁰ => h⁰
//│ 		| _  => error⁰([LH_C 'm' [LH_C 'a' [LH_C 't' [LH_C 'c' [LH_C 'h' [LH_C ' ' [LH_C 'e' [LH_C 'r' [LH_C 'r' [LH_C 'o' [LH_C 'r' [LH_N]]]]]]]]]]]])}}
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C 1 [N]]: 36 --->
//│ 	case xs⁰ of {C h⁰ t⁰ => h⁰ | _  => error⁰([LH_C 'm' [LH_C 'a' [LH_C 't' [LH_C 'c' [LH_C 'h' [LH_C ' ' [LH_C 'e' [LH_C 'r' [LH_C 'r' [LH_C 'o' [LH_C 'r' [LH_N]]]]]]]]]]]])}: 30
//│ 	case xs⁰ of {N  => 0 | _  => case xs⁰ of {C h⁰ t⁰ => h⁰ | _  => error⁰([LH_C 'm' [LH_C 'a' [LH_C 't' [LH_C 'c' [LH_C 'h' [LH_C ' ' [LH_C 'e' [LH_C 'r' [LH_C 'r' [LH_C 'o' [LH_C 'r' [LH_N]]]]]]]]]]]])}}: 31
//│ ------------------
//│ case xs⁰ of {C h⁰ t⁰ => h⁰ | _  => error⁰([LH_C 'm' [LH_C 'a' [LH_C 't' [LH_C 'c' [LH_C 'h' [LH_C ' ' [LH_C 'e' [LH_C 'r' [LH_C 'r' [LH_C 'o' [LH_C 'r' [LH_N]]]]]]]]]]]])}: 30 --->
//│ 	[C 1 [N]]: 36
//│ case xs⁰ of {N  => 0 | _  => case xs⁰ of {C h⁰ t⁰ => h⁰ | _  => error⁰([LH_C 'm' [LH_C 'a' [LH_C 't' [LH_C 'c' [LH_C 'h' [LH_C ' ' [LH_C 'e' [LH_C 'r' [LH_C 'r' [LH_C 'o' [LH_C 'r' [LH_N]]]]]]]]]]]])}}: 31 --->
//│ 	[C 1 [N]]: 36
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ 
//│ ------------------
//│ 
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ f([C 1 [N]])
//│ def f(xs¹) = case xs¹ of {
//│ 	N  => 0
//│ 	| _  => case xs¹ of {
//│ 		C h⁰ t⁰ => h⁰
//│ 		| _  => error⁰([LH_C 'm' [LH_C 'a' [LH_C 't' [LH_C 'c' [LH_C 'h' [LH_C ' ' [LH_C 'e' [LH_C 'r' [LH_C 'r' [LH_C 'o' [LH_C 'r' [LH_N]]]]]]]]]]]])}}
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>> consumer ids >>>>>>>
//│ 
//│ <<<<<<< consumer ids <<<<<<<
//│ 
//│ >>>>>>> floating out info >>>>>>>
//│ 
//│ <<<<<<< floating out info <<<<<<<
//│ 
//│ >>>>>>> after inlining >>>>>>>
//│ f([C 1 [N]])
//│ def f(xs⁰) = case xs⁰ of {
//│ 	N  => 0
//│ 	| _  => case xs⁰ of {
//│ 		C h⁰ t⁰ => h⁰
//│ 		| _  => error⁰([LH_C 'm' [LH_C 'a' [LH_C 't' [LH_C 'c' [LH_C 'h' [LH_C ' ' [LH_C 'e' [LH_C 'r' [LH_C 'r' [LH_C 'o' [LH_C 'r' [LH_N]]]]]]]]]]]])}}
//│ <<<<<<< after inlining <<<<<<<
//│ 
//│ >>>>>>> after floating out >>>>>>>
//│ f([C 1 [N]])
//│ def f(xs⁰) = case xs⁰ of {
//│ 	N  => 0
//│ 	| _  => case xs⁰ of {
//│ 		C h⁰ t⁰ => h⁰
//│ 		| _  => error⁰([LH_C 'm' [LH_C 'a' [LH_C 't' [LH_C 'c' [LH_C 'h' [LH_C ' ' [LH_C 'e' [LH_C 'r' [LH_C 'r' [LH_C 'o' [LH_C 'r' [LH_N]]]]]]]]]]]])}}
//│ <<<<<<< after floating out <<<<<<<


fun f(x, y) = if x is
  N then y
  _ then y + 1
f(C(1, N), 0)
//│ |#fun| |f|(|x|,| |y|)| |#=| |#if| |x| |is|→|N| |#then| |y|↵|_| |#then| |y| |+| |1|←|↵|f|(|C|(|1|,| |N|)|,| |0|)|
//│ Parsed: {fun f = x, y, => if x is ‹(N) then y; (_) then + (y,) (1,)›; f (C (1, N,), 0,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ f^11([C 1 [N]], 0)
//│ def f(x⁰, y⁰) = case x⁰ of {
//│ 	N  => y⁰
//│ 	| _  => (y⁰ + 1)}
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [C 1 [N]]: 14 --->
//│ 	case x⁰ of {N  => y⁰ | _  => (y⁰ + 1)}: 8
//│ ------------------
//│ case x⁰ of {N  => y⁰ | _  => (y⁰ + 1)}: 8 --->
//│ 	[C 1 [N]]: 14
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [C 1 [N]]: 14 --->
//│ 	case x⁰ of {N  => y⁰ | _  => (y⁰ + 1)}: 8
//│ ------------------
//│ case x⁰ of {N  => y⁰ | _  => (y⁰ + 1)}: 8 --->
//│ 	[C 1 [N]]: 14
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ f((fun y¹ -> (y¹ + 1)), 0)
//│ def f(x¹, y²) = x¹(y²)
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>> consumer ids >>>>>>>
//│ f
//│ <<<<<<< consumer ids <<<<<<<
//│ 
//│ >>>>>>> floating out info >>>>>>>
//│ 
//│ <<<<<<< floating out info <<<<<<<
//│ 
//│ >>>>>>> after inlining >>>>>>>
//│ (fun y⁰ -> (y⁰ + 1))(0)
//│ def f(x⁰, y¹) = x⁰(y¹)
//│ <<<<<<< after inlining <<<<<<<
//│ 
//│ >>>>>>> after floating out >>>>>>>
//│ (fun y⁰ -> (y⁰ + 1))(0)
//│ def f(x⁰, y¹) = x⁰(y¹)
//│ <<<<<<< after floating out <<<<<<<


// NOTE: after registering wildcard and id match, no type error
fun zip(xs, ys) = if xs is
  N then N
  _ then if ys is
    N then N
    _ then if xs is
      C(xs, xt) then if ys is
        C(ys, yt) then C(P2(xs, ys), zip(xt, yt))
        _ then N
      _ then N
zip(C(1,N), C(2,N))
//│ |#fun| |zip|(|xs|,| |ys|)| |#=| |#if| |xs| |is|→|N| |#then| |N|↵|_| |#then| |#if| |ys| |is|→|N| |#then| |N|↵|_| |#then| |#if| |xs| |is|→|C|(|xs|,| |xt|)| |#then| |#if| |ys| |is|→|C|(|ys|,| |yt|)| |#then| |C|(|P2|(|xs|,| |ys|)|,| |zip|(|xt|,| |yt|)|)|↵|_| |#then| |N|←|↵|_| |#then| |N|←|←|←|↵|zip|(|C|(|1|,|N|)|,| |C|(|2|,|N|)|)|
//│ Parsed: {fun zip = xs, ys, => if xs is ‹(N) then N; (_) then if ys is ‹(N) then N; (_) then if xs is ‹(C (xs, xt,)) then if ys is ‹(C (ys, yt,)) then C (P2 (xs, ys,), zip (xt, yt,),); (_) then N›; (_) then N›››; zip (C (1, N,), C (2, N,),)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ zip^24([C 1 [N]], [C 2 [N]])
//│ def zip(xs⁰, ys⁰) = case xs⁰ of {
//│ 	N  => [N]
//│ 	| _  => case ys⁰ of {
//│ 		N  => [N]
//│ 		| _  => case xs⁰ of {
//│ 			C xs¹ xt⁰ => case ys⁰ of {
//│ 				C ys¹ yt⁰ => [C [P2 xs¹ ys¹] zip^10(xt⁰, yt⁰)]
//│ 				| _  => [N]}
//│ 			| _  => [N]}}}
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [N]: 26 --->
//│ 	case xs⁰ of {C xs¹ xt⁰ => case ys⁰ of {C ys¹ yt⁰ => [C [P2 xs¹ ys¹] zip(xt⁰, yt⁰)] | _  => [N]} | _  => [N]}: 19
//│ 	case xs⁰ of {N  => [N] | _  => case ys⁰ of {N  => [N] | _  => case xs⁰ of {C xs¹ xt⁰ => case ys⁰ of {C ys¹ yt⁰ => [C [P2 xs¹ ys¹] zip(xt⁰, yt⁰)] | _  => [N]} | _  => [N]}}}: 21
//│ [C 1 [N]]: 27 --->
//│ 	case xs⁰ of {C xs¹ xt⁰ => case ys⁰ of {C ys¹ yt⁰ => [C [P2 xs¹ ys¹] zip(xt⁰, yt⁰)] | _  => [N]} | _  => [N]}: 19
//│ 	case xs⁰ of {N  => [N] | _  => case ys⁰ of {N  => [N] | _  => case xs⁰ of {C xs¹ xt⁰ => case ys⁰ of {C ys¹ yt⁰ => [C [P2 xs¹ ys¹] zip(xt⁰, yt⁰)] | _  => [N]} | _  => [N]}}}: 21
//│ [N]: 30 --->
//│ 	case ys⁰ of {C ys¹ yt⁰ => [C [P2 xs¹ ys¹] zip(xt⁰, yt⁰)] | _  => [N]}: 17
//│ 	case ys⁰ of {N  => [N] | _  => case xs⁰ of {C xs¹ xt⁰ => case ys⁰ of {C ys¹ yt⁰ => [C [P2 xs¹ ys¹] zip(xt⁰, yt⁰)] | _  => [N]} | _  => [N]}}: 20
//│ [C 2 [N]]: 31 --->
//│ 	case ys⁰ of {C ys¹ yt⁰ => [C [P2 xs¹ ys¹] zip(xt⁰, yt⁰)] | _  => [N]}: 17
//│ 	case ys⁰ of {N  => [N] | _  => case xs⁰ of {C xs¹ xt⁰ => case ys⁰ of {C ys¹ yt⁰ => [C [P2 xs¹ ys¹] zip(xt⁰, yt⁰)] | _  => [N]} | _  => [N]}}: 20
//│ ------------------
//│ case ys⁰ of {C ys¹ yt⁰ => [C [P2 xs¹ ys¹] zip(xt⁰, yt⁰)] | _  => [N]}: 17 --->
//│ 	[N]: 30
//│ 	[C 2 [N]]: 31
//│ case xs⁰ of {C xs¹ xt⁰ => case ys⁰ of {C ys¹ yt⁰ => [C [P2 xs¹ ys¹] zip(xt⁰, yt⁰)] | _  => [N]} | _  => [N]}: 19 --->
//│ 	[N]: 26
//│ 	[C 1 [N]]: 27
//│ case ys⁰ of {N  => [N] | _  => case xs⁰ of {C xs¹ xt⁰ => case ys⁰ of {C ys¹ yt⁰ => [C [P2 xs¹ ys¹] zip(xt⁰, yt⁰)] | _  => [N]} | _  => [N]}}: 20 --->
//│ 	[N]: 30
//│ 	[C 2 [N]]: 31
//│ case xs⁰ of {N  => [N] | _  => case ys⁰ of {N  => [N] | _  => case xs⁰ of {C xs¹ xt⁰ => case ys⁰ of {C ys¹ yt⁰ => [C [P2 xs¹ ys¹] zip(xt⁰, yt⁰)] | _  => [N]} | _  => [N]}}}: 21 --->
//│ 	[N]: 26
//│ 	[C 1 [N]]: 27
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ 
//│ ------------------
//│ 
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ zip([C 1 [N]], [C 2 [N]])
//│ def zip(xs², ys²) = case xs² of {
//│ 	N  => [N]
//│ 	| _  => case ys² of {
//│ 		N  => [N]
//│ 		| _  => case xs² of {
//│ 			C xs¹ xt⁰ => case ys² of {
//│ 				C ys¹ yt⁰ => [C [P2 xs¹ ys¹] zip(xt⁰, yt⁰)]
//│ 				| _  => [N]}
//│ 			| _  => [N]}}}
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>> consumer ids >>>>>>>
//│ 
//│ <<<<<<< consumer ids <<<<<<<
//│ 
//│ >>>>>>> floating out info >>>>>>>
//│ 
//│ <<<<<<< floating out info <<<<<<<
//│ 
//│ >>>>>>> after inlining >>>>>>>
//│ zip([C 1 [N]], [C 2 [N]])
//│ def zip(xs⁰, ys⁰) = case xs⁰ of {
//│ 	N  => [N]
//│ 	| _  => case ys⁰ of {
//│ 		N  => [N]
//│ 		| _  => case xs⁰ of {
//│ 			C xs¹ xt⁰ => case ys⁰ of {
//│ 				C ys¹ yt⁰ => [C [P2 xs¹ ys¹] zip(xt⁰, yt⁰)]
//│ 				| _  => [N]}
//│ 			| _  => [N]}}}
//│ <<<<<<< after inlining <<<<<<<
//│ 
//│ >>>>>>> after floating out >>>>>>>
//│ zip([C 1 [N]], [C 2 [N]])
//│ def zip(xs⁰, ys⁰) = case xs⁰ of {
//│ 	N  => [N]
//│ 	| _  => case ys⁰ of {
//│ 		N  => [N]
//│ 		| _  => case xs⁰ of {
//│ 			C xs¹ xt⁰ => case ys⁰ of {
//│ 				C ys¹ yt⁰ => [C [P2 xs¹ ys¹] zip(xt⁰, yt⁰)]
//│ 				| _  => [N]}
//│ 			| _  => [N]}}}
//│ <<<<<<< after floating out <<<<<<<

// NOTE: type error: f x = x f cannot be well typed in haskell
fun f(x) =
  (
    if x is
      C(h, t) then ff => C(h, ff(t))
      N then ff => N
  )(f)
f(C(3, N))
//│ |#fun| |f|(|x|)| |#=|→|(|→|#if| |x| |is|→|C|(|h|,| |t|)| |#then| |ff| |=>| |C|(|h|,| |ff|(|t|)|)|↵|N| |#then| |ff| |=>| |N|←|←|↵|)|(|f|)|←|↵|f|(|C|(|3|,| |N|)|)|
//│ Parsed: {fun f = x, => {'(' if x is ‹(C (h, t,)) then ff, => C (h, ff (t,),); (N) then ff, => N›, ')' (f,)}; f (C (3, N,),)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ f^14([C 3 [N]])
//│ def f(x⁰) = case x⁰ of {
//│ 	C h⁰ t⁰ => (fun ff⁰ -> [C h⁰ ff⁰(t⁰)])
//│ 	| N  => (fun ff¹ -> [N])}(f^11)
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [N]: 16 --->
//│ 	case x⁰ of {C h⁰ t⁰ => (fun ff⁰ -> [C h⁰ ff⁰(t⁰)]) | N  => (fun ff¹ -> [N])}: 10
//│ [C 3 [N]]: 17 --->
//│ 	case x⁰ of {C h⁰ t⁰ => (fun ff⁰ -> [C h⁰ ff⁰(t⁰)]) | N  => (fun ff¹ -> [N])}: 10
//│ ------------------
//│ case x⁰ of {C h⁰ t⁰ => (fun ff⁰ -> [C h⁰ ff⁰(t⁰)]) | N  => (fun ff¹ -> [N])}: 10 --->
//│ 	DeadCodeProd
//│ 	[N]: 16
//│ 	[C 3 [N]]: 17
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ 
//│ ------------------
//│ 
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ f([C 3 [N]])
//│ def f(x¹) = case x¹ of {
//│ 	C h⁰ t⁰ => (fun ff² -> [C h⁰ ff²(t⁰)])
//│ 	| N  => (fun ff³ -> [N])}(f)
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>> consumer ids >>>>>>>
//│ 
//│ <<<<<<< consumer ids <<<<<<<
//│ 
//│ >>>>>>> floating out info >>>>>>>
//│ 
//│ <<<<<<< floating out info <<<<<<<
//│ 
//│ >>>>>>> after inlining >>>>>>>
//│ f([C 3 [N]])
//│ def f(x⁰) = case x⁰ of {
//│ 	C h⁰ t⁰ => (fun ff⁰ -> [C h⁰ ff⁰(t⁰)])
//│ 	| N  => (fun ff¹ -> [N])}(f)
//│ <<<<<<< after inlining <<<<<<<
//│ 
//│ >>>>>>> after floating out >>>>>>>
//│ f([C 3 [N]])
//│ def f(x⁰) = case x⁰ of {
//│ 	C h⁰ t⁰ => (fun ff⁰ -> [C h⁰ ff⁰(t⁰)])
//│ 	| N  => (fun ff¹ -> [N])}(f)
//│ <<<<<<< after floating out <<<<<<<

// a more minimal example requiring recursive type after fusion
fun f(x) =
  (
    if x is
      N then ff => 1
  )(f)
f(N)
//│ |#fun| |f|(|x|)| |#=|→|(|→|#if| |x| |is|→|N| |#then| |ff| |=>| |1|←|←|↵|)|(|f|)|←|↵|f|(|N|)|
//│ Parsed: {fun f = x, => {'(' if x is ‹(N) then ff, => 1›, ')' (f,)}; f (N,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ f^8([N])
//│ def f(x⁰) = case x⁰ of {
//│ 	N  => (fun ff⁰ -> 1)}(f^5)
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [N]: 9 --->
//│ 	case x⁰ of {N  => (fun ff⁰ -> 1)}: 4
//│ ------------------
//│ case x⁰ of {N  => (fun ff⁰ -> 1)}: 4 --->
//│ 	DeadCodeProd
//│ 	[N]: 9
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ 
//│ ------------------
//│ 
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ f([N])
//│ def f(x¹) = case x¹ of {
//│ 	N  => (fun ff¹ -> 1)}(f)
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>> consumer ids >>>>>>>
//│ 
//│ <<<<<<< consumer ids <<<<<<<
//│ 
//│ >>>>>>> floating out info >>>>>>>
//│ 
//│ <<<<<<< floating out info <<<<<<<
//│ 
//│ >>>>>>> after inlining >>>>>>>
//│ f([N])
//│ def f(x⁰) = case x⁰ of {
//│ 	N  => (fun ff⁰ -> 1)}(f)
//│ <<<<<<< after inlining <<<<<<<
//│ 
//│ >>>>>>> after floating out >>>>>>>
//│ f([N])
//│ def f(x⁰) = case x⁰ of {
//│ 	N  => (fun ff⁰ -> 1)}(f)
//│ <<<<<<< after floating out <<<<<<<


// FIXME: still have error even after eliminating dead branches and unused definitions, need more
// flow sensitive dead code elmination?
:lhInHaskell
:lhGenOCaml
:d
break p [] = ([], [])
break p (x:xs) = if p x then ([], (x:xs)) else case (break1 p xs) of { (ys, zs) -> ((x:ys), zs) }
break1 p [] = ([], [])
break1 p (x:xs) = if p x then ([], (x:xs)) else case (break1 p xs) of { (ys, zs) -> ((x:ys), zs) }
words s =  case (dropWhile (\x -> polyEq x ' ') s) of
          [] -> []
          s' -> case (break (\x -> polyEq x ' ') s') of (w, s'') -> (w : (words s''))
dropWhile f [] = []
dropWhile f (h:t) = if (f h) then dropWhile f t else (h:t)
words "1 2 4"
//│ ||
//│ Parsed: {}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ words_lh_₁^115([LH_C '1' [LH_C ' ' [LH_C '2' [LH_C ' ' [LH_C '4' [LH_N]]]]]])
//│ def break1_lh_₁(_lh_break1_arg1⁰, _lh_break1_arg2⁰) = case _lh_break1_arg2⁰ of {
//│ 	LH_N  => [LH_P2 [LH_N] [LH_N]]
//│ 	| LH_C _lh_break1_LH_C_0⁰ _lh_break1_LH_C_1⁰ => if _lh_break1_arg1⁰(_lh_break1_LH_C_0⁰) then [LH_P2 [LH_N] [LH_C _lh_break1_LH_C_0⁰ _lh_break1_LH_C_1⁰]] else 
//│ 		let _lh_matchIdent⁰ = break1_lh_₁^13(_lh_break1_arg1⁰, _lh_break1_LH_C_1⁰)
//│ 		in case _lh_matchIdent⁰ of {
//│ 			LH_P2 _lh_break1_LH_P2_0⁰ _lh_break1_LH_P2_1⁰ => [LH_P2 [LH_C _lh_break1_LH_C_0⁰ _lh_break1_LH_P2_0⁰] _lh_break1_LH_P2_1⁰]
//│ 			| _  => error⁰}
//│ 	| _  => error⁰}
//│ def break_lh_₁(_lh_break_arg1⁰, _lh_break_arg2⁰) = case _lh_break_arg2⁰ of {
//│ 	LH_N  => [LH_P2 [LH_N] [LH_N]]
//│ 	| LH_C _lh_break_LH_C_0⁰ _lh_break_LH_C_1⁰ => if _lh_break_arg1⁰(_lh_break_LH_C_0⁰) then [LH_P2 [LH_N] [LH_C _lh_break_LH_C_0⁰ _lh_break_LH_C_1⁰]] else 
//│ 		let _lh_matchIdent¹ = break1_lh_₁^62(_lh_break_arg1⁰, _lh_break_LH_C_1⁰)
//│ 		in case _lh_matchIdent¹ of {
//│ 			LH_P2 _lh_break_LH_P2_0⁰ _lh_break_LH_P2_1⁰ => [LH_P2 [LH_C _lh_break_LH_C_0⁰ _lh_break_LH_P2_0⁰] _lh_break_LH_P2_1⁰]
//│ 			| _  => error⁰}
//│ 	| _  => error⁰}
//│ def dropWhile_lh_₁(_lh_dropWhile_arg1⁰, _lh_dropWhile_arg2⁰) = case _lh_dropWhile_arg2⁰ of {
//│ 	LH_N  => [LH_N]
//│ 	| LH_C _lh_dropWhile_LH_C_0⁰ _lh_dropWhile_LH_C_1⁰ => if _lh_dropWhile_arg1⁰(_lh_dropWhile_LH_C_0⁰) then dropWhile_lh_₁^37(_lh_dropWhile_arg1⁰, _lh_dropWhile_LH_C_1⁰) else [LH_C _lh_dropWhile_LH_C_0⁰ _lh_dropWhile_LH_C_1⁰]
//│ 	| _  => error⁰}
//│ def words_lh_₁(_lh_words_arg1⁰) = 
//│ 	let _lh_matchIdent² = dropWhile_lh_₁^81((fun x⁰ -> polyEq⁰(x⁰, ' ')), _lh_words_arg1⁰)
//│ 	in case _lh_matchIdent² of {
//│ 		LH_N  => [LH_N]
//│ 		| _  => 
//│ 			let _lh_matchIdent³ = break_lh_₁^93((fun x¹ -> polyEq⁰(x¹, ' ')), _lh_matchIdent²)
//│ 			in case _lh_matchIdent³ of {
//│ 				LH_P2 _lh_words_LH_P2_0⁰ _lh_words_LH_P2_1⁰ => [LH_C _lh_words_LH_P2_0⁰ words_lh_₁^105(_lh_words_LH_P2_1⁰)]
//│ 				| _  => error⁰}}
//│ 		---------- unoptimized ocaml gen ----------
//│ 		let rec dropWhile_lh__d1 _lh_dropWhile_arg1_0 _lh_dropWhile_arg2_0 =
//│ 		  (match _lh_dropWhile_arg2_0 with
//│ 		    | `LH_N -> 
//│ 		      (`LH_N)
//│ 		    | `LH_C(_lh_dropWhile_LH_C_0_0, _lh_dropWhile_LH_C_1_0) -> 
//│ 		      (if (_lh_dropWhile_arg1_0 _lh_dropWhile_LH_C_0_0) then
//│ 		        ((dropWhile_lh__d1 _lh_dropWhile_arg1_0) _lh_dropWhile_LH_C_1_0)
//│ 		      else
//│ 		        (`LH_C(_lh_dropWhile_LH_C_0_0, _lh_dropWhile_LH_C_1_0)))
//│ 		    | _ -> 
//│ 		      (failwith "error"));;
//│ 		let rec break1_lh__d1 _lh_break1_arg1_0 _lh_break1_arg2_0 =
//│ 		  (match _lh_break1_arg2_0 with
//│ 		    | `LH_N -> 
//│ 		      (`LH_P2((`LH_N), (`LH_N)))
//│ 		    | `LH_C(_lh_break1_LH_C_0_0, _lh_break1_LH_C_1_0) -> 
//│ 		      (if (_lh_break1_arg1_0 _lh_break1_LH_C_0_0) then
//│ 		        (`LH_P2((`LH_N), (`LH_C(_lh_break1_LH_C_0_0, _lh_break1_LH_C_1_0))))
//│ 		      else
//│ 		        (let rec _lh_matchIdent_0 = ((break1_lh__d1 _lh_break1_arg1_0) _lh_break1_LH_C_1_0) in
//│ 		          (match _lh_matchIdent_0 with
//│ 		            | `LH_P2(_lh_break1_LH_P2_0_0, _lh_break1_LH_P2_1_0) -> 
//│ 		              (`LH_P2((`LH_C(_lh_break1_LH_C_0_0, _lh_break1_LH_P2_0_0)), _lh_break1_LH_P2_1_0))
//│ 		            | _ -> 
//│ 		              (failwith "error"))))
//│ 		    | _ -> 
//│ 		      (failwith "error"));;
//│ 		let rec break_lh__d1 _lh_break_arg1_0 _lh_break_arg2_0 =
//│ 		  (match _lh_break_arg2_0 with
//│ 		    | `LH_N -> 
//│ 		      (`LH_P2((`LH_N), (`LH_N)))
//│ 		    | `LH_C(_lh_break_LH_C_0_0, _lh_break_LH_C_1_0) -> 
//│ 		      (if (_lh_break_arg1_0 _lh_break_LH_C_0_0) then
//│ 		        (`LH_P2((`LH_N), (`LH_C(_lh_break_LH_C_0_0, _lh_break_LH_C_1_0))))
//│ 		      else
//│ 		        (let rec _lh_matchIdent_1 = ((break1_lh__d1 _lh_break_arg1_0) _lh_break_LH_C_1_0) in
//│ 		          (match _lh_matchIdent_1 with
//│ 		            | `LH_P2(_lh_break_LH_P2_0_0, _lh_break_LH_P2_1_0) -> 
//│ 		              (`LH_P2((`LH_C(_lh_break_LH_C_0_0, _lh_break_LH_P2_0_0)), _lh_break_LH_P2_1_0))
//│ 		            | _ -> 
//│ 		              (failwith "error"))))
//│ 		    | _ -> 
//│ 		      (failwith "error"));;
//│ 		let rec words_lh__d1 _lh_words_arg1_0 =
//│ 		  (let rec _lh_matchIdent_2 = ((dropWhile_lh__d1 (fun x_0 -> 
//│ 		    (x_0 = ' '))) _lh_words_arg1_0) in
//│ 		    (match _lh_matchIdent_2 with
//│ 		      | `LH_N -> 
//│ 		        (`LH_N)
//│ 		      | _ -> 
//│ 		        (let rec _lh_matchIdent_3 = ((break_lh__d1 (fun x_1 -> 
//│ 		          (x_1 = ' '))) _lh_matchIdent_2) in
//│ 		          (match _lh_matchIdent_3 with
//│ 		            | `LH_P2(_lh_words_LH_P2_0_0, _lh_words_LH_P2_1_0) -> 
//│ 		              (`LH_C(_lh_words_LH_P2_0_0, (words_lh__d1 _lh_words_LH_P2_1_0)))
//│ 		            | _ -> 
//│ 		              (failwith "error")))));;
//│ 		(words_lh__d1 (`LH_C('1', (`LH_C(' ', (`LH_C('2', (`LH_C(' ', (`LH_C('4', (`LH_N))))))))))))
//│ 		....... ocaml repl result .......
//│ /!!!\ Uncaught error: java.io.IOException: Cannot run program "/Users/crescentonc/.opam/benchmarkflambda/bin/ocaml": error=2, No such file or directory


// FIXME: the type error can be eliminated by expanding again to
// eliminate dead codes (totally unreachable definitions) that appear
// after removing dead branches
:lhGenOCaml
:d
fun break(p, ls) = if ls is
  N then P(N, N)
  C(x, xs) then if p(x) then P(N, C(x, xs)) else if break1(p, xs) is
    P(ys, zs) then P(C(x, ys), zs)
fun break1(p, ls) = if ls is
  N then P(N, N)
  C(x, xs) then if p(x) then P(N, C(x, xs)) else if break1(p, xs) is
    P(ys, zs) then P(C(x, ys), zs)
fun words(s) = if dropWhile(x => x == 1, s) is
  N then N
  s' then if break(x => x == 1, s') is
    P(w, s'') then C(w, words(s''))
fun dropWhile(f, ls) = if ls is
  N then N
  C(h, t) then if f(h) then dropWhile(f, t) else C(h, t)
words(C(2, C(1, C(2, C(1, C(2, N))))))
//│ |#fun| |break|(|p|,| |ls|)| |#=| |#if| |ls| |is|→|N| |#then| |P|(|N|,| |N|)|↵|C|(|x|,| |xs|)| |#then| |#if| |p|(|x|)| |#then| |P|(|N|,| |C|(|x|,| |xs|)|)| |#else| |#if| |break1|(|p|,| |xs|)| |is|→|P|(|ys|,| |zs|)| |#then| |P|(|C|(|x|,| |ys|)|,| |zs|)|←|←|↵|#fun| |break1|(|p|,| |ls|)| |#=| |#if| |ls| |is|→|N| |#then| |P|(|N|,| |N|)|↵|C|(|x|,| |xs|)| |#then| |#if| |p|(|x|)| |#then| |P|(|N|,| |C|(|x|,| |xs|)|)| |#else| |#if| |break1|(|p|,| |xs|)| |is|→|P|(|ys|,| |zs|)| |#then| |P|(|C|(|x|,| |ys|)|,| |zs|)|←|←|↵|#fun| |words|(|s|)| |#=| |#if| |dropWhile|(|x| |=>| |x| |==| |1|,| |s|)| |is|→|N| |#then| |N|↵|s'| |#then| |#if| |break|(|x| |=>| |x| |==| |1|,| |s'|)| |is|→|P|(|w|,| |s''|)| |#then| |C|(|w|,| |words|(|s''|)|)|←|←|↵|#fun| |dropWhile|(|f|,| |ls|)| |#=| |#if| |ls| |is|→|N| |#then| |N|↵|C|(|h|,| |t|)| |#then| |#if| |f|(|h|)| |#then| |dropWhile|(|f|,| |t|)| |#else| |C|(|h|,| |t|)|←|↵|words|(|C|(|2|,| |C|(|1|,| |C|(|2|,| |C|(|1|,| |C|(|2|,| |N|)|)|)|)|)|)|
//│ Parsed: {fun break = p, ls, => if ls is ‹(N) then P (N, N,); (C (x, xs,)) then if (p (x,)) then P (N, C (x, xs,),) else if break1 (p, xs,) is ‹(P (ys, zs,)) then P (C (x, ys,), zs,)››; fun break1 = p, ls, => if ls is ‹(N) then P (N, N,); (C (x, xs,)) then if (p (x,)) then P (N, C (x, xs,),) else if break1 (p, xs,) is ‹(P (ys, zs,)) then P (C (x, ys,), zs,)››; fun words = s, => if dropWhile (x, => == (x,) (1,), s,) is ‹(N) then N; (s') then if break (x, => == (x,) (1,), s',) is ‹(P (w, s'',)) then C (w, words (s'',),)››; fun dropWhile = f, ls, => if ls is ‹(N) then N; (C (h, t,)) then if (f (h,)) then dropWhile (f, t,) else C (h, t,)›; words (C (2, C (1, C (2, C (1, C (2, N,),),),),),)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ words^101([C 2 [C 1 [C 2 [C 1 [C 2 [N]]]]]])
//│ def break(p⁰, ls⁰) = case ls⁰ of {
//│ 	N  => [P [N] [N]]
//│ 	| C x⁰ xs⁰ => if p⁰(x⁰) then [P [N] [C x⁰ xs⁰]] else case break1^13(p⁰, xs⁰) of {
//│ 		P ys⁰ zs⁰ => [P [C x⁰ ys⁰] zs⁰]}}
//│ def break1(p¹, ls¹) = case ls¹ of {
//│ 	N  => [P [N] [N]]
//│ 	| C x¹ xs¹ => if p¹(x¹) then [P [N] [C x¹ xs¹]] else case break1^40(p¹, xs¹) of {
//│ 		P ys¹ zs¹ => [P [C x¹ ys¹] zs¹]}}
//│ def dropWhile(f⁰, ls²) = case ls² of {
//│ 	N  => [N]
//│ 	| C h⁰ t⁰ => if f⁰(h⁰) then dropWhile^89(f⁰, t⁰) else [C h⁰ t⁰]}
//│ def words(s⁰) = case dropWhile^55((fun x² -> (x² == 1)), s⁰) of {
//│ 	N  => [N]
//│ 	| s'⁰ => case break^66((fun x³ -> (x³ == 1)), s'⁰) of {
//│ 		P w⁰ s''⁰ => [C w⁰ words^77(s''⁰)]}}
//│ 		---------- unoptimized ocaml gen ----------
//│ 		let rec dropWhile f_0 ls_2 =
//│ 		  (match ls_2 with
//│ 		    | `N -> 
//│ 		      (`N)
//│ 		    | `C(h_0, t_0) -> 
//│ 		      (if (f_0 h_0) then
//│ 		        ((dropWhile f_0) t_0)
//│ 		      else
//│ 		        (`C(h_0, t_0))));;
//│ 		let rec break1 p_1 ls_1 =
//│ 		  (match ls_1 with
//│ 		    | `N -> 
//│ 		      (`P((`N), (`N)))
//│ 		    | `C(x_1, xs_1) -> 
//│ 		      (if (p_1 x_1) then
//│ 		        (`P((`N), (`C(x_1, xs_1))))
//│ 		      else
//│ 		        (match ((break1 p_1) xs_1) with
//│ 		          | `P(ys_1, zs_1) -> 
//│ 		            (`P((`C(x_1, ys_1)), zs_1)))));;
//│ 		let rec break p_0 ls_0 =
//│ 		  (match ls_0 with
//│ 		    | `N -> 
//│ 		      (`P((`N), (`N)))
//│ 		    | `C(x_0, xs_0) -> 
//│ 		      (if (p_0 x_0) then
//│ 		        (`P((`N), (`C(x_0, xs_0))))
//│ 		      else
//│ 		        (match ((break1 p_0) xs_0) with
//│ 		          | `P(ys_0, zs_0) -> 
//│ 		            (`P((`C(x_0, ys_0)), zs_0)))));;
//│ 		let rec words s_0 =
//│ 		  (match ((dropWhile (fun x_2 -> 
//│ 		    (x_2 = 1))) s_0) with
//│ 		    | `N -> 
//│ 		      (`N)
//│ 		    | s'_0 -> 
//│ 		      (match ((break (fun x_3 -> 
//│ 		        (x_3 = 1))) s'_0) with
//│ 		        | `P(w_0, s''_0) -> 
//│ 		          (`C(w_0, (words s''_0)))));;
//│ 		(words (`C(2, (`C(1, (`C(2, (`C(1, (`C(2, (`N))))))))))))
//│ 		....... ocaml repl result .......
//│ /!!!\ Uncaught error: java.io.IOException: Cannot run program "/Users/crescentonc/.opam/benchmarkflambda/bin/ocaml": error=2, No such file or directory

