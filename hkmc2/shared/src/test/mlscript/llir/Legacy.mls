:js
:llir
:cpp

:global

:intl
class Pair[A, B](x: A, y: B)
fun mktup2(x, y) = mktup(x, y)
fun mktup(x, y) = Pair(x, y)
fun foo() =
  mktup2(1, 2)
foo()
//│ = Pair(1, 2)
//│ 
//│ Interpreted:
//│ Pair(1,2)

:intl
class Pair[A, B](x: A, y: B)
fun foo(pair) =
  if pair is
    Pair(x, y) then Pair(x, y)
fun bar() =
  foo(Pair(1, 2))
bar()
//│ = Pair(1, 2)
//│ 
//│ Interpreted:
//│ Pair(1,2)

:intl
class Pair[A, B](x: A, y: B)
fun foo(pair) =
  if pair is
    Pair(x, y) then Pair(x, y)
fun bar() =
  foo(Pair(1, 2))
bar()
//│ = Pair(1, 2)
//│ 
//│ Interpreted:
//│ Pair(1,2)

:intl
class Pair[A, B](x: A, y: B)
fun silly(pair) =
  let x = 0
  let n = if pair is
    Pair(x1, x2) then
      if pair is
        Pair (x3, x4) then x3 + 1
  n + 1
fun foo() =
    let a = Pair(0, 1)
    let b = silly(a)
    b
foo()
//│ = 2
//│ 
//│ Interpreted:
//│ 2


:intl
class Pair[A, B](x: A, y: B)
fun inc_fst(pair) =
  let c = 2
  if pair is
    Pair(x1, x2) then x1 + c
fun foo() =
    let a = Pair(0, 1)
    let b = inc_fst(a)
    b
foo()
//│ = 2
//│ 
//│ Interpreted:
//│ 2

:intl
class Pair[A, B](x: A, y: B)
fun inc_fst(pair) =
  let x = 0
  if pair is
    Pair(x1, x2) then x2 + 1
fun foo() =
    let b = inc_fst(Pair(0, 1))
    b
foo()
//│ = 2
//│ 
//│ Interpreted:
//│ 2

:intl
abstract class Either[out A, out B]: Left[A, B] | Right[A, B]
class Left[out A, out B](x: A) extends Either[A, B]
class Right[out A, out B](y: B) extends Either[A, B]
fun foo(a, b) =
  let t = if a is
    Left(x) then Left(x + 1)
    Right(y) then Right(b)
  if t is
    Left(x) then x
    Right(y) then y
fun bar() =
  foo(Right(2), 2)
bar()
//│ = 2
//│ 
//│ Interpreted:
//│ 2

:intl
abstract class Nat: S[Nat] | O
class S(s: Nat) extends Nat
object O extends Nat
fun foo() =
  bar(S(O))
fun bar(x) =
  baz(x)
fun baz(x) =
  if x is
    S(s) then s
    O then x
foo()
//│ = O
//│ 
//│ Interpreted:
//│ O()

:intl
class A(x, y, z)
class B(m, n)
fun complex_foo(t) =
  let r = if t is
    A(x, y, z) then x + y * z
    B(m, n) then m - n
  let s = B(1, 2)
  let u = if s is
    A(x, y, z) then 3
    B(m, n) then 4
  r + u
fun bar() =
  complex_foo(A(6, 7, 8))
  complex_foo(B(9, 10))
bar()
//│ = 3
//│ 
//│ Interpreted:
//│ 3

:intl
class A(w, x)
class B(y)
class C(z)
fun complex_foo(t) =
  let a = 1 + 2
  let b = 1 * 2
  let x = if t is
    A(x, y) then y
    B(x) then B(x + b)
    C(x) then C(0)
  let z = A(5, x)
  let v = B(6)
  let y = if x is
    A(x, y) then
      let m = x + a + b
      if y is
        A(x, y) then x
        B(x) then m
        C(x) then 0
    B(x) then 2
    C(x) then 3
  if z is
    A(x, y) then x
    B(x) then 4
    C(x) then
      if v is
        A(x, y) then x
        B(x) then 7
        C(x) then 8
fun bar() =
  complex_foo(A(10, A(9, B(10))))
bar()
//│ = 5
//│ 
//│ Interpreted:
//│ 5

:intl
fun fib(n) = if n < 2 then n else fib(n-1) + fib(n-2)
fib(20)
//│ = 6765
//│ 
//│ Interpreted:
//│ 6765

:intl
fun odd(x) = if x == 0 then false else even(x-1)
fun even(x) = if x == 0 then true else odd(x-1)
fun foo() = odd(10)
foo()
//│ = false
//│ 
//│ Interpreted:
//│ false

:intl
abstract class Option[out T]: Some[T] | None
class Some[out T](x: T) extends Option[T]
object None extends Option
fun not(x) =
  if x then false else true
fun foo(x) =
  if x then None
       else Some(foo(not(x)))
fun main() = foo(false)
main()
//│ = Some(None)
//│ 
//│ Interpreted:
//│ Some(None())

:sllir
:intl
abstract class Option[out T]: Some[T] | None
class Some[out T](x: T) extends Option[T]
object None extends Option
fun fromSome(s) = if s is Some(x) then x
abstract class Nat: S[Nat] | O
class S(s: Nat) extends Nat
object O extends Nat
fun aaa() =
  let m = 1
  let n = 2
  let p = 3
  let q = 4
  m + n - p + q
fun bbb() =
  let x = aaa()
  x * 100 + 4
fun not(x) =
  if x then false else true
fun foo(x) =
  if x then None
       else Some(foo(not(x)))
fun main() =
  let x = foo(false)
  if x is
    None then aaa()
    Some(b1) then bbb()
main()
//│ = 404
//│ LLIR:
//│   class Option()
//│   class Some(x$1742) extends Option
//│   class None() extends Option
//│   class Nat()
//│   class S(s$1753) extends Nat
//│   class O() extends Nat
//│   def fromSome$1725(s$1745) =
//│     case s$1745 of
//│       Some$1739 =>
//│         let x$1872 = s$1745.<Some$1739:x> in
//│         x$1872
//│       _ =>
//│         panic "match error"
//│   def j$1871() =
//│     null
//│   def aaa$1730() =
//│     let x$1873 = 1 in
//│     let x$1874 = 2 in
//│     let x$1875 = 3 in
//│     let x$1876 = 4 in
//│     let x$1877 = +(x$1873,x$1874) in
//│     let x$1878 = -(x$1877,x$1875) in
//│     let x$1879 = +(x$1878,x$1876) in
//│     x$1879
//│   def bbb$1732() =
//│     let* (x$1880) = aaa() in
//│     let x$1881 = *(x$1880,100) in
//│     let x$1882 = +(x$1881,4) in
//│     x$1882
//│   def not$1728(x$1769) =
//│     case x$1769 of
//│       BoolLit(true) =>
//│         false
//│       _ =>
//│         true
//│   def j$1883() =
//│     null
//│   def foo$1735(x$1771) =
//│     case x$1771 of
//│       BoolLit(true) =>
//│         let x$1885 = None$1743() in
//│         x$1885
//│       _ =>
//│         let* (x$1886) = not(x$1771) in
//│         let* (x$1887) = foo(x$1886) in
//│         let x$1888 = Some$1739(x$1887) in
//│         x$1888
//│   def j$1884() =
//│     null
//│   def main$1726() =
//│     let* (x$1889) = foo(false) in
//│     case x$1889 of
//│       None$1743 =>
//│         let* (x$1891) = aaa() in
//│         x$1891
//│       _ =>
//│         case x$1889 of
//│           Some$1739 =>
//│             let x$1893 = x$1889.<Some$1739:x> in
//│             let* (x$1894) = bbb() in
//│             x$1894
//│           _ =>
//│             panic "match error"
//│   def j$1892() =
//│     jump j$1890()
//│   def j$1890() =
//│     null
//│   let* (x$1895) = main() in
//│   x$1895
//│ 
//│ Interpreted:
//│ 404

:intl
abstract class Nat: S[Nat] | O
class S(s: Nat) extends Nat
object O extends Nat
fun odd(x) =
  if x is
    O then false
    S(s) then even(s)
fun even(x) =
  if x is
    O then true
    S(s) then odd(s)
fun foo() = odd(S(S(S(O))))
foo()
//│ = true
//│ 
//│ Interpreted:
//│ true

:intl
abstract class Nat: S[Nat] | O
class S(s: Nat) extends Nat
object O extends Nat
fun odd(x) =
  if x is
    O then false
    S(s) then even(s)
fun even(x) =
  if x is
    O then true
    S(s) then odd(s)
fun mk(n) = if n > 0 then S(mk(n - 1)) else O
fun foo() = odd(mk(10))
foo() 
//│ = false
//│ 
//│ Interpreted:
//│ false

:intl
abstract class Nat: S[Nat] | O
class S(s: Nat) extends Nat
object O extends Nat
fun odd(x) =
  if x is
    O then false
    S(s) then even(s)
fun even(x) =
  if x is
    O then true
    S(s) then odd(s)
fun mk(n) = if n > 0 then S(mk(n - 1)) else O
fun foo() = odd(S(S(mk(10))))
foo()
//│ = false
//│ 
//│ Interpreted:
//│ false

:intl
abstract class Nat: S[Nat] | O
class S(s: Nat) extends Nat
object O extends Nat
fun odd(x) =
  if x is
    O then false
    S(s) then even(s)
fun even(x) =
  if x is
    O then true
    S(s) then odd(s)
fun foo() = odd(if 10 > 0 then S(O) else O)
fun bar() = if 10 > 0 then odd(S(O)) else odd(O)
fun main() =
  foo()
  bar()
main()
//│ = true
//│ 
//│ Interpreted:
//│ true

:intl
abstract class Option[out T]: Some[T] | None
class Some[out T](x: T) extends Option[T]
object None extends Option
abstract class List[out T]: Cons[T] | Nil
class (::) Cons[out T](head: T, tail: List[T]) extends List[T]
object Nil extends List
fun head_opt(l) =
  if l is
    Nil then None
    Cons(h, t) then Some(h)
fun is_none(o) =
  if o is
    None then true
    Some(x) then false
fun is_empty(l) =
  is_none(head_opt(l))
fun main() =
  is_empty(Cons(1, Cons(2, Nil)))
main()
//│ = false
//│ 
//│ Interpreted:
//│ false

:intl
abstract class Option[out T]: Some[T] | None
class Some[out T](x: T) extends Option[T]
object None extends Option
abstract class List[out T]: Cons[T] | Nil
class (::) Cons[out T](head: T, tail: List[T]) extends List[T]
object Nil extends List
fun mk_list(n) =
  if n == 0 then Nil else Cons(n, mk_list(n - 1))
fun head_opt(l) =
  if l is
    Nil then None
    Cons(h, t) then Some(h)
fun is_none(o) =
  if o is
    None then true
    Some(x) then false
fun is_empty(l) =
  is_none(head_opt(l))
fun main() =
  is_empty(mk_list(10))
main()
//│ = false
//│ 
//│ Interpreted:
//│ false


:intl
abstract class Option[out T]: Some[T] | None
class Some[out T](x: T) extends Option[T]
object None extends Option
abstract class List[out T]: Cons[T] | Nil
class (::) Cons[out T](head: T, tail: List[T]) extends List[T]
object Nil extends List
fun mk_list(n) =
  if n == 0 then Nil else Cons(n, mk_list(n - 1))
fun last_opt(l) =
  if l is
    Nil then None
    Cons(h, t) then
      if t is
        Nil then Some(h)
        Cons(h2, t2) then last_opt(t)
fun main() =
  last_opt(mk_list(10))
main()
//│ = Some(1)
//│ 
//│ Interpreted:
//│ Some(1)

:intl
abstract class Option[out T]: Some[T] | None
class Some[out T](x: T) extends Option[T]
object None extends Option
fun is_some(o) =
  if o is
    Some(x) then true
    None then false
fun e0(w) =
  w + 8 + 9 + 10
fun e1(a, c) =
  a + 1 + 2 + 3 + 4
fun e3(c) =
  let m = 4
  let n = 5
  let p = 6
  let q = 7
  if c then m + n + p + q else m + n - p + q
fun e2(x) =
  x + 12 + 13 + 14
fun f(x) =
  let c1 = is_some(x)
  let z = e3(c1)
  let w = if x is
    Some(a) then e1(a, z)
    None then e2(z)
  e0(w)
fun main() =
  f(Some(2)) + f(None)
main()
//│ = 115
//│ 
//│ Interpreted:
//│ 115

:intl
abstract class Nat: S[Nat] | O
class S(s: Nat) extends Nat
object O extends Nat
fun pred(n) =
  if n is
    S(p) then p
    O then O
fun plus(n1, n2) =
  if n1 is
    O then n2
    S(p) then S(plus(p, n2))
fun fib(n) =
  if n is
    O then S(O)
    S(p) then
      if p is
        O then S(O)
        S(q) then plus(fib(p), fib(q))
fun to_int(n) =
  if n is
    O then 0
    S(p) then 1 + to_int(p)
fun to_nat(n) =
  if n == 0 then O
  else S(to_nat(n - 1))
fun main() =
  to_int(fib(to_nat(14)))
main()
//│ = 610
//│ 
//│ Interpreted:
//│ 610
