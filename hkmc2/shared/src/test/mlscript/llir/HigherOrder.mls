:js
:llir

:global

:sllir
:intl
fun add(x) = y => x + y
add(1)(2)
//│ = 3
//│ LLIR:
//│   class Lambda$0(x) extends Callable {
//│     def apply1(y) =
//│       let x$0 = +(x,y) in
//│       x$0
//│   }
//│   def add(x) =
//│     let x$1 = Lambda$0(x) in
//│     x$1
//│   let* (x$2) = add(1) in
//│   let x$3 = Callable.apply1(x$2,2) in
//│   x$3
//│ 
//│ Interpreted:
//│ 3

:sllir
:intl
fun add4(a, b) = (c, d) => a + b + c + d
add4(1, 2)(3, 4)
//│ = 10
//│ LLIR:
//│   class Lambda$0(a,b) extends Callable {
//│     def apply2(c,d) =
//│       let x$0 = +(a,b) in
//│       let x$1 = +(x$0,c) in
//│       let x$2 = +(x$1,d) in
//│       x$2
//│   }
//│   def add4(a,b) =
//│     let x$3 = Lambda$0(a,b) in
//│     x$3
//│   let* (x$4) = add4(1,2) in
//│   let x$5 = Callable.apply2(x$4,3,4) in
//│   x$5
//│ 
//│ Interpreted:
//│ 10


:sllir
:intl
abstract class List[out T]: Cons[T] | Nil
class (::) Cons[out T](head: T, tail: List[T]) extends List[T]
object Nil extends List
fun map(f, l) =
  if l is
    Cons(h, t) then Cons(f(h), map(f, t))
    Nil then Nil
fun inc(x) = x + 1
fun main() =
  map(x => inc(x), 1 :: 2 :: 3 :: Nil)
  map(inc, 1 :: 2 :: 3 :: Nil)
main()
//│ = Cons(2, Cons(3, Cons(4, Nil)))
//│ LLIR:
//│   class List()
//│   class Cons(head,tail) extends List
//│   class Nil() extends List
//│   class Lambda$0() extends Callable {
//│     def apply1(x1) =
//│       let* (x$11) = inc(x1) in
//│       x$11
//│   }
//│   class Lambda$1() extends Callable {
//│     def apply1(lam_arg) =
//│       let* (x$18) = inc(lam_arg) in
//│       x$18
//│   }
//│   def map(f,l) =
//│     case l of
//│       Cons =>
//│         let x$0 = l.<Cons:head> in
//│         let x$1 = l.<Cons:tail> in
//│         let x$2 = Callable.apply1(f,x$0) in
//│         let* (x$3) = map(f,x$1) in
//│         let x$4 = Cons(x$2,x$3) in
//│         x$4
//│       _ =>
//│         case l of
//│           Nil =>
//│             let x$5 = Nil() in
//│             x$5
//│           _ =>
//│             panic "match error"
//│   def j$1() =
//│     jump j$0()
//│   def j$0() =
//│     null
//│   def inc(x) =
//│     let x$6 = +(x,1) in
//│     x$6
//│   def main() =
//│     let x$7 = Nil() in
//│     let x$8 = Cons(3,x$7) in
//│     let x$9 = Cons(2,x$8) in
//│     let x$10 = Cons(1,x$9) in
//│     let x$12 = Lambda$0() in
//│     let* (x$13) = map(x$12,x$10) in
//│     let x$14 = Nil() in
//│     let x$15 = Cons(3,x$14) in
//│     let x$16 = Cons(2,x$15) in
//│     let x$17 = Cons(1,x$16) in
//│     let x$19 = Lambda$1() in
//│     let* (x$20) = map(x$19,x$17) in
//│     x$20
//│   let* (x$21) = main() in
//│   x$21
//│ 
//│ Interpreted:
//│ Cons(2,Cons(3,Cons(4,Nil())))

