:js
:llir
:cpp

:global

:sllir
:intl
:scpp
fun add(x) = y => x + y
add(1)(2)
//│ = 3
//│ LLIR:
//│   class Lambda(x$199) extends Callable {
//│     def apply1$216(y$200) =
//│       let x$217 = +(x$199,y$200) in
//│       x$217
//│   }
//│   def add$198(x$199) =
//│     let x$218 = Lambda$214(x$199) in
//│     x$218
//│   let* (x$219) = add(1) in
//│   let x$220 = Callable.apply1$216(x$219,2) in
//│   x$220
//│ 
//│ Cpp:
//│ #include "mlsprelude.h"
//│ struct Lambda;
//│ _mlsValue add(_mlsValue);
//│ _mlsValue _mlsMain();
//│ struct Lambda: public Callable {
//│   _mlsValue x;
//│   constexpr static inline const char *typeName = "Lambda";
//│   constexpr static inline uint32_t typeTag = nextTypeTag();
//│   virtual void print() const override { std::printf("%s", typeName); std::printf("("); this->x.print();  std::printf(")"); }
//│   virtual void destroy() override { _mlsValue::destroy(this->x);  operator delete (this, std::align_val_t(_mlsAlignment)); }
//│   static _mlsValue create(_mlsValue x) { auto _mlsVal = new (std::align_val_t(_mlsAlignment)) Lambda; _mlsVal->refCount = 1; _mlsVal->tag = typeTag; _mlsVal->x = x;  return _mlsValue(_mlsVal); }
//│   virtual _mlsValue apply1(_mlsValue y) {
//│     _mlsValue _mls_retval;
//│     auto x1 = (x + y);
//│     _mls_retval = x1;
//│     return _mls_retval;
//│   }
//│ };
//│ _mlsValue add(_mlsValue x) {
//│   _mlsValue _mls_retval;
//│   auto x2 = _mlsValue::create<Lambda>(x);
//│   _mls_retval = x2;
//│   return _mls_retval;
//│ }
//│ _mlsValue _mlsMain() {
//│   _mlsValue _mls_retval;
//│   auto x3 = add(_mlsValue::fromIntLit(1));
//│   auto x4 = _mlsMethodCall<Callable>(x3)->apply1(_mlsValue::fromIntLit(2));
//│   _mls_retval = x4;
//│   return _mls_retval;
//│ }
//│ int main() { return _mlsLargeStack(_mlsMainWrapper); }
//│ 
//│ Interpreted:
//│ 3

:sllir
:intl
:scpp
fun add4(a, b) = (c, d) => a + b + c + d
add4(1, 2)(3, 4)
//│ = 10
//│ LLIR:
//│   class Lambda(b$223,a$222) extends Callable {
//│     def apply2$247(c$224,d$225) =
//│       let x$248 = +(a$222,b$223) in
//│       let x$249 = +(x$248,c$224) in
//│       let x$250 = +(x$249,d$225) in
//│       x$250
//│   }
//│   def add4$221(a$222,b$223) =
//│     let x$251 = Lambda$245(b$223,a$222) in
//│     x$251
//│   let* (x$252) = add4(1,2) in
//│   let x$253 = Callable.apply2$247(x$252,3,4) in
//│   x$253
//│ 
//│ Cpp:
//│ #include "mlsprelude.h"
//│ struct Lambda;
//│ _mlsValue add4(_mlsValue, _mlsValue);
//│ _mlsValue _mlsMain();
//│ struct Lambda: public Callable {
//│   _mlsValue b;
//│   _mlsValue a;
//│   constexpr static inline const char *typeName = "Lambda";
//│   constexpr static inline uint32_t typeTag = nextTypeTag();
//│   virtual void print() const override { std::printf("%s", typeName); std::printf("("); this->b.print(); std::printf(", "); this->a.print();  std::printf(")"); }
//│   virtual void destroy() override { _mlsValue::destroy(this->b); _mlsValue::destroy(this->a);  operator delete (this, std::align_val_t(_mlsAlignment)); }
//│   static _mlsValue create(_mlsValue b, _mlsValue a) { auto _mlsVal = new (std::align_val_t(_mlsAlignment)) Lambda; _mlsVal->refCount = 1; _mlsVal->tag = typeTag; _mlsVal->b = b; _mlsVal->a = a;  return _mlsValue(_mlsVal); }
//│   virtual _mlsValue apply2(_mlsValue c, _mlsValue d) {
//│     _mlsValue _mls_retval;
//│     auto x = (a + b);
//│     auto x1 = (x + c);
//│     auto x2 = (x1 + d);
//│     _mls_retval = x2;
//│     return _mls_retval;
//│   }
//│ };
//│ _mlsValue add4(_mlsValue a, _mlsValue b) {
//│   _mlsValue _mls_retval;
//│   auto x3 = _mlsValue::create<Lambda>(b, a);
//│   _mls_retval = x3;
//│   return _mls_retval;
//│ }
//│ _mlsValue _mlsMain() {
//│   _mlsValue _mls_retval;
//│   auto x4 = add4(_mlsValue::fromIntLit(1), _mlsValue::fromIntLit(2));
//│   auto x5 = _mlsMethodCall<Callable>(x4)->apply2(_mlsValue::fromIntLit(3), _mlsValue::fromIntLit(4));
//│   _mls_retval = x5;
//│   return _mls_retval;
//│ }
//│ int main() { return _mlsLargeStack(_mlsMainWrapper); }
//│ 
//│ Interpreted:
//│ 10

:sllir
:intl
:scpp
fun add(a, b) = a + b
fun dummy() = add
dummy()(1, 2)
//│ = 3
//│ LLIR:
//│   class Lambda_add() extends Callable {
//│     def apply2$277(arg$273,arg$274) =
//│       let* (x$278) = add(arg$273,arg$274) in
//│       x$278
//│   }
//│   def add$254(a$256,b$257) =
//│     let x$272 = +(a$256,b$257) in
//│     x$272
//│   def dummy$255() =
//│     let x$279 = Lambda_add$275() in
//│     x$279
//│   let* (x$280) = dummy() in
//│   let x$281 = Callable.apply2$277(x$280,1,2) in
//│   x$281
//│ 
//│ Cpp:
//│ #include "mlsprelude.h"
//│ struct Lambda_add;
//│ _mlsValue add(_mlsValue, _mlsValue);
//│ _mlsValue dummy();
//│ _mlsValue _mlsMain();
//│ struct Lambda_add: public Callable {
//│   
//│   constexpr static inline const char *typeName = "Lambda_add";
//│   constexpr static inline uint32_t typeTag = nextTypeTag();
//│   virtual void print() const override { std::printf("%s", typeName); }
//│   virtual void destroy() override {  operator delete (this, std::align_val_t(_mlsAlignment)); }
//│   static _mlsValue create() { auto _mlsVal = new (std::align_val_t(_mlsAlignment)) Lambda_add; _mlsVal->refCount = 1; _mlsVal->tag = typeTag;  return _mlsValue(_mlsVal); }
//│   virtual _mlsValue apply2(_mlsValue arg, _mlsValue arg1) {
//│     _mlsValue _mls_retval;
//│     auto x = add(arg, arg1);
//│     _mls_retval = x;
//│     return _mls_retval;
//│   }
//│ };
//│ _mlsValue add(_mlsValue a, _mlsValue b) {
//│   _mlsValue _mls_retval;
//│   auto x1 = (a + b);
//│   _mls_retval = x1;
//│   return _mls_retval;
//│ }
//│ _mlsValue dummy() {
//│   _mlsValue _mls_retval;
//│   auto x2 = _mlsValue::create<Lambda_add>();
//│   _mls_retval = x2;
//│   return _mls_retval;
//│ }
//│ _mlsValue _mlsMain() {
//│   _mlsValue _mls_retval;
//│   auto x3 = dummy();
//│   auto x4 = _mlsMethodCall<Callable>(x3)->apply2(_mlsValue::fromIntLit(1), _mlsValue::fromIntLit(2));
//│   _mls_retval = x4;
//│   return _mls_retval;
//│ }
//│ int main() { return _mlsLargeStack(_mlsMainWrapper); }
//│ 
//│ Interpreted:
//│ 3

:sllir
:intl
abstract class List[out T]: Cons[T] | Nil
class (::) Cons[out T](head: T, tail: List[T]) extends List[T]
object Nil extends List
fun map(f, l) =
  if l is
    Cons(h, t) then Cons(f(h), map(f, t))
    Nil then Nil
fun inc(x) = x + 1
fun main() =
  map(x => inc(x), 1 :: 2 :: Nil)
  map(inc, 3 :: 4 :: Nil)
main()
//│ = Cons(4, Cons(5, Nil))
//│ LLIR:
//│   class List()
//│   class Cons(head$294,tail$295) extends List
//│   class Nil() extends List
//│   class Lambda() extends Callable {
//│     def apply1$367(x$312) =
//│       let* (x$378) = inc(x$312) in
//│       x$378
//│   }
//│   class Lambda_inc() extends Callable {
//│     def apply1$367(arg$384) =
//│       let* (x$387) = inc(arg$384) in
//│       x$387
//│   }
//│   def map$283(f$298,l$299) =
//│     case l$299 of
//│       Cons$291 =>
//│         let x$364 = l$299.<Cons$291:head> in
//│         let x$365 = l$299.<Cons$291:tail> in
//│         let x$366 = Callable.apply1$367(f$298,x$364) in
//│         let* (x$368) = map(f$298,x$365) in
//│         let x$369 = Cons$291(x$366,x$368) in
//│         x$369
//│       _ =>
//│         case l$299 of
//│           Nil$296 =>
//│             let x$371 = Nil$296() in
//│             x$371
//│           _ =>
//│             panic "match error"
//│   def j$370() =
//│     jump j$363()
//│   def j$363() =
//│     null
//│   def inc$286(x$308) =
//│     let x$372 = +(x$308,1) in
//│     x$372
//│   def main$284() =
//│     let x$373 = Nil$296() in
//│     let x$374 = Cons$291(2,x$373) in
//│     let x$375 = Cons$291(1,x$374) in
//│     let x$379 = Lambda$376() in
//│     let* (x$380) = map(x$379,x$375) in
//│     let x$381 = Nil$296() in
//│     let x$382 = Cons$291(4,x$381) in
//│     let x$383 = Cons$291(3,x$382) in
//│     let x$388 = Lambda_inc$385() in
//│     let* (x$389) = map(x$388,x$383) in
//│     x$389
//│   let* (x$390) = main() in
//│   x$390
//│ 
//│ Interpreted:
//│ Cons(4,Cons(5,Nil()))

