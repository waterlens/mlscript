:llir

abstract class Lazy[out A](init: () -> A) with
  fun get: A
fun lazy(x) = Lazy(x)
fun force(x) = if x is Lazy then x.Lazy#get()
type LazyList[out T] = Lazy[LzList[T]]
abstract class LzList[out T]: LzCons[T] | LzNil
class LzCons[out T](head: T, tail: LazyList[T]) extends LzList[T]
object LzNil extends LzList

:sllir
:scpp
fun side_effect() =
  console.log("executed")
  1
fun main() =
  let x = lazy(() => side_effect())
  let y = force(x)
  let y1 = force(x) // force again, but should not execute side_effect again
  ()
main()
//│ LLIR:
//│   class Lambda() extends Callable {
//│     def apply0$281() =
//│       let* (x$282) = side_effect() in
//│       x$282
//│   }
//│   def side_effect$254() =
//│     let* (x$276) = <builtin>("println","executed") in
//│     1
//│   def main$253() =
//│     let x$284 = Lambda$279() in
//│     let* (x$278) = lazy(x$284) in
//│     let* (x$285) = force(x$278) in
//│     let* (x$286) = force(x$278) in
//│     undefined
//│   let* (x$287) = main() in
//│   x$287
//│ 
//│ Cpp:
//│ #include "mlsprelude.h"
//│ struct _mls_Lambda;
//│ _mlsValue _mls_side_effect();
//│ _mlsValue _mls_main();
//│ _mlsValue _mlsMain();
//│ struct _mls_Lambda: public _mls_Callable {
//│   
//│   constexpr static inline const char *typeName = "Lambda";
//│   constexpr static inline uint32_t typeTag = nextTypeTag();
//│   virtual void print() const override { std::printf("%s", typeName); }
//│   virtual void destroy() override {  operator delete (this, std::align_val_t(_mlsAlignment)); }
//│   static _mlsValue create() { auto _mlsVal = new (std::align_val_t(_mlsAlignment)) _mls_Lambda; _mlsVal->refCount = 1; _mlsVal->tag = typeTag;  return _mlsValue(_mlsVal); }
//│   virtual _mlsValue _mls_apply0();
//│ };
//│ _mlsValue _mls_side_effect() {
//│   _mlsValue _mls_retval;
//│   auto _mls_x1 = _mls_builtin_println(_mlsValue::create<_mls_Str>("executed"));
//│   _mls_retval = _mlsValue::fromIntLit(1);
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_main() {
//│   _mlsValue _mls_retval;
//│   auto _mls_x2 = _mlsValue::create<_mls_Lambda>();
//│   auto _mls_x3 = _mls_lazy(_mls_x2);
//│   auto _mls_x4 = _mls_force(_mls_x3);
//│   auto _mls_x5 = _mls_force(_mls_x3);
//│   _mls_retval = _mlsValue::create<_mls_Unit>();
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_Lambda::_mls_apply0() {
//│   _mlsValue _mls_retval;
//│   auto _mls_x = _mls_side_effect();
//│   _mls_retval = _mls_x;
//│   return _mls_retval;
//│ }
//│ _mlsValue _mlsMain() {
//│   _mlsValue _mls_retval;
//│   auto _mls_x6 = _mls_main();
//│   _mls_retval = _mls_x6;
//│   return _mls_retval;
//│ }
//│ int main() { return _mlsLargeStack(_mlsMainWrapper); }
