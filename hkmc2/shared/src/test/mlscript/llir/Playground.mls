:js

:llir
abstract class Option[out T]: Some[T] | None
class Some[out T](x: T) extends Option[T]
object None extends Option
fun fromSome(s) = if s is Some(x) then x
class Lazy[out A](init: () -> A) with
  mut val cache: Option[A] = None
fun lazy(x) = Lazy(x)
//│ LLIR:
//│   class Option()
//│   class Some(x)
//│   class None()
//│   class Lazy(init,cache)
//│   def fromSome(s) =
//│     case s of
//│       Some =>
//│         let x$0 = s.<Some:x> in
//│         x$0
//│       _ =>
//│         panic "match error"
//│   def j$0() =
//│     null
//│   def lazy(x1) =
//│     let x$1 = Lazy(x1) in
//│     x$1
//│   undefined

:llir
fun testCtor1() = None
fun testCtor2() = new None
//│ LLIR:
//│   
//│   def testCtor1() =
//│     let x$0 = None() in
//│     x$0
//│   def testCtor2() =
//│     let x$1 = None() in
//│     x$1
//│   undefined

:llir
abstract class Option[out T]: Some[T] | None
class Some[out T](x: T) extends Option[T]
object None extends Option
fun fromSome(s) = if s is Some(x) then x
abstract class Nat: S[Nat] | O
class S(s: Nat) extends Nat
object O extends Nat
fun aaa() =
  let m = 1
  let n = 2
  let p = 3
  let q = 4
  m + n - p + q
fun bbb() =
  let x = aaa()
  x * 100 + 4
fun not(x) =
  if x then false else true
fun foo(x) =
  if x then None
       else Some(foo(not(x)))
fun main() =
  let x = foo(false)
  if x is
    None then aaa()
    Some(b1) then bbb()
main()
//│ = 404
//│ LLIR:
//│   class Option()
//│   class Some(x)
//│   class None()
//│   class Nat()
//│   class S(s)
//│   class O()
//│   def fromSome(s) =
//│     case s of
//│       Some =>
//│         let x$0 = s.<Some:x> in
//│         x$0
//│       _ =>
//│         panic "match error"
//│   def j$0() =
//│     null
//│   def aaa() =
//│     let x$1 = 1 in
//│     let x$2 = 2 in
//│     let x$3 = 3 in
//│     let x$4 = 4 in
//│     let x$5 = +(x$1,x$2) in
//│     let x$6 = -(x$5,x$3) in
//│     let x$7 = +(x$6,x$4) in
//│     x$7
//│   def bbb() =
//│     let* (x$8) = aaa() in
//│     let x$9 = *(x$8,100) in
//│     let x$10 = +(x$9,4) in
//│     x$10
//│   def not(x2) =
//│     case x2 of
//│       BoolLit(true) =>
//│         false
//│       _ =>
//│         true
//│   def j$1() =
//│     null
//│   def foo(x3) =
//│     case x3 of
//│       BoolLit(true) =>
//│         let x$11 = None() in
//│         x$11
//│       _ =>
//│         let* (x$12) = not(x3) in
//│         let* (x$13) = foo(x$12) in
//│         let x$14 = Some(x$13) in
//│         x$14
//│   def j$2() =
//│     null
//│   def main() =
//│     let* (x$15) = foo(false) in
//│     case x$15 of
//│       None =>
//│         let* (x$16) = aaa() in
//│         x$16
//│       _ =>
//│         case x$15 of
//│           Some =>
//│             let x$17 = x$15.<Some:x> in
//│             let* (x$18) = bbb() in
//│             x$18
//│           _ =>
//│             panic "match error"
//│   def j$4() =
//│     jump j$3()
//│   def j$3() =
//│     null
//│   let* (x$19) = main() in
//│   x$19

:llir
fun f1() =
  let x = 1
  let x = 2
  x
//│ LLIR:
//│   
//│   def f1() =
//│     let x$0 = 1 in
//│     let x$1 = 2 in
//│     x$1
//│   undefined

:slot
:llir
fun f2() =
  let x = 0
  if x == 1 then 2 else 3
//│ Pretty Lowered:
//│   define fun f2() { set x = 0 in set scrut = ==(x, 1) in match scrut true => return 2 else return 3 } in return null
//│ LLIR:
//│   
//│   def f2() =
//│     let x$0 = 0 in
//│     let x$1 = ==(x$0,1) in
//│     case x$1 of
//│       BoolLit(true) =>
//│         2
//│       _ =>
//│         3
//│   def j$0() =
//│     null
//│   undefined

:llir
:slot
fun f3() =
  let x1 = 0
  let x2 = 1
  if true then x1 else x2
//│ Pretty Lowered:
//│  
//│ define fun f3() {
//│   set x1 = 0 in
//│   set x2 = 1 in
//│   set scrut = true in
//│   match scrut
//│     true =>
//│       return x1
//│     else
//│       return x2
//│ } in
//│ return null
//│ LLIR:
//│   
//│   def f3() =
//│     let x$0 = 0 in
//│     let x$1 = 1 in
//│     let x$2 = true in
//│     case x$2 of
//│       BoolLit(true) =>
//│         x$0
//│       _ =>
//│         x$1
//│   def j$0() =
//│     null
//│   undefined


:slot
:llir
fun f4() =
  let x = 0
  let x = if x == 1 then 2 else 3
  x
//│ Pretty Lowered:
//│  
//│ define fun f4() {
//│   set x = 0 in
//│   begin
//│     set scrut = ==(x, 1) in
//│     match scrut
//│       true =>
//│         set tmp = 2 in
//│         end
//│       else
//│         set tmp = 3 in
//│         end;
//│     set x1 = tmp in
//│     return x1
//│ } in
//│ return null
//│ LLIR:
//│   
//│   def f4() =
//│     let x$0 = 0 in
//│     let x$1 = ==(x$0,1) in
//│     case x$1 of
//│       BoolLit(true) =>
//│         let x$3 = 2 in
//│         jump j$0(x$3)
//│       _ =>
//│         let x$4 = 3 in
//│         jump j$0(x$4)
//│   def j$0(x$2) =
//│     x$2
//│   undefined

:slot
:llir
fun f5() =
  let x = 0
  let x = if x == 1 then 2 else 3
  let x = if x == 2 then 4 else 5
  x
//│ Pretty Lowered:
//│  
//│ define fun f5() {
//│   set x = 0 in
//│   begin
//│     set scrut = ==(x, 1) in
//│     match scrut
//│       true =>
//│         set tmp = 2 in
//│         end
//│       else
//│         set tmp = 3 in
//│         end;
//│     set x1 = tmp in
//│     begin
//│       set scrut1 = ==(x1, 2) in
//│       match scrut1
//│         true =>
//│           set tmp1 = 4 in
//│           end
//│         else
//│           set tmp1 = 5 in
//│           end;
//│       set x2 = tmp1 in
//│       return x2
//│ } in
//│ return null
//│ LLIR:
//│   
//│   def f5() =
//│     let x$0 = 0 in
//│     let x$1 = ==(x$0,1) in
//│     case x$1 of
//│       BoolLit(true) =>
//│         let x$3 = 2 in
//│         jump j$0(x$3)
//│       _ =>
//│         let x$4 = 3 in
//│         jump j$0(x$4)
//│   def j$0(x$2) =
//│     let x$5 = ==(x$2,2) in
//│     case x$5 of
//│       BoolLit(true) =>
//│         let x$7 = 4 in
//│         jump j$1(x$7)
//│       _ =>
//│         let x$8 = 5 in
//│         jump j$1(x$8)
//│   def j$1(x$6) =
//│     x$6
//│   undefined

:llir
fun test() =
  if true do test()
//│ LLIR:
//│   
//│   def test() =
//│     let x$0 = true in
//│     case x$0 of
//│       BoolLit(true) =>
//│         let* (x$1) = test() in
//│         x$1
//│       _ =>
//│         undefined
//│   def j$0() =
//│     null
//│   undefined

:llir
fun test() =
  (if true then test()) + 1
//│ LLIR:
//│   
//│   def test() =
//│     let x$0 = true in
//│     case x$0 of
//│       BoolLit(true) =>
//│         let* (x$2) = test() in
//│         jump j$0(x$2)
//│       _ =>
//│         panic "match error"
//│   def j$0(x$1) =
//│     let x$3 = +(x$1,1) in
//│     x$3
//│   undefined

