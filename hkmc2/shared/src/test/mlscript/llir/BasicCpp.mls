
:global
:llir
:cpp

:sllir
fun foo(a) =
  let x
  if a > 0 do
    x = 1
  x + 1
//│ LLIR:
//│   
//│   def foo$195(a$196) =
//│     let x$203 = null in
//│     let x$204 = >(a$196,0) in
//│     case x$204 of
//│       BoolLit(true) =>
//│         let x$206 = 1 in
//│         let x$207 = undefined in
//│         jump j$205(x$206)
//│       _ =>
//│         let x$208 = undefined in
//│         jump j$205(x$203)
//│   def j$205(x$197) =
//│     let x$209 = +(x$197,1) in
//│     x$209
//│   undefined

:showWholeCpp
fun bar(x) =
  x + 1
foo(1)
//│ 
//│ WholeProgramCpp:
//│ #include "mlsprelude.h"
//│ _mlsValue _mls_j(_mlsValue);
//│ _mlsValue _mls_foo(_mlsValue);
//│ _mlsValue _mls_bar(_mlsValue);
//│ _mlsValue _mlsMain();
//│ _mlsValue _mls_j(_mlsValue _mls_x1) {
//│   _mlsValue _mls_retval;
//│   auto _mls_x = (_mls_x1 + _mlsValue::fromIntLit(1));
//│   _mls_retval = _mls_x;
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_foo(_mlsValue _mls_a) {
//│   _mlsValue _mls_retval;
//│   auto _mls_x2 = _mlsValue::create<_mls_Unit>();
//│   auto _mls_x3 = (_mls_a > _mlsValue::fromIntLit(0));
//│   if (_mlsValue::isIntLit(_mls_x3, 1)) {
//│     auto _mls_x5 = _mlsValue::fromIntLit(1);
//│     auto _mls_x6 = _mlsValue::create<_mls_Unit>();
//│     _mls_retval = _mls_j(_mls_x5);
//│   } else {
//│     auto _mls_x4 = _mlsValue::create<_mls_Unit>();
//│     _mls_retval = _mls_j(_mls_x2);
//│   }
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_bar(_mlsValue _mls_x8) {
//│   _mlsValue _mls_retval;
//│   auto _mls_x7 = (_mls_x8 + _mlsValue::fromIntLit(1));
//│   _mls_retval = _mls_x7;
//│   return _mls_retval;
//│ }
//│ _mlsValue _mlsMain() {
//│   _mlsValue _mls_retval;
//│   auto _mls_x9 = _mls_foo(_mlsValue::fromIntLit(1));
//│   _mls_retval = _mls_x9;
//│   return _mls_retval;
//│ }
//│ int main() { return _mlsLargeStack(_mlsMainWrapper); }
