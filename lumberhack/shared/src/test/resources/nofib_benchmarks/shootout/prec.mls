:NewParser
:ParseOnly

:lhNoIter
:lhInHaskell
:lhGenOCaml
:lhToMls
arith a b c d =
  let x = a * b * c in
  let y = (a * b) + (c * d) in
  let z = (a < b) + (b < c) in
  let z2 = a < (b + b) < c in
  let a1 = a + b - c + d in
  (0)
//│ ||
//│ Parsed: {}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ 		---------- unoptimized mls gen ----------
//│ fun map(f)(ls) =
//│   if ls is
//│     LH_C (h, t) then
//│       LH_C ((f(h)), (map(f)(f)))
//│     LH_N then
//│       LH_N ()
//│ fun map_lz(f)(ls) =
//│   lazy((if force(ls) is
//│     LH_C (h, t) then
//│       LH_C ((f(h)), (map_lz(f)(f)))
//│     LH_N then
//│       LH_N ()))
//│ fun filter(f)(ls) =
//│   if ls is
//│     LH_C (h, t) then
//│       if f(h) then
//│         LH_C (h, (filter(f)(f)))
//│       else
//│         (filter(f)(f))
//│     LH_N then
//│       LH_N ()
//│ fun filter_lz(f)(ls) =
//│   lazy((if force(ls) is
//│     LH_C (h, t) then
//│       if f(h) then
//│         LH_C (h, (filter_lz(f)(f)))
//│       else
//│         (force((filter_lz(f)(f))))
//│     LH_N then
//│       LH_N ()))
//│ fun foldl(f)(i)(ls) =
//│   if ls is
//│     LH_C (h, t) then
//│       foldl(f)(f)((f(i)(i)))
//│     LH_N then
//│       i
//│ fun foldr(f)(i)(ls) =
//│   if ls is
//│     LH_C (h, t) then
//│       f(h)(h)
//│     LH_N then
//│       i
//│ fun foldr_lz(f)(i)(ls) =
//│   lazy((if force(ls) is
//│     LH_C (h, t) then
//│       f(h)(h)
//│     LH_N then
//│       i))
//│ fun zip(xs)(ys) =
//│   if xs is
//│     LH_C (hx, tx) then
//│       if ys is
//│         LH_C (hy, ty) then
//│           LH_C ((LH_P2 (hx, hy)), (zip(tx)(tx)))
//│         LH_N then
//│           LH_N ()
//│     LH_N then
//│       LH_N ()
//│ fun zip_nl_lz(xs)(ys) =
//│   if xs is
//│     LH_C (hx, tx) then
//│       if force(ys) is
//│         LH_C (hy, ty) then
//│           LH_C ((LH_P2 (hx, hy)), (zip_nl_lz(tx)(tx)))
//│         LH_N then
//│           LH_N ()
//│     LH_N then
//│       LH_N ()
//│ fun zip_lz_nl(xs)(ys) =
//│   if ys is
//│     LH_C (hy, ty) then
//│       if force(xs) is
//│         LH_C (hx, tx) then
//│           LH_C ((LH_P2 (hx, hy)), (zip_lz_nl(tx)(tx)))
//│         LH_N then
//│           LH_N ()
//│     LH_N then
//│       LH_N ()
//│ fun zip_lz_lz(xs)(ys) =
//│   lazy((if force(xs) is
//│     LH_C (hx, tx) then
//│       if force(ys) is
//│         LH_C (hy, ty) then
//│           LH_C ((LH_P2 (hx, hy)), (zip_lz_lz(tx)(tx)))
//│         LH_N then
//│           LH_N ()
//│     LH_N then
//│       LH_N ()))
//│ fun zipWith(f)(xs)(ys) =
//│   if xs is
//│     LH_C (hx, tx) then
//│       if ys is
//│         LH_C (hy, ty) then
//│           LH_C ((f(hx)(hx)), (zipWith(f)(f)(tx)))
//│         LH_N then
//│           LH_N ()
//│     LH_N then
//│       LH_N ()
//│ fun zipWith_nl_lz(f)(xs)(ys) =
//│   if xs is
//│     LH_C (hx, tx) then
//│       if force(ys) is
//│         LH_C (hy, ty) then
//│           LH_C ((f(hx)(hx)), (zipWith_nl_lz(f)(f)(tx)))
//│         LH_N then
//│           LH_N ()
//│     LH_N then
//│       LH_N ()
//│ fun zipWith_lz_nl(f)(xs)(ys) =
//│   if ys is
//│     LH_C (hy, ty) then
//│       if force(xs) is
//│         LH_C (hx, tx) then
//│           LH_C ((f(hx)(hx)), (zipWith_lz_nl(f)(f)(tx)))
//│         LH_N then
//│           LH_N ()
//│     LH_N then
//│       LH_N ()
//│ fun zipWith_lz_lz(f)(xs)(ys) =
//│   lazy((if force(xs) is
//│     LH_C (hx, tx) then
//│       if force(ys) is
//│         LH_C (hy, ty) then
//│           LH_C ((f(hx)(hx)), (zipWith_lz_lz(f)(f)(tx)))
//│         LH_N then
//│           LH_N ()
//│     LH_N then
//│       LH_N ()))
//│ fun head(ls) =
//│   if ls is
//│     LH_C (h, t) then
//│       h
//│     LH_N then
//│       error
//│ fun head_lz(ls) =
//│   if force(ls) is
//│     LH_C (h, t) then
//│       h
//│     LH_N then
//│       error
//│ fun tail(ls) =
//│   if ls is
//│     LH_C (h, t) then
//│       t
//│     LH_N then
//│       error
//│ fun tail_lz(ls) =
//│   if force(ls) is
//│     LH_C (h, t) then
//│       t
//│     LH_N then
//│       error
//│ fun enumFromTo(a)(b) =
//│   if a <= b then
//│     LH_C (a, (enumFromTo((a + 1))((a + 1))))
//│   else
//│     (LH_N ())
//│ fun enumFromThenTo(a)(t)(b) =
//│   if a <= b then
//│     LH_C (a, (enumFromThenTo(t)(t)((2 * t - a))))
//│   else
//│     (LH_N ())
//│ fun enumFrom(a) =
//│   lazy((LH_C (a, (enumFrom((a + 1))))))
//│ fun enumFromThen(a)(t) =
//│   lazy((LH_C (a, (enumFromThen(t)(t)))))
//│ fun repeat(x) =
//│   lazy((LH_C (x, (repeat(x)))))
//│ fun iterate(f)(x) =
//│   lazy((LH_C (x, (iterate(f)(f)))))
//│ fun take(n)(ls) =
//│   if n > 0 then
//│     if ls is
//│       LH_C (h, t) then
//│         LH_C (h, (take((n - 1))((n - 1))))
//│       LH_N then
//│         LH_N ()
//│   else
//│     (LH_N ())
//│ fun take_lz(n)(ls) =
//│   if n > 0 then
//│     if force(ls) is
//│       LH_C (h, t) then
//│         LH_C (h, (take_lz((n - 1))((n - 1))))
//│       LH_N then
//│         LH_N ()
//│   else
//│     (LH_N ())
//│ fun length(ls) =
//│   if ls is
//│     LH_C (h, t) then
//│       1 + (length(t))
//│     LH_N then
//│       0
//│ fun mappend(xs)(ys) =
//│   if xs is
//│     LH_C (h, t) then
//│       LH_C (h, (mappend(t)(t)))
//│     LH_N then
//│       ys
//│ fun sum(ls) =
//│   sumAux(ls)(ls)
//│ fun sumAux(ls)(a) =
//│   if ls is
//│     LH_N then
//│       a
//│     LH_C (h, t) then
//│       sumAux(t)(t)
//│ fun atIndex(n)(ls) =
//│   if n < 0 then
//│     error
//│   else
//│     (if ls is
//│       LH_C (h, t) then
//│         if n == 0 then
//│           h
//│         else
//│           (atIndex((n - 1))((n - 1)))
//│       LH_N then
//│         error)
//│ fun atIndex_lz(n)(ls) =
//│   if n < 0 then
//│     error
//│   else
//│     (if force(ls) is
//│       LH_C (h, t) then
//│         if n == 0 then
//│           h
//│         else
//│           (atIndex_lz((n - 1))((n - 1)))
//│       LH_N then
//│         error)
//│ fun concat(lss) =
//│   if lss is
//│     LH_C (h, t) then
//│       mappend(h)(h)
//│     LH_N then
//│       LH_N ()
//│ fun reverse(ls) =
//│   reverse_helper(ls)(ls)
//│ fun reverse_helper(ls)(a) =
//│   if ls is
//│     LH_C (h, t) then
//│       reverse_helper(t)(t)
//│     LH_N then
//│       a
//│ fun arith(_lh_arith_arg1)(_lh_arith_arg2)(_lh_arith_arg3)(_lh_arith_arg4) =
//│   let x = _lh_arith_arg1 * _lh_arith_arg2 * _lh_arith_arg3
//│   let y = _lh_arith_arg1 * _lh_arith_arg2 + _lh_arith_arg3 * _lh_arith_arg4
//│   let z = (_lh_arith_arg1 < _lh_arith_arg2) + (_lh_arith_arg2 < _lh_arith_arg3)
//│   let z2 = _lh_arith_arg1 < _lh_arith_arg2 + _lh_arith_arg2 < _lh_arith_arg3
//│   let a1 = _lh_arith_arg1 + _lh_arith_arg2 - _lh_arith_arg3 + _lh_arith_arg4
//│   0
//│ 		---------- unoptimized mls gen ----------
//│ 
//│ 		---------- unoptimized ocaml gen ----------
//│ 
//│ 		---------- unoptimized ocaml gen ----------
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ 
//│ ------------------
//│ 
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ 
//│ ------------------
//│ 
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ 
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>> consumer ids >>>>>>>
//│ 
//│ <<<<<<< consumer ids <<<<<<<
//│ 
//│ >>>>>>> floating out info >>>>>>>
//│ 
//│ <<<<<<< floating out info <<<<<<<
//│ 
//│ >>>>>>> after inlining >>>>>>>
//│ 
//│ <<<<<<< after inlining <<<<<<<
//│ 
//│ >>>>>>> after floating out >>>>>>>
//│ 
//│ <<<<<<< after floating out <<<<<<<
//│ 
//│ >>>>>>>>>> Generated OCaml >>>>>>>>>>
//│ cannot generate benchmark files: Internal Error: benchmark requires a method of name `testxxx` calling a value wrapped in `primId`
//│  and if there are manually fused benchmarks, there should be a call to `testManual`with exact the same parameter following the `testxxx`
//│ 
//│ 
//│ <<<<<<<<<< Generated OCaml <<<<<<<<<<
