:NewParser
:ParseOnly

// dead branch causes dead producer, which causes problem
// can be fixed by elminating dead branches, or blocking fusion when encountering
// dead producers
:lhGenOCaml
:d
fun main(x) = if x is
  C(t) then G
  n then if n is
    C(t) then if True then g(t) else h(t) // dead branch, DeadCodeCons <: 't
    N then G
fun g(x) = if x is
  N then g(C(N)) // this C(x) is fused, making g'(x) = x(99)
  C(t) then G
fun h(x) = if x is
  N then H
  C(t) then H
main(N)
//│ |#fun| |main|(|x|)| |#=| |#if| |x| |is|→|C|(|t|)| |#then| |G|↵|n| |#then| |#if| |n| |is|→|C|(|t|)| |#then| |#if| |True| |#then| |g|(|t|)| |#else| |h|(|t|)| |/* dead branch, DeadCodeCons <: 't*/|↵|N| |#then| |G|←|←|↵|#fun| |g|(|x|)| |#=| |#if| |x| |is|→|N| |#then| |g|(|C|(|N|)|)| |/* this C(x) is fused, making g'(x) = x(99)*/|↵|C|(|t|)| |#then| |G|←|↵|#fun| |h|(|x|)| |#=| |#if| |x| |is|→|N| |#then| |H|↵|C|(|t|)| |#then| |H|←|↵|main|(|N|)|
//│ Parsed: {fun main = x, => if x is ‹(C (t,)) then G; (n) then if n is ‹(C (t,)) then if (True) then g (t,) else h (t,); (N) then G››; fun g = x, => if x is ‹(N) then g (C (N,),); (C (t,)) then G›; fun h = x, => if x is ‹(N) then H; (C (t,)) then H›; main (N,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ main^29([N])
//│ def g(x¹) = case x¹ of {
//│ 	N  => g^17([C [N]])
//│ 	| C t² => [G]}
//│ def h(x²) = case x² of {
//│ 	N  => [H]
//│ 	| C t³ => [H]}
//│ def main(x⁰) = case x⁰ of {
//│ 	C t⁰ => [G]
//│ 	| n⁰ => case n⁰ of {
//│ 		C t¹ => if [True] then g^5(t¹) else h^8(t¹)
//│ 		| N  => [G]}}
//│ 		---------- unoptimized ocaml gen ----------
//│ 		let rec g x_1 =
//│ 		  (match x_1 with
//│ 		    | `N -> 
//│ 		      (g (`C((`N))))
//│ 		    | `C(t_2) -> 
//│ 		      (`G));;
//│ 		let rec h x_2 =
//│ 		  (match x_2 with
//│ 		    | `N -> 
//│ 		      (`H)
//│ 		    | `C(t_3) -> 
//│ 		      (`H));;
//│ 		let rec main x_0 =
//│ 		  (match x_0 with
//│ 		    | `C(t_0) -> 
//│ 		      (`G)
//│ 		    | n_0 -> 
//│ 		      (match n_0 with
//│ 		        | `C(t_1) -> 
//│ 		          (if true then
//│ 		            (g t_1)
//│ 		          else
//│ 		            (h t_1))
//│ 		        | `N -> 
//│ 		          (`G)));;
//│ 		(main (`N))
//│ 		....... ocaml repl result .......
//│ /!!!\ Uncaught error: java.io.IOException: Cannot run program "/Users/crescentonc/.opam/benchmarkflambda/bin/ocaml": error=2, No such file or directory
//│ 	at: java.base/java.lang.ProcessBuilder.start(ProcessBuilder.java:1128)
//│ 	at: java.base/java.lang.ProcessBuilder.start(ProcessBuilder.java:1071)
//│ 	at: mlscript.lumberhack.OCamlReplHost.<init>(DiffTestLumberhack.scala:580)
//│ 	at: mlscript.lumberhack.DiffTestLumberhack.postProcess(DiffTestLumberhack.scala:106)
//│ 	at: mlscript.DiffTests.rec$1(DiffTests.scala:396)
//│ 	at: mlscript.DiffTests.$anonfun$new$3(DiffTests.scala:803)
//│ 	at: org.scalatest.OutcomeOf.outcomeOf(OutcomeOf.scala:85)
//│ 	at: org.scalatest.OutcomeOf.outcomeOf$(OutcomeOf.scala:83)
//│ 	at: org.scalatest.OutcomeOf$.outcomeOf(OutcomeOf.scala:104)
//│ 	at: org.scalatest.Transformer.apply(Transformer.scala:22)


// FIXME: the solution to only eliminate dead branches is not complete and cannot work here
// some deadbranches will not be eliminated and the type-error code is still there
:d
:lhGenOCaml
fun main(x) = if x is
  C(t) then G
  n then hiddenDeadBranch(n)
fun hiddenDeadBranch(n) = if n is
  C(t) then                               // dead branch which is more difficult to detect due to the recursive call below
    let dummy = hiddenDeadBranch(C(t))    // I think recursive calls like this makes tracking dead branches more troublesome... need to be globally flow sensitive?
    if True then g(t) else h(t)           
  N then G                                
fun g(x) = if x is
  N then g(C(N))                          // this C(N) is fused, making fun g'(x) = x(99)
  C(t) then G
fun h(x) = if x is                        // the consumer in h is not fused
  N then H
  C(t) then H
main(N)
//│ |#fun| |main|(|x|)| |#=| |#if| |x| |is|→|C|(|t|)| |#then| |G|↵|n| |#then| |hiddenDeadBranch|(|n|)|←|↵|#fun| |hiddenDeadBranch|(|n|)| |#=| |#if| |n| |is|→|C|(|t|)| |#then| |/* dead branch which is more difficult to detect due to the recursive call below*/|→|#let| |dummy| |#=| |hiddenDeadBranch|(|C|(|t|)|)| |/* I think recursive calls like this makes tracking dead branches more troublesome... need to be globally flow sensitive?*/|↵|#if| |True| |#then| |g|(|t|)| |#else| |h|(|t|)| |←|↵|N| |#then| |G| |←|↵|#fun| |g|(|x|)| |#=| |#if| |x| |is|→|N| |#then| |g|(|C|(|N|)|)| |/* this C(N) is fused, making fun g'(x) = x(99)*/|↵|C|(|t|)| |#then| |G|←|↵|#fun| |h|(|x|)| |#=| |#if| |x| |is| |/* the consumer in h is not fused*/|→|N| |#then| |H|↵|C|(|t|)| |#then| |H|←|↵|main|(|N|)|
//│ Parsed: {fun main = x, => if x is ‹(C (t,)) then G; (n) then hiddenDeadBranch (n,)›; fun hiddenDeadBranch = n, => if n is ‹(C (t,)) then {let dummy = hiddenDeadBranch (C (t,),); if (True) then g (t,) else h (t,)}; (N) then G›; fun g = x, => if x is ‹(N) then g (C (N,),); (C (t,)) then G›; fun h = x, => if x is ‹(N) then H; (C (t,)) then H›; main (N,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ main^38([N])
//│ def g(x¹) = case x¹ of {
//│ 	N  => g^26([C [N]])
//│ 	| C t² => [G]}
//│ def h(x²) = case x² of {
//│ 	N  => [H]
//│ 	| C t³ => [H]}
//│ def hiddenDeadBranch(n¹) = case n¹ of {
//│ 	C t¹ => 
//│ 		let dummy⁰ = hiddenDeadBranch^9([C t¹])
//│ 		in if [True] then g^14(t¹) else h^17(t¹)
//│ 	| N  => [G]}
//│ def main(x⁰) = case x⁰ of {
//│ 	C t⁰ => [G]
//│ 	| n⁰ => hiddenDeadBranch^3(n⁰)}
//│ 		---------- unoptimized ocaml gen ----------
//│ 		let rec h x_2 =
//│ 		  (match x_2 with
//│ 		    | `N -> 
//│ 		      (`H)
//│ 		    | `C(t_3) -> 
//│ 		      (`H));;
//│ 		let rec g x_1 =
//│ 		  (match x_1 with
//│ 		    | `N -> 
//│ 		      (g (`C((`N))))
//│ 		    | `C(t_2) -> 
//│ 		      (`G));;
//│ 		let rec hiddenDeadBranch n_1 =
//│ 		  (match n_1 with
//│ 		    | `C(t_1) -> 
//│ 		      (let rec dummy_0 = (hiddenDeadBranch (`C(t_1))) in
//│ 		        (if true then
//│ 		          (g t_1)
//│ 		        else
//│ 		          (h t_1)))
//│ 		    | `N -> 
//│ 		      (`G));;
//│ 		let rec main x_0 =
//│ 		  (match x_0 with
//│ 		    | `C(t_0) -> 
//│ 		      (`G)
//│ 		    | n_0 -> 
//│ 		      (hiddenDeadBranch n_0));;
//│ 		(main (`N))
//│ 		....... ocaml repl result .......
//│ /!!!\ Uncaught error: java.io.IOException: Cannot run program "/Users/crescentonc/.opam/benchmarkflambda/bin/ocaml": error=2, No such file or directory


// FIXME: the solution to only eliminate dead branches is not complete and cannot work here
// some deadbranches will not be eliminated and the type-error code is still there
:lhGenOCaml
:d
fun break(p, ls) = if ls is
  N then P(N, N)
  C(x, xs) then if p(x) then P(N, C(x, xs)) else if break1(p, xs) is
    P(ys, zs) then P(C(x, ys), zs)
fun break1(p, ls) = if ls is
  N then P(N, N)
  C(x, xs) then if p(x) then P(N, C(x, xs)) else if break1(p, xs) is
    P(ys, zs) then P(C(x, ys), zs)
fun words(s) =
  let scrut = dropWhile(x => x == 1, s)
  if scrut is
    N then N
    _ then if break(x => x == 1, scrut) is
      P(w, s'') then C(w, words(s''))
fun dropWhile(f, ls) = if ls is
  N then N
  C(h, t) then if f(h) then dropWhile(f, t) else C(h, t)
words(C(2, C(1, C(2, C(1, C(2, N))))))
//│ |#fun| |break|(|p|,| |ls|)| |#=| |#if| |ls| |is|→|N| |#then| |P|(|N|,| |N|)|↵|C|(|x|,| |xs|)| |#then| |#if| |p|(|x|)| |#then| |P|(|N|,| |C|(|x|,| |xs|)|)| |#else| |#if| |break1|(|p|,| |xs|)| |is|→|P|(|ys|,| |zs|)| |#then| |P|(|C|(|x|,| |ys|)|,| |zs|)|←|←|↵|#fun| |break1|(|p|,| |ls|)| |#=| |#if| |ls| |is|→|N| |#then| |P|(|N|,| |N|)|↵|C|(|x|,| |xs|)| |#then| |#if| |p|(|x|)| |#then| |P|(|N|,| |C|(|x|,| |xs|)|)| |#else| |#if| |break1|(|p|,| |xs|)| |is|→|P|(|ys|,| |zs|)| |#then| |P|(|C|(|x|,| |ys|)|,| |zs|)|←|←|↵|#fun| |words|(|s|)| |#=|→|#let| |scrut| |#=| |dropWhile|(|x| |=>| |x| |==| |1|,| |s|)|↵|#if| |scrut| |is|→|N| |#then| |N|↵|_| |#then| |#if| |break|(|x| |=>| |x| |==| |1|,| |scrut|)| |is|→|P|(|w|,| |s''|)| |#then| |C|(|w|,| |words|(|s''|)|)|←|←|←|↵|#fun| |dropWhile|(|f|,| |ls|)| |#=| |#if| |ls| |is|→|N| |#then| |N|↵|C|(|h|,| |t|)| |#then| |#if| |f|(|h|)| |#then| |dropWhile|(|f|,| |t|)| |#else| |C|(|h|,| |t|)|←|↵|words|(|C|(|2|,| |C|(|1|,| |C|(|2|,| |C|(|1|,| |C|(|2|,| |N|)|)|)|)|)|)|
//│ Parsed: {fun break = p, ls, => if ls is ‹(N) then P (N, N,); (C (x, xs,)) then if (p (x,)) then P (N, C (x, xs,),) else if break1 (p, xs,) is ‹(P (ys, zs,)) then P (C (x, ys,), zs,)››; fun break1 = p, ls, => if ls is ‹(N) then P (N, N,); (C (x, xs,)) then if (p (x,)) then P (N, C (x, xs,),) else if break1 (p, xs,) is ‹(P (ys, zs,)) then P (C (x, ys,), zs,)››; fun words = s, => {let scrut = dropWhile (x, => == (x,) (1,), s,); if scrut is ‹(N) then N; (_) then if break (x, => == (x,) (1,), scrut,) is ‹(P (w, s'',)) then C (w, words (s'',),)››}; fun dropWhile = f, ls, => if ls is ‹(N) then N; (C (h, t,)) then if (f (h,)) then dropWhile (f, t,) else C (h, t,)›; words (C (2, C (1, C (2, C (1, C (2, N,),),),),),)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ words^103([C 2 [C 1 [C 2 [C 1 [C 2 [N]]]]]])
//│ def break(p⁰, ls⁰) = case ls⁰ of {
//│ 	N  => [P [N] [N]]
//│ 	| C x⁰ xs⁰ => if p⁰(x⁰) then [P [N] [C x⁰ xs⁰]] else case break1^13(p⁰, xs⁰) of {
//│ 		P ys⁰ zs⁰ => [P [C x⁰ ys⁰] zs⁰]}}
//│ def break1(p¹, ls¹) = case ls¹ of {
//│ 	N  => [P [N] [N]]
//│ 	| C x¹ xs¹ => if p¹(x¹) then [P [N] [C x¹ xs¹]] else case break1^40(p¹, xs¹) of {
//│ 		P ys¹ zs¹ => [P [C x¹ ys¹] zs¹]}}
//│ def dropWhile(f⁰, ls²) = case ls² of {
//│ 	N  => [N]
//│ 	| C h⁰ t⁰ => if f⁰(h⁰) then dropWhile^91(f⁰, t⁰) else [C h⁰ t⁰]}
//│ def words(s⁰) = 
//│ 	let scrut⁰ = dropWhile^55((fun x² -> (x² == 1)), s⁰)
//│ 	in case scrut⁰ of {
//│ 		N  => [N]
//│ 		| _  => case break^67((fun x³ -> (x³ == 1)), scrut⁰) of {
//│ 			P w⁰ s''⁰ => [C w⁰ words^78(s''⁰)]}}
//│ 		---------- unoptimized ocaml gen ----------
//│ 		let rec dropWhile f_0 ls_2 =
//│ 		  (match ls_2 with
//│ 		    | `N -> 
//│ 		      (`N)
//│ 		    | `C(h_0, t_0) -> 
//│ 		      (if (f_0 h_0) then
//│ 		        ((dropWhile f_0) t_0)
//│ 		      else
//│ 		        (`C(h_0, t_0))));;
//│ 		let rec break1 p_1 ls_1 =
//│ 		  (match ls_1 with
//│ 		    | `N -> 
//│ 		      (`P((`N), (`N)))
//│ 		    | `C(x_1, xs_1) -> 
//│ 		      (if (p_1 x_1) then
//│ 		        (`P((`N), (`C(x_1, xs_1))))
//│ 		      else
//│ 		        (match ((break1 p_1) xs_1) with
//│ 		          | `P(ys_1, zs_1) -> 
//│ 		            (`P((`C(x_1, ys_1)), zs_1)))));;
//│ 		let rec break p_0 ls_0 =
//│ 		  (match ls_0 with
//│ 		    | `N -> 
//│ 		      (`P((`N), (`N)))
//│ 		    | `C(x_0, xs_0) -> 
//│ 		      (if (p_0 x_0) then
//│ 		        (`P((`N), (`C(x_0, xs_0))))
//│ 		      else
//│ 		        (match ((break1 p_0) xs_0) with
//│ 		          | `P(ys_0, zs_0) -> 
//│ 		            (`P((`C(x_0, ys_0)), zs_0)))));;
//│ 		let rec words s_0 =
//│ 		  (let rec scrut_0 = ((dropWhile (fun x_2 -> 
//│ 		    (x_2 = 1))) s_0) in
//│ 		    (match scrut_0 with
//│ 		      | `N -> 
//│ 		        (`N)
//│ 		      | _ -> 
//│ 		        (match ((break (fun x_3 -> 
//│ 		          (x_3 = 1))) scrut_0) with
//│ 		          | `P(w_0, s''_0) -> 
//│ 		            (`C(w_0, (words s''_0))))));;
//│ 		(words (`C(2, (`C(1, (`C(2, (`C(1, (`C(2, (`N))))))))))))
//│ 		....... ocaml repl result .......
//│ /!!!\ Uncaught error: java.io.IOException: Cannot run program "/Users/crescentonc/.opam/benchmarkflambda/bin/ocaml": error=2, No such file or directory
