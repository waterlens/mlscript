fun map(f)(ls) =
  if ls is
    Cons(h, t) then
      Cons(f(h), map(f)(t))
    Nil then
      Nil
fun map_lz(f)(ls) =
  lazy(
    if force(ls) is
      Cons(h, t) then
        Cons(f(h), map_lz(f)(t))
      Nil then
        Nil
  )
fun filter(f)(ls) =
  if ls is
    Cons(h, t) then
      if f(h) then
        Cons(h, filter(f)(t))
      else
        (filter(f)(t))
    Nil then
      Nil
fun filter_lz(f)(ls) =
  lazy(
    if force(ls) is
      Cons(h, t) then
        if f(h) then
          Cons(h, filter_lz(f)(t))
        else
          (force(filter_lz(f)(t)))
      Nil then
        Nil
  )
fun foldl(f)(i)(ls) =
  if ls is
    Cons(h, t) then
      foldl(f)(f(i)(h))(t)
    Nil then
      i
fun foldr(f)(i)(ls) =
  if ls is
    Cons(h, t) then
      f(h)(foldr(f)(i)(t))
    Nil then
      i
fun foldr_lz(f)(i)(ls) =
  lazy(
    if force(ls) is
      Cons(h, t) then
        f(h)(foldr_lz(f)(i)(t))
      Nil then
        i
  )
fun zip(xs)(ys) =
  if xs is
    Cons(hx, tx) then
      if ys is
        Cons(hy, ty) then
          Cons(Tuple2(hx, hy), zip(tx)(ty))
        Nil then
          Nil
    Nil then
      Nil
fun zip_nl_lz(xs)(ys) =
  if xs is
    Cons(hx, tx) then
      if force(ys) is
        Cons(hy, ty) then
          Cons(Tuple2(hx, hy), zip_nl_lz(tx)(ty))
        Nil then
          Nil
    Nil then
      Nil
fun zip_lz_nl(xs)(ys) =
  if ys is
    Cons(hy, ty) then
      if force(xs) is
        Cons(hx, tx) then
          Cons(Tuple2(hx, hy), zip_lz_nl(tx)(ty))
        Nil then
          Nil
    Nil then
      Nil
fun zip_lz_lz(xs)(ys) =
  lazy(
    if force(xs) is
      Cons(hx, tx) then
        if force(ys) is
          Cons(hy, ty) then
            Cons(Tuple2(hx, hy), zip_lz_lz(tx)(ty))
          Nil then
            Nil
      Nil then
        Nil
  )
fun zipWith(f)(xs)(ys) =
  if xs is
    Cons(hx, tx) then
      if ys is
        Cons(hy, ty) then
          Cons(f(hx)(hy), zipWith(f)(tx)(ty))
        Nil then
          Nil
    Nil then
      Nil
fun zipWith_nl_lz(f)(xs)(ys) =
  if xs is
    Cons(hx, tx) then
      if force(ys) is
        Cons(hy, ty) then
          Cons(f(hx)(hy), zipWith_nl_lz(f)(tx)(ty))
        Nil then
          Nil
    Nil then
      Nil
fun zipWith_lz_nl(f)(xs)(ys) =
  if ys is
    Cons(hy, ty) then
      if force(xs) is
        Cons(hx, tx) then
          Cons(f(hx)(hy), zipWith_lz_nl(f)(tx)(ty))
        Nil then
          Nil
    Nil then
      Nil
fun zipWith_lz_lz(f)(xs)(ys) =
  lazy(
    if force(xs) is
      Cons(hx, tx) then
        if force(ys) is
          Cons(hy, ty) then
            Cons(f(hx)(hy), zipWith_lz_lz(f)(tx)(ty))
          Nil then
            Nil
      Nil then
        Nil
  )
fun head(ls) =
  if ls is
    Cons(h, t) then
      h
    Nil then
      error
fun head_lz(ls) =
  if force(ls) is
    Cons(h, t) then
      h
    Nil then
      error
fun tail(ls) =
  if ls is
    Cons(h, t) then
      t
    Nil then
      error
fun tail_lz(ls) =
  if force(ls) is
    Cons(h, t) then
      t
    Nil then
      error
fun enumFromTo(a)(b) =
  if a <= b then
    Cons(a, enumFromTo(a + 1)(b))
  else
    Nil
fun enumFromThenTo(a)(t)(b) =
  if a <= b then
    Cons(a, enumFromThenTo(t)(2 * t - a)(b))
  else
    Nil
fun enumFrom(a) =
  lazy(Cons(a, enumFrom(a + 1)))
fun enumFromThen(a)(t) =
  lazy(Cons(a, enumFromThen(t)(2 * t - a)))
fun repeat(x) =
  lazy(Cons(x, repeat(x)))
fun iterate(f)(x) =
  lazy(Cons(x, iterate(f)(f(x))))
fun take(n)(ls) =
  if n > 0 then
    if ls is
      Cons(h, t) then
        Cons(h, take(n - 1)(t))
      Nil then
        Nil
  else
    Nil
fun take_lz(n)(ls) =
  if n > 0 then
    if force(ls) is
      Cons(h, t) then
        Cons(h, take_lz(n - 1)(t))
      Nil then
        Nil
  else
    Nil
fun length(ls) =
  if ls is
    Cons(h, t) then
      1 + (length(t))
    Nil then
      0
fun mappend(xs)(ys) =
  if xs is
    Cons(h, t) then
      Cons(h, mappend(t)(ys))
    Nil then
      ys
fun sum(ls) =
  sumAux(ls)(0)
fun sumAux(ls)(a) =
  if ls is
    Nil then
      a
    Cons(h, t) then
      sumAux(t)(a + h)
fun atIndex(n)(ls) =
  if n < 0 then
    error
  else
    if ls is
      Cons(h, t) then
        if n == 0 then
          h
        else
          (atIndex(n - 1)(t))
      Nil then
        error
fun atIndex_lz(n)(ls) =
  if n < 0 then
    error
  else
    if force(ls) is
      Cons(h, t) then
        if n == 0 then
          h
        else
          (atIndex_lz(n - 1)(t))
      Nil then
        error
fun concat(lss) =
  if lss is
    Cons(h, t) then
      mappend(h)(concat(t))
    Nil then
      Nil
fun reverse(ls) =
  reverse_helper(ls)(Nil)
fun reverse_helper(ls)(a) =
  if ls is
    Cons(h, t) then
      reverse_helper(t)(Cons(h, a))
    Nil then
      a
fun testPiDigits_nofib(testPiDigits_nofib1) =
  pidgits(testPiDigits_nofib1)
fun drop_lz(drop_lz1)(drop_lz2) =
  if drop_lz1 > 0 then
    lazy(
      let mi = force(drop_lz2)
      if mi is
        Nil then
          Nil
        Cons(drop_lz_Cons_0, drop_lz_Cons_1) then
          force(drop_lz(drop_lz1 - 1)(drop_lz_Cons_1))
    )
  else
    drop_lz2
fun min(min1)(min2) =
  if min1 > min2 then
    min2
  else
    min1
fun replicate(replicate1)(replicate2) =
  if replicate1 > 0 then
    Cons(replicate2, replicate(replicate1 - 1)(replicate2))
  else
    Nil
fun pidgits(pidgits1) =
  percOp(0)(hashOp(0)(Tuple3(1, 0, 1)))(pidgits1)
fun ampOp(ampOp1)(ampOp2) =
  if ampOp2 is
    Tuple3(ampOp_Tuple3_0, ampOp_Tuple3_1, ampOp_Tuple3_2) then
      let y = ampOp1 * 2 + 1
      Tuple3(ampOp_Tuple3_0 * ampOp1, (ampOp_Tuple3_1 + ampOp_Tuple3_0 * 2) * y, ampOp_Tuple3_2 * y)
fun percOp(percOp1)(percOp2)(percOp3) =
  if percOp1 >= percOp3 then
    Nil
  else
    (let k = percOp1 + 10
    let j = min(percOp3)(k)
    let mi_1 = if k > percOp3 then
      Tuple2(mappend(take_lz(percOp3 % 10)(percOp2))(replicate(k - percOp3)(Cons(char" ", Nil))), lazy(Nil))
    else
      (splitAt_lz(10)(percOp2))
    if mi_1 is
      Tuple2(percOp_Tuple2_0, percOp_Tuple2_1) then
        mappend(mappend(concat(percOp_Tuple2_0))(mappend(Cons(char"t", Cons(char":", Nil)))(mappend(string_of_int(j))(Cons(char"n", Nil)))))(percOp(j)(percOp_Tuple2_1)(percOp3)))
fun divmod(divmod1)(divmod2) =
  Tuple2(div(divmod1)(divmod2), divmod1 % divmod2)
fun splitAt_lz(splitAt_lz1)(splitAt_lz2) =
  Tuple2(take_lz(splitAt_lz1)(splitAt_lz2), drop_lz(splitAt_lz1)(splitAt_lz2))
fun hashOp(hashOp1)(hashOp2) =
  lazy(
    let k = hashOp1 + 1
    let mi_2 = ampOp(k)(hashOp2)
    if mi_2 is
      Tuple3(hashOp_Tuple3_0, hashOp_Tuple3_1, hashOp_Tuple3_2) then
        let mi_3 = divmod(hashOp_Tuple3_0 * 3 + hashOp_Tuple3_1)(hashOp_Tuple3_2)
        if mi_3 is
          Tuple2(hashOp_Tuple2_0, hashOp_Tuple2_1) then
            if hashOp_Tuple3_0 > hashOp_Tuple3_1 || hashOp_Tuple2_1 + hashOp_Tuple3_0 >= hashOp_Tuple3_2 then
              force(hashOp(k)(Tuple3(hashOp_Tuple3_0, hashOp_Tuple3_1, hashOp_Tuple3_2)))
            else
              (Cons(string_of_int(hashOp_Tuple2_0), hashOp(k)(Tuple3(hashOp_Tuple3_0 * 10, (hashOp_Tuple3_1 - hashOp_Tuple2_0 * hashOp_Tuple3_2) * 10, hashOp_Tuple3_2))))
  )
(testPiDigits_nofib(primId(5000)))
