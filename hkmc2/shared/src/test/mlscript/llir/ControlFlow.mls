:js
:llir
:cpp

:global

:sllir
:intl
fun f1() =
  let x = 1
  let x = 2
  x
f1()
//│ = 2
//│ LLIR:
//│   
//│   def f1$198() =
//│     let x$208 = 1 in
//│     let x$209 = 2 in
//│     x$209
//│   let* (x$210) = f1() in
//│   x$210
//│ 
//│ Interpreted:
//│ 2

:sllir
:intl
fun f2() =
  let x = 0
  if x == 1 then 2 else 3
f2()
//│ = 3
//│ LLIR:
//│   
//│   def f2$211() =
//│     let x$222 = 0 in
//│     let x$223 = ==(x$222,1) in
//│     case x$223 of
//│       BoolLit(true) =>
//│         2
//│       _ =>
//│         3
//│   def j$224() =
//│     null
//│   let* (x$225) = f2() in
//│   x$225
//│ 
//│ Interpreted:
//│ 3


:sllir
fun f3() =
  let x1 = 0
  let x2 = 1
  if true then x1 else x2
f3()
//│ = 0
//│ LLIR:
//│   
//│   def f3$226() =
//│     let x$237 = 0 in
//│     let x$238 = 1 in
//│     let x$239 = true in
//│     case x$239 of
//│       BoolLit(true) =>
//│         x$237
//│       _ =>
//│         x$238
//│   def j$240() =
//│     null
//│   let* (x$241) = f3() in
//│   x$241


:sllir
:intl
fun f4() =
  let x = 0
  let x = if x == 1 then 2 else 3
  x
f4()
//│ = 3
//│ LLIR:
//│   
//│   def f4$242() =
//│     let x$256 = 0 in
//│     let x$257 = ==(x$256,1) in
//│     case x$257 of
//│       BoolLit(true) =>
//│         let x$259 = 2 in
//│         jump j$258(x$259)
//│       _ =>
//│         let x$260 = 3 in
//│         jump j$258(x$260)
//│   def j$258(tmp$253) =
//│     tmp$253
//│   let* (x$261) = f4() in
//│   x$261
//│ 
//│ Interpreted:
//│ 3

:sllir
:intl
fun f5() =
  let x = 0
  let x = if x == 1 then 2 else 3
  let x = if x == 2 then 4 else 5
  x
f5()
//│ = 5
//│ LLIR:
//│   
//│   def f5$262() =
//│     let x$281 = 0 in
//│     let x$282 = ==(x$281,1) in
//│     case x$282 of
//│       BoolLit(true) =>
//│         let x$284 = 2 in
//│         jump j$283(x$284)
//│       _ =>
//│         let x$285 = 3 in
//│         jump j$283(x$285)
//│   def j$283(tmp$277) =
//│     let x$286 = ==(tmp$277,2) in
//│     case x$286 of
//│       BoolLit(true) =>
//│         let x$288 = 4 in
//│         jump j$287(x$288)
//│       _ =>
//│         let x$289 = 5 in
//│         jump j$287(x$289)
//│   def j$287(tmp$278) =
//│     tmp$278
//│   let* (x$290) = f5() in
//│   x$290
//│ 
//│ Interpreted:
//│ 5

:sllir
:scpp
fun test() =
  if true do test()
//│ LLIR:
//│   
//│   def test$291() =
//│     let x$300 = true in
//│     case x$300 of
//│       BoolLit(true) =>
//│         let* (x$302) = test() in
//│         x$302
//│       _ =>
//│         undefined
//│   def j$301() =
//│     null
//│   undefined
//│ 
//│ Cpp:
//│ #include "mlsprelude.h"
//│ _mlsValue _mls_j5();
//│ _mlsValue _mls_test();
//│ _mlsValue _mlsMain();
//│ _mlsValue _mls_j5() {
//│   _mlsValue _mls_retval;
//│   _mls_retval = _mlsValue::create<_mls_Unit>();
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_test() {
//│   _mlsValue _mls_retval;
//│   auto _mls_x23 = _mlsValue::fromIntLit(1);
//│   if (_mlsValue::isIntLit(_mls_x23, 1)) {
//│     auto _mls_x24 = _mls_test();
//│     _mls_retval = _mls_x24;
//│   } else {
//│     _mls_retval = _mlsValue::create<_mls_Unit>();
//│   }
//│   return _mls_retval;
//│ }
//│ _mlsValue _mlsMain() {
//│   _mlsValue _mls_retval;
//│   _mls_retval = _mlsValue::create<_mls_Unit>();
//│   return _mls_retval;
//│ }
//│ int main() { return _mlsLargeStack(_mlsMainWrapper); }

:sllir
:scpp
fun test() =
  (if true then test()) + 1
//│ LLIR:
//│   
//│   def test$303() =
//│     let x$315 = true in
//│     case x$315 of
//│       BoolLit(true) =>
//│         let* (x$317) = test() in
//│         jump j$316(x$317)
//│       _ =>
//│         panic "match error"
//│   def j$316(tmp$313) =
//│     let x$318 = +(tmp$313,1) in
//│     x$318
//│   undefined
//│ 
//│ Cpp:
//│ #include "mlsprelude.h"
//│ _mlsValue _mls_j6(_mlsValue);
//│ _mlsValue _mls_test1();
//│ _mlsValue _mlsMain();
//│ _mlsValue _mls_j6(_mlsValue _mls_tmp3) {
//│   _mlsValue _mls_retval;
//│   auto _mls_x25 = (_mls_tmp3 + _mlsValue::fromIntLit(1));
//│   _mls_retval = _mls_x25;
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_test1() {
//│   _mlsValue _mls_retval;
//│   auto _mls_x26 = _mlsValue::fromIntLit(1);
//│   if (_mlsValue::isIntLit(_mls_x26, 1)) {
//│     auto _mls_x27 = _mls_test1();
//│     _mls_retval = _mls_j6(_mls_x27);
//│   } else {
//│     throw std::runtime_error("match error");
//│   }
//│   return _mls_retval;
//│ }
//│ _mlsValue _mlsMain() {
//│   _mlsValue _mls_retval;
//│   _mls_retval = _mlsValue::create<_mls_Unit>();
//│   return _mls_retval;
//│ }
//│ int main() { return _mlsLargeStack(_mlsMainWrapper); }


:sllir
:intl
:scpp
fun f() =
  let x = 10
  if true do
    set x += 1
  x
f()
//│ = 11
//│ LLIR:
//│   
//│   def f$319() =
//│     let x$334 = 10 in
//│     let x$335 = true in
//│     case x$335 of
//│       BoolLit(true) =>
//│         let x$337 = +(x$334,1) in
//│         let x$338 = undefined in
//│         jump j$336(x$337)
//│       _ =>
//│         let x$339 = undefined in
//│         jump j$336(x$334)
//│   def j$336(x$320) =
//│     x$320
//│   let* (x$340) = f() in
//│   x$340
//│ 
//│ Cpp:
//│ #include "mlsprelude.h"
//│ _mlsValue _mls_j7(_mlsValue);
//│ _mlsValue _mls_f();
//│ _mlsValue _mlsMain();
//│ _mlsValue _mls_j7(_mlsValue _mls_x28) {
//│   _mlsValue _mls_retval;
//│   _mls_retval = _mls_x28;
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_f() {
//│   _mlsValue _mls_retval;
//│   auto _mls_x29 = _mlsValue::fromIntLit(10);
//│   auto _mls_x30 = _mlsValue::fromIntLit(1);
//│   if (_mlsValue::isIntLit(_mls_x30, 1)) {
//│     auto _mls_x32 = (_mls_x29 + _mlsValue::fromIntLit(1));
//│     auto _mls_x33 = _mlsValue::create<_mls_Unit>();
//│     _mls_retval = _mls_j7(_mls_x32);
//│   } else {
//│     auto _mls_x31 = _mlsValue::create<_mls_Unit>();
//│     _mls_retval = _mls_j7(_mls_x29);
//│   }
//│   return _mls_retval;
//│ }
//│ _mlsValue _mlsMain() {
//│   _mlsValue _mls_retval;
//│   auto _mls_x34 = _mls_f();
//│   _mls_retval = _mls_x34;
//│   return _mls_retval;
//│ }
//│ int main() { return _mlsLargeStack(_mlsMainWrapper); }
//│ 
//│ Interpreted:
//│ 11

:sllir
:intl
class A(x)
class B(y)
fun f(a) =
  let t = if a is
    A(_) then 1
    B(_) then 2
  t
f(A(1))
//│ = 1
//│ LLIR:
//│   class A(x$346)
//│   class B(y$349)
//│   def f$343(a$350) =
//│     case a$350 of
//│       A$344 =>
//│         let x$371 = a$350.<A$344:x> in
//│         let x$372 = 1 in
//│         jump j$370(x$372)
//│       _ =>
//│         case a$350 of
//│           B$347 =>
//│             let x$374 = a$350.<B$347:y> in
//│             let x$375 = 2 in
//│             jump j$373(x$375)
//│           _ =>
//│             panic "match error"
//│   def j$373(tmp$365) =
//│     jump j$370(tmp$365)
//│   def j$370(tmp$365) =
//│     tmp$365
//│   let x$376 = A$344(1) in
//│   let* (x$377) = f(x$376) in
//│   x$377
//│ 
//│ Interpreted:
//│ 1

:sllir
:intl
class A(x)
class B(y)
fun f(a) =
  let t = if a is
    A(_) then if a is
      A(1) then 1
      B(_) then 2
    B(_) then 3
  t
f(A(1))
//│ = 1
//│ LLIR:
//│   class A(x$383)
//│   class B(y$386)
//│   def f$380(a$387) =
//│     case a$387 of
//│       A$381 =>
//│         let x$412 = a$387.<A$381:x> in
//│         case a$387 of
//│           A$381 =>
//│             let x$414 = a$387.<A$381:x> in
//│             case x$414 of
//│               IntLit(1) =>
//│                 let x$416 = 1 in
//│                 jump j$415(x$416)
//│               _ =>
//│                 panic "match error"
//│           _ =>
//│             case a$387 of
//│               B$384 =>
//│                 let x$418 = a$387.<B$384:y> in
//│                 let x$419 = 2 in
//│                 jump j$417(x$419)
//│               _ =>
//│                 panic "match error"
//│       _ =>
//│         case a$387 of
//│           B$384 =>
//│             let x$421 = a$387.<B$384:y> in
//│             let x$422 = 3 in
//│             jump j$420(x$422)
//│           _ =>
//│             panic "match error"
//│   def j$415(tmp$405) =
//│     jump j$413(tmp$405)
//│   def j$417(tmp$405) =
//│     jump j$413(tmp$405)
//│   def j$413(tmp$405) =
//│     jump j$411(tmp$405)
//│   def j$420(tmp$406) =
//│     jump j$411(tmp$406)
//│   def j$411(tmp$406) =
//│     tmp$406
//│   let x$423 = A$381(1) in
//│   let* (x$424) = f(x$423) in
//│   x$424
//│ 
//│ Interpreted:
//│ 1
