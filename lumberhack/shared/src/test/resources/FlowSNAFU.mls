:NewParser
:ParseOnly


:lhEval
// NOTE: sometimes the output program will be correct without adding Obj.magic
fun f(a, ret) = if a is
  A then b =>
    if b is
      B then ret
  AA then b => End2
f(A, ReturnValue, B)
//│ |#fun| |f|(|a|,| |ret|)| |#=| |#if| |a| |is|→|A| |#then| |b| |=>|→|#if| |b| |is|→|B| |#then| |ret|←|←|↵|AA| |#then| |b| |=>| |End2|←|↵|f|(|A|,| |ReturnValue|,| |B|)|
//│ Parsed: {fun f = a, ret, => if a is ‹(A) then b, => {if b is ‹(B) then ret›}; (AA) then b, => End2›; f (A, ReturnValue, B,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ f^11([A], [ReturnValue], [B])
//│ def f(a⁰, ret⁰) = case a⁰ of {
//│ 	A  => (fun b⁰ -> case b⁰ of {
//│ 		B  => ret⁰})
//│ 	| AA  => (fun b¹ -> [End2])}
//│ <<<<<<<<<< Original <<<<<<<<<<
//│ 
//│ >>>>>>>>>> Original Eval Res >>>>>>>>>>
//│ [ReturnValue]
//│ <<<<<<<<<< Original Eval Res <<<<<<<<<<
//│ 
//│ >>>>>>> fusion matches >>>>>>>
//│ [A]: 12 --->
//│ 	case a⁰ of {A  => (fun b⁰ -> case b⁰ of {B  => ret⁰}) | AA  => (fun b¹ -> [End2])}: 8
//│ [B]: 16 --->
//│ 	DeadCodeCons
//│ 	case b⁰ of {B  => ret⁰}: 4
//│ ------------------
//│ case b⁰ of {B  => ret⁰}: 4 --->
//│ 	[B]: 16
//│ case a⁰ of {A  => (fun b⁰ -> case b⁰ of {B  => ret⁰}) | AA  => (fun b¹ -> [End2])}: 8 --->
//│ 	[A]: 12
//│ <<<<<<< fusion matches <<<<<<<
//│ 
//│ >>>>>>> new fusion strategy >>>>>>>
//│ [A]: 12 --->
//│ 	case a⁰ of {A  => (fun b⁰ -> case b⁰ of {B  => ret⁰}) | AA  => (fun b¹ -> [End2])}: 8
//│ ------------------
//│ case a⁰ of {A  => (fun b⁰ -> case b⁰ of {B  => ret⁰}) | AA  => (fun b¹ -> [End2])}: 8 --->
//│ 	[A]: 12
//│ <<<<<<< new fusion strategy <<<<<<<
//│ 
//│ >>>>>>> after fusion >>>>>>>
//│ f((fun ret¹ -> (fun b² -> case b² of {
//│ 	B  => ret¹})), [ReturnValue], [B])
//│ def f(a¹, ret²) = a¹(ret²)
//│ <<<<<<< after fusion <<<<<<<
//│ 
//│ >>>>>>> evaluate >>>>>>>
//│ [ReturnValue]
//│ <<<<<<< evaluate <<<<<<<
//│ 
//│ >>>>>>> consumer ids >>>>>>>
//│ f
//│ <<<<<<< consumer ids <<<<<<<
//│ 
//│ >>>>>>> floating out info >>>>>>>
//│ 
//│ <<<<<<< floating out info <<<<<<<
//│ 
//│ >>>>>>> after inlining >>>>>>>
//│ (fun ret⁰ -> (fun b⁰ -> case b⁰ of {
//│ 	B  => ret⁰}))([ReturnValue], [B])
//│ def f(a⁰, ret¹) = a⁰(ret¹)
//│ <<<<<<< after inlining <<<<<<<
//│ 
//│ >>>>>>> after floating out >>>>>>>
//│ (fun ret⁰ -> (fun b⁰ -> case b⁰ of {
//│ 	B  => ret⁰}))([ReturnValue], [B])
//│ def f(a⁰, ret¹) = a⁰(ret¹)
//│ <<<<<<< after floating out <<<<<<<

// NOTE: mlscript thinks this is ok, but not ocaml
:lhError
:lhGenOCaml
:d
fun f(a) = if True then C(0) else C(x => x)
f(0)
// // will need to be:
// ignore(f(0))
//│ |#fun| |f|(|a|)| |#=| |#if| |True| |#then| |C|(|0|)| |#else| |C|(|x| |=>| |x|)|↵|f|(|0|)|↵|/* // will need to be:*/|↵|/* ignore(f(0))*/|
//│ Parsed: {fun f = a, => if (True) then C (0,) else C (x, => x,); f (0,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ f^9(0)
//│ def f(a⁰) = if [True] then [C 0] else [C (fun x⁰ -> x⁰)]
//│ 		---------- unoptimized ocaml gen ----------
//│ 		let rec f a_0 =
//│ 		  (if true then
//│ 		    (`C(0))
//│ 		  else
//│ 		    (`C((fun x_0 -> 
//│ 		      x_0))));;
//│ 		(f 0)
//│ 		....... ocaml repl result .......
//│ !!!!!!ERROR!!!!!!
//│ java.io.IOException: Cannot run program "/Users/crescentonc/.opam/benchmarkflambda/bin/ocaml": error=2, No such file or directory
//│ !!!!!!ERROR!!!!!!

// fun f(a) = if True then C(0) else Object.magic(C(x => x))
// f(0)



// TODO: investigate why the expander doesn't dup dropWhile, which causes its outer layer not to fuse
// reproduced as below
// ```
// fun c(x) = if x is
//   C(a) then c(a)
//   N then N
// c(C(C(C(N))))
// ```
// the fusion process if the `NoCons` does not block the fusion
// and the dropWhile gets duplicated as needed
// fun dropWhile(ls) = (if ls is
//   N then () => C(N)
//   C(t) then () => if True then dropWhile(t) else C(t))()
// dropWhile(C(N))
// -----------
// dropWhile'(ls) = ls ()
// dropWhile'(
//   let t = N
//   in () => if True then dropWhile(t) else C(t)
// )
// -----------
// dropWhile''(ls) = ls()
// dropWhile'(ls) = ls()
// dropWhile'(
//   let t = () => C(N)
//   in () => if True then dropWhile''(t) else C(t)
// )
:lhGenOCaml
:d
fun dropWhile(ls) = if ls is
  N then C(N)
  C(t) then if True then dropWhile(t) else C(t)
dropWhile(C(N))
//│ |#fun| |dropWhile|(|ls|)| |#=| |#if| |ls| |is|→|N| |#then| |C|(|N|)|↵|C|(|t|)| |#then| |#if| |True| |#then| |dropWhile|(|t|)| |#else| |C|(|t|)|←|↵|dropWhile|(|C|(|N|)|)|
//│ Parsed: {fun dropWhile = ls, => if ls is ‹(N) then C (N,); (C (t,)) then if (True) then dropWhile (t,) else C (t,)›; dropWhile (C (N,),)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ dropWhile^13([C [N]])
//│ def dropWhile(ls⁰) = case ls⁰ of {
//│ 	N  => [C [N]]
//│ 	| C t⁰ => if [True] then dropWhile^5(t⁰) else [C t⁰]}
//│ 		---------- unoptimized ocaml gen ----------
//│ 		let rec dropWhile ls_0 =
//│ 		  (match ls_0 with
//│ 		    | `N -> 
//│ 		      (`C((`N)))
//│ 		    | `C(t_0) -> 
//│ 		      (if true then
//│ 		        (dropWhile t_0)
//│ 		      else
//│ 		        (`C(t_0))));;
//│ 		(dropWhile (`C((`N))))
//│ 		....... ocaml repl result .......
//│ /!!!\ Uncaught error: java.io.IOException: Cannot run program "/Users/crescentonc/.opam/benchmarkflambda/bin/ocaml": error=2, No such file or directory


:lhGenOCaml
:d
fun dropWhile(ls) = if ls is
  N then C(N)
  C(t) then if True then dropWhile(t) else C(t)
(x => 2)(dropWhile(C(N)))
//│ |#fun| |dropWhile|(|ls|)| |#=| |#if| |ls| |is|→|N| |#then| |C|(|N|)|↵|C|(|t|)| |#then| |#if| |True| |#then| |dropWhile|(|t|)| |#else| |C|(|t|)|←|↵|(|x| |=>| |2|)|(|dropWhile|(|C|(|N|)|)|)|
//│ Parsed: {fun dropWhile = ls, => if ls is ‹(N) then C (N,); (C (t,)) then if (True) then dropWhile (t,) else C (t,)›; '(' x, => 2, ')' (dropWhile (C (N,),),)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ (fun x⁰ -> 2)(dropWhile^15([C [N]]))
//│ def dropWhile(ls⁰) = case ls⁰ of {
//│ 	N  => [C [N]]
//│ 	| C t⁰ => if [True] then dropWhile^5(t⁰) else [C t⁰]}
//│ 		---------- unoptimized ocaml gen ----------
//│ 		let rec dropWhile ls_0 =
//│ 		  (match ls_0 with
//│ 		    | `N -> 
//│ 		      (`C((`N)))
//│ 		    | `C(t_0) -> 
//│ 		      (if true then
//│ 		        (dropWhile t_0)
//│ 		      else
//│ 		        (`C(t_0))));;
//│ 		((fun x_0 -> 
//│ 		  2) (dropWhile (`C((`N)))))
//│ 		....... ocaml repl result .......
//│ /!!!\ Uncaught error: java.io.IOException: Cannot run program "/Users/crescentonc/.opam/benchmarkflambda/bin/ocaml": error=2, No such file or directory
//│ 	at: java.base/java.lang.ProcessBuilder.start(ProcessBuilder.java:1128)
//│ 	at: java.base/java.lang.ProcessBuilder.start(ProcessBuilder.java:1071)
//│ 	at: mlscript.lumberhack.OCamlReplHost.<init>(DiffTestLumberhack.scala:580)
//│ 	at: mlscript.lumberhack.DiffTestLumberhack.postProcess(DiffTestLumberhack.scala:106)
//│ 	at: mlscript.DiffTests.rec$1(DiffTests.scala:396)
//│ 	at: mlscript.DiffTests.$anonfun$new$3(DiffTests.scala:803)
//│ 	at: org.scalatest.OutcomeOf.outcomeOf(OutcomeOf.scala:85)
//│ 	at: org.scalatest.OutcomeOf.outcomeOf$(OutcomeOf.scala:83)
//│ 	at: org.scalatest.OutcomeOf$.outcomeOf(OutcomeOf.scala:104)
//│ 	at: org.scalatest.Transformer.apply(Transformer.scala:22)

:lhGenOCaml
:d
fun dropWhile(ls) = if ls is
  N then N
  C(t) then if True then dropWhile(t) else C(t)
fun f(x) = Pair(f(C(N)), f(x))
f(dropWhile(C(N)))
//│ |#fun| |dropWhile|(|ls|)| |#=| |#if| |ls| |is|→|N| |#then| |N|↵|C|(|t|)| |#then| |#if| |True| |#then| |dropWhile|(|t|)| |#else| |C|(|t|)|←|↵|#fun| |f|(|x|)| |#=| |Pair|(|f|(|C|(|N|)|)|,| |f|(|x|)|)|↵|f|(|dropWhile|(|C|(|N|)|)|)|
//│ Parsed: {fun dropWhile = ls, => if ls is ‹(N) then N; (C (t,)) then if (True) then dropWhile (t,) else C (t,)›; fun f = x, => Pair (f (C (N,),), f (x,),); f (dropWhile (C (N,),),)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ f^21(dropWhile^22([C [N]]))
//│ def dropWhile(ls⁰) = case ls⁰ of {
//│ 	N  => [N]
//│ 	| C t⁰ => if [True] then dropWhile^4(t⁰) else [C t⁰]}
//│ def f(x⁰) = [Pair f^12([C [N]]) f^16(x⁰)]
//│ 		---------- unoptimized ocaml gen ----------
//│ 		let rec f x_0 =
//│ 		  (`Pair((f (`C((`N)))), (f x_0)));;
//│ 		let rec dropWhile ls_0 =
//│ 		  (match ls_0 with
//│ 		    | `N -> 
//│ 		      (`N)
//│ 		    | `C(t_0) -> 
//│ 		      (if true then
//│ 		        (dropWhile t_0)
//│ 		      else
//│ 		        (`C(t_0))));;
//│ 		(f (dropWhile (`C((`N)))))
//│ 		....... ocaml repl result .......
//│ /!!!\ Uncaught error: java.io.IOException: Cannot run program "/Users/crescentonc/.opam/benchmarkflambda/bin/ocaml": error=2, No such file or directory
//│ 	at: java.base/java.lang.ProcessBuilder.start(ProcessBuilder.java:1128)
//│ 	at: java.base/java.lang.ProcessBuilder.start(ProcessBuilder.java:1071)
//│ 	at: mlscript.lumberhack.OCamlReplHost.<init>(DiffTestLumberhack.scala:580)
//│ 	at: mlscript.lumberhack.DiffTestLumberhack.postProcess(DiffTestLumberhack.scala:106)
//│ 	at: mlscript.DiffTests.rec$1(DiffTests.scala:396)
//│ 	at: mlscript.DiffTests.$anonfun$new$3(DiffTests.scala:803)
//│ 	at: org.scalatest.OutcomeOf.outcomeOf(OutcomeOf.scala:85)
//│ 	at: org.scalatest.OutcomeOf.outcomeOf$(OutcomeOf.scala:83)
//│ 	at: org.scalatest.OutcomeOf$.outcomeOf(OutcomeOf.scala:104)
//│ 	at: org.scalatest.Transformer.apply(Transformer.scala:22)


:lhGenOCaml
:d
fun dropWhile(ls) = if ls is
  N then N
  C(t) then if True then dropWhile(t) else C(t)
fun f(x) =
  let x = f(C(N))
  if x is
    C(a) then N
    N then f(x)
f(dropWhile(C(N)))
//│ |#fun| |dropWhile|(|ls|)| |#=| |#if| |ls| |is|→|N| |#then| |N|↵|C|(|t|)| |#then| |#if| |True| |#then| |dropWhile|(|t|)| |#else| |C|(|t|)|←|↵|#fun| |f|(|x|)| |#=|→|#let| |x| |#=| |f|(|C|(|N|)|)|↵|#if| |x| |is|→|C|(|a|)| |#then| |N|↵|N| |#then| |f|(|x|)|←|←|↵|f|(|dropWhile|(|C|(|N|)|)|)|
//│ Parsed: {fun dropWhile = ls, => if ls is ‹(N) then N; (C (t,)) then if (True) then dropWhile (t,) else C (t,)›; fun f = x, => {let x = f (C (N,),); if x is ‹(C (a,)) then N; (N) then f (x,)›}; f (dropWhile (C (N,),),)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ f^24(dropWhile^25([C [N]]))
//│ def dropWhile(ls⁰) = case ls⁰ of {
//│ 	N  => [N]
//│ 	| C t⁰ => if [True] then dropWhile^4(t⁰) else [C t⁰]}
//│ def f(x⁰) = 
//│ 	let x¹ = f^12([C [N]])
//│ 	in case x¹ of {
//│ 		C a⁰ => [N]
//│ 		| N  => f^18(x¹)}
//│ 		---------- unoptimized ocaml gen ----------
//│ 		let rec f x_0 =
//│ 		  (let rec x_1 = (f (`C((`N)))) in
//│ 		    (match x_1 with
//│ 		      | `C(a_0) -> 
//│ 		        (`N)
//│ 		      | `N -> 
//│ 		        (f x_1)));;
//│ 		let rec dropWhile ls_0 =
//│ 		  (match ls_0 with
//│ 		    | `N -> 
//│ 		      (`N)
//│ 		    | `C(t_0) -> 
//│ 		      (if true then
//│ 		        (dropWhile t_0)
//│ 		      else
//│ 		        (`C(t_0))));;
//│ 		(f (dropWhile (`C((`N)))))
//│ 		....... ocaml repl result .......
//│ /!!!\ Uncaught error: java.io.IOException: Cannot run program "/Users/crescentonc/.opam/benchmarkflambda/bin/ocaml": error=2, No such file or directory
//│ 	at: java.base/java.lang.ProcessBuilder.start(ProcessBuilder.java:1128)
//│ 	at: java.base/java.lang.ProcessBuilder.start(ProcessBuilder.java:1071)
//│ 	at: mlscript.lumberhack.OCamlReplHost.<init>(DiffTestLumberhack.scala:580)
//│ 	at: mlscript.lumberhack.DiffTestLumberhack.postProcess(DiffTestLumberhack.scala:106)
//│ 	at: mlscript.DiffTests.rec$1(DiffTests.scala:396)
//│ 	at: mlscript.DiffTests.$anonfun$new$3(DiffTests.scala:803)
//│ 	at: org.scalatest.OutcomeOf.outcomeOf(OutcomeOf.scala:85)
//│ 	at: org.scalatest.OutcomeOf.outcomeOf$(OutcomeOf.scala:83)
//│ 	at: org.scalatest.OutcomeOf$.outcomeOf(OutcomeOf.scala:104)
//│ 	at: org.scalatest.Transformer.apply(Transformer.scala:22)


:lhGenOCaml
:lhNoIter
:d
fun break(ls) = if ls is
  N then
    let fst = N
    let snd = N
    C(fst, words1(snd))
  C(h,t) then
    let fst = N
    let snd = C(h,t)
    C(fst, words1(snd))
fun dropWhile(p, ls) = if ls is
  N then N
  C(h,t) then if p(h) then dropWhile(p, t) else C(h,t)
fun words0(ls) =
  let mident = dropWhile(x => False, ls)
  if mident is
    N then N
    _ then break(mident)
fun words1(ls) =
  let mident = dropWhile(x => False, ls)
  if mident is
    N then N
    _ then break(mident)
(x => 2)(words0)
//│ |#fun| |break|(|ls|)| |#=| |#if| |ls| |is|→|N| |#then|→|#let| |fst| |#=| |N|↵|#let| |snd| |#=| |N|↵|C|(|fst|,| |words1|(|snd|)|)|←|↵|C|(|h|,|t|)| |#then|→|#let| |fst| |#=| |N|↵|#let| |snd| |#=| |C|(|h|,|t|)|↵|C|(|fst|,| |words1|(|snd|)|)|←|←|↵|#fun| |dropWhile|(|p|,| |ls|)| |#=| |#if| |ls| |is|→|N| |#then| |N|↵|C|(|h|,|t|)| |#then| |#if| |p|(|h|)| |#then| |dropWhile|(|p|,| |t|)| |#else| |C|(|h|,|t|)|←|↵|#fun| |words0|(|ls|)| |#=|→|#let| |mident| |#=| |dropWhile|(|x| |=>| |False|,| |ls|)|↵|#if| |mident| |is|→|N| |#then| |N|↵|_| |#then| |break|(|mident|)|←|←|↵|#fun| |words1|(|ls|)| |#=|→|#let| |mident| |#=| |dropWhile|(|x| |=>| |False|,| |ls|)|↵|#if| |mident| |is|→|N| |#then| |N|↵|_| |#then| |break|(|mident|)|←|←|↵|(|x| |=>| |2|)|(|words0|)|
//│ Parsed: {fun break = ls, => if ls is ‹(N) then {let fst = N; let snd = N; C (fst, words1 (snd,),)}; (C (h, t,)) then {let fst = N; let snd = C (h, t,); C (fst, words1 (snd,),)}›; fun dropWhile = p, ls, => if ls is ‹(N) then N; (C (h, t,)) then if (p (h,)) then dropWhile (p, t,) else C (h, t,)›; fun words0 = ls, => {let mident = dropWhile (x, => False, ls,); if mident is ‹(N) then N; (_) then break (mident,)›}; fun words1 = ls, => {let mident = dropWhile (x, => False, ls,); if mident is ‹(N) then N; (_) then break (mident,)›}; '(' x, => 2, ')' (words0,)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ (fun x² -> 2)(words0^71)
//│ def break(ls⁰) = case ls⁰ of {
//│ 	N  => 
//│ 		let fst⁰ = [N]
//│ 		in let snd⁰ = [N]
//│ 		in [C fst⁰ words1^5(snd⁰)]
//│ 	| C h⁰ t⁰ => 
//│ 		let fst¹ = [N]
//│ 		in let snd¹ = [C h⁰ t⁰]
//│ 		in [C fst¹ words1^16(snd¹)]}
//│ def dropWhile(p⁰, ls¹) = case ls¹ of {
//│ 	N  => [N]
//│ 	| C h¹ t¹ => if p⁰(h¹) then dropWhile^29(p⁰, t¹) else [C h¹ t¹]}
//│ def words0(ls²) = 
//│ 	let mident⁰ = dropWhile^41((fun x⁰ -> [False]), ls²)
//│ 	in case mident⁰ of {
//│ 		N  => [N]
//│ 		| _  => break^49(mident⁰)}
//│ def words1(ls³) = 
//│ 	let mident¹ = dropWhile^55((fun x¹ -> [False]), ls³)
//│ 	in case mident¹ of {
//│ 		N  => [N]
//│ 		| _  => break^63(mident¹)}
//│ 		---------- unoptimized ocaml gen ----------
//│ 		let rec dropWhile p_0 ls_1 =
//│ 		  (match ls_1 with
//│ 		    | `N -> 
//│ 		      (`N)
//│ 		    | `C(h_1, t_1) -> 
//│ 		      (if (p_0 h_1) then
//│ 		        ((dropWhile p_0) t_1)
//│ 		      else
//│ 		        (`C(h_1, t_1))));;
//│ 		let rec break ls_0 =
//│ 		  (match ls_0 with
//│ 		    | `N -> 
//│ 		      (let rec fst_0 = (`N) in
//│ 		        (let rec snd_0 = (`N) in
//│ 		          (`C(fst_0, (words1 snd_0)))))
//│ 		    | `C(h_0, t_0) -> 
//│ 		      (let rec fst_1 = (`N) in
//│ 		        (let rec snd_1 = (`C(h_0, t_0)) in
//│ 		          (`C(fst_1, (words1 snd_1))))))
//│ 		and
//│ 		words1 ls_3 =
//│ 		  (let rec mident_1 = ((dropWhile (fun x_1 -> 
//│ 		    false)) ls_3) in
//│ 		    (match mident_1 with
//│ 		      | `N -> 
//│ 		        (`N)
//│ 		      | _ -> 
//│ 		        (break mident_1)));;
//│ 		let rec words0 ls_2 =
//│ 		  (let rec mident_0 = ((dropWhile (fun x_0 -> 
//│ 		    false)) ls_2) in
//│ 		    (match mident_0 with
//│ 		      | `N -> 
//│ 		        (`N)
//│ 		      | _ -> 
//│ 		        (break mident_0)));;
//│ 		((fun x_2 -> 
//│ 		  2) words0)
//│ 		....... ocaml repl result .......
//│ /!!!\ Uncaught error: java.io.IOException: Cannot run program "/Users/crescentonc/.opam/benchmarkflambda/bin/ocaml": error=2, No such file or directory
//│ 	at: java.base/java.lang.ProcessBuilder.start(ProcessBuilder.java:1128)
//│ 	at: java.base/java.lang.ProcessBuilder.start(ProcessBuilder.java:1071)
//│ 	at: mlscript.lumberhack.OCamlReplHost.<init>(DiffTestLumberhack.scala:580)
//│ 	at: mlscript.lumberhack.DiffTestLumberhack.postProcess(DiffTestLumberhack.scala:106)
//│ 	at: mlscript.DiffTests.rec$1(DiffTests.scala:396)
//│ 	at: mlscript.DiffTests.$anonfun$new$3(DiffTests.scala:803)
//│ 	at: org.scalatest.OutcomeOf.outcomeOf(OutcomeOf.scala:85)
//│ 	at: org.scalatest.OutcomeOf.outcomeOf$(OutcomeOf.scala:83)
//│ 	at: org.scalatest.OutcomeOf$.outcomeOf(OutcomeOf.scala:104)
//│ 	at: org.scalatest.Transformer.apply(Transformer.scala:22)


:lhGenOCaml
:lhNoIter
:d
fun f(x) = if x is
  C(t) then if True then f(t) else x // NOTE: or `else x`, but two branches must exist
fun break(x) = break(f(C(x)))
(x => 2)(x => break(f(x)))
//│ |#fun| |f|(|x|)| |#=| |#if| |x| |is|→|C|(|t|)| |#then| |#if| |True| |#then| |f|(|t|)| |#else| |x| |/* NOTE: or `else x`, but two branches must exist*/|←|↵|#fun| |break|(|x|)| |#=| |break|(|f|(|C|(|x|)|)|)|↵|(|x| |=>| |2|)|(|x| |=>| |break|(|f|(|x|)|)|)|
//│ Parsed: {fun f = x, => if x is ‹(C (t,)) then if (True) then f (t,) else x›; fun break = x, => break (f (C (x,),),); '(' x, => 2, ')' (x, => break (f (x,),),)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ (fun x² -> 2)((fun x³ -> break^19(f^20(x³))))
//│ def break(x¹) = break^10(f^11([C x¹]))
//│ def f(x⁰) = case x⁰ of {
//│ 	C t⁰ => if [True] then f^3(t⁰) else x⁰}
//│ 		---------- unoptimized ocaml gen ----------
//│ 		let rec f x_0 =
//│ 		  (match x_0 with
//│ 		    | `C(t_0) -> 
//│ 		      (if true then
//│ 		        (f t_0)
//│ 		      else
//│ 		        x_0));;
//│ 		let rec break x_1 =
//│ 		  (break (f (`C(x_1))));;
//│ 		((fun x_2 -> 
//│ 		  2) (fun x_3 -> 
//│ 		  (break (f x_3))))
//│ 		....... ocaml repl result .......
//│ /!!!\ Uncaught error: java.io.IOException: Cannot run program "/Users/crescentonc/.opam/benchmarkflambda/bin/ocaml": error=2, No such file or directory
//│ 	at: java.base/java.lang.ProcessBuilder.start(ProcessBuilder.java:1128)
//│ 	at: java.base/java.lang.ProcessBuilder.start(ProcessBuilder.java:1071)
//│ 	at: mlscript.lumberhack.OCamlReplHost.<init>(DiffTestLumberhack.scala:580)
//│ 	at: mlscript.lumberhack.DiffTestLumberhack.postProcess(DiffTestLumberhack.scala:106)
//│ 	at: mlscript.DiffTests.rec$1(DiffTests.scala:396)
//│ 	at: mlscript.DiffTests.$anonfun$new$3(DiffTests.scala:803)
//│ 	at: org.scalatest.OutcomeOf.outcomeOf(OutcomeOf.scala:85)
//│ 	at: org.scalatest.OutcomeOf.outcomeOf$(OutcomeOf.scala:83)
//│ 	at: org.scalatest.OutcomeOf$.outcomeOf(OutcomeOf.scala:104)
//│ 	at: org.scalatest.Transformer.apply(Transformer.scala:22)

// prodType recurses in a way that will return a type of `[C of 'a] as 'a`
// two uses of the consumer `f`:
// for one branch the input is not constraint with any prodStrat, so it is ignored with no clash;
// for the other branch the input is `g(t)` which produces a `C(t)`, and it will be fused
// and our type system does not catch this?
:lhGenOCaml
:d
fun prodType(x) = if x is
  C(t) then if True then t else prodType(t)
fun f(x) = if x is
  C(t) then if True then f(t) else f(g(t))
fun g(t) = C(t)
(x => 2)(x => f(prodType(x)))
//│ |#fun| |prodType|(|x|)| |#=| |#if| |x| |is|→|C|(|t|)| |#then| |#if| |True| |#then| |t| |#else| |prodType|(|t|)|←|↵|#fun| |f|(|x|)| |#=| |#if| |x| |is|→|C|(|t|)| |#then| |#if| |True| |#then| |f|(|t|)| |#else| |f|(|g|(|t|)|)|←|↵|#fun| |g|(|t|)| |#=| |C|(|t|)|↵|(|x| |=>| |2|)|(|x| |=>| |f|(|prodType|(|x|)|)|)|
//│ Parsed: {fun prodType = x, => if x is ‹(C (t,)) then if (True) then t else prodType (t,)›; fun f = x, => if x is ‹(C (t,)) then if (True) then f (t,) else f (g (t,),)›; fun g = t, => C (t,); '(' x, => 2, ')' (x, => f (prodType (x,),),)}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ (fun x² -> 2)((fun x³ -> f^28(prodType^29(x³))))
//│ def f(x¹) = case x¹ of {
//│ 	C t¹ => if [True] then f^12(t¹) else f^15(g^16(t¹))}
//│ def g(t²) = [C t²]
//│ def prodType(x⁰) = case x⁰ of {
//│ 	C t⁰ => if [True] then t⁰ else prodType^4(t⁰)}
//│ 		---------- unoptimized ocaml gen ----------
//│ 		let rec g t_2 =
//│ 		  (`C(t_2));;
//│ 		let rec f x_1 =
//│ 		  (match x_1 with
//│ 		    | `C(t_1) -> 
//│ 		      (if true then
//│ 		        (f t_1)
//│ 		      else
//│ 		        (f (g t_1))));;
//│ 		let rec prodType x_0 =
//│ 		  (match x_0 with
//│ 		    | `C(t_0) -> 
//│ 		      (if true then
//│ 		        t_0
//│ 		      else
//│ 		        (prodType t_0)));;
//│ 		((fun x_2 -> 
//│ 		  2) (fun x_3 -> 
//│ 		  (f (prodType x_3))))
//│ 		....... ocaml repl result .......
//│ /!!!\ Uncaught error: java.io.IOException: Cannot run program "/Users/crescentonc/.opam/benchmarkflambda/bin/ocaml": error=2, No such file or directory
//│ 	at: java.base/java.lang.ProcessBuilder.start(ProcessBuilder.java:1128)
//│ 	at: java.base/java.lang.ProcessBuilder.start(ProcessBuilder.java:1071)
//│ 	at: mlscript.lumberhack.OCamlReplHost.<init>(DiffTestLumberhack.scala:580)
//│ 	at: mlscript.lumberhack.DiffTestLumberhack.postProcess(DiffTestLumberhack.scala:106)
//│ 	at: mlscript.DiffTests.rec$1(DiffTests.scala:396)
//│ 	at: mlscript.DiffTests.$anonfun$new$3(DiffTests.scala:803)
//│ 	at: org.scalatest.OutcomeOf.outcomeOf(OutcomeOf.scala:85)
//│ 	at: org.scalatest.OutcomeOf.outcomeOf$(OutcomeOf.scala:83)
//│ 	at: org.scalatest.OutcomeOf$.outcomeOf(OutcomeOf.scala:104)
//│ 	at: org.scalatest.Transformer.apply(Transformer.scala:22)


:lhGenOCaml
:d
:lhLessExpansion
fun break(ls) = if ls is
  N then P(N, N)
  C(h, t) then if h == 1 then P(N, C(h, t)) else if (break(t)) is
    P(fst, snd) then P(C(h, fst), snd)
fun line(ls) = if break(ls) is
  P(fst, snd) then
    C(
      fst,
      if snd is
        C(h, t) then line(t)
        N then N
    )
fun head(ls) = if ls is
  C(h, t) then h
  N then error
(head(line(primId(C(2,C(2,C(1,C(2,N))))))))
//│ |#fun| |break|(|ls|)| |#=| |#if| |ls| |is|→|N| |#then| |P|(|N|,| |N|)|↵|C|(|h|,| |t|)| |#then| |#if| |h| |==| |1| |#then| |P|(|N|,| |C|(|h|,| |t|)|)| |#else| |#if| |(|break|(|t|)|)| |is|→|P|(|fst|,| |snd|)| |#then| |P|(|C|(|h|,| |fst|)|,| |snd|)|←|←|↵|#fun| |line|(|ls|)| |#=| |#if| |break|(|ls|)| |is|→|P|(|fst|,| |snd|)| |#then|→|C|(|→|fst|,|↵|#if| |snd| |is|→|C|(|h|,| |t|)| |#then| |line|(|t|)|↵|N| |#then| |N|←|←|↵|)|←|←|↵|#fun| |head|(|ls|)| |#=| |#if| |ls| |is|→|C|(|h|,| |t|)| |#then| |h|↵|N| |#then| |error|←|↵|(|head|(|line|(|primId|(|C|(|2|,|C|(|2|,|C|(|1|,|C|(|2|,|N|)|)|)|)|)|)|)|)|
//│ Parsed: {fun break = ls, => if ls is ‹(N) then P (N, N,); (C (h, t,)) then if (== (h,) (1,)) then P (N, C (h, t,),) else if '(' break (t,), ')' is ‹(P (fst, snd,)) then P (C (h, fst,), snd,)››; fun line = ls, => if break (ls,) is ‹(P (fst, snd,)) then {C (fst, if snd is ‹(C (h, t,)) then line (t,); (N) then N›,)}›; fun head = ls, => if ls is ‹(C (h, t,)) then h; (N) then error›; '(' head (line (primId (C (2, C (2, C (1, C (2, N,),),),),),),), ')'}
//│ >>>>>>>>>> Original >>>>>>>>>>
//│ head^45(line^46(primId⁰([C 2 [C 2 [C 1 [C 2 [N]]]]])))
//│ def break(ls⁰) = case ls⁰ of {
//│ 	N  => [P [N] [N]]
//│ 	| C h⁰ t⁰ => if (h⁰ == 1) then [P [N] [C h⁰ t⁰]] else case break^15(t⁰) of {
//│ 		P fst⁰ snd⁰ => [P [C h⁰ fst⁰] snd⁰]}}
//│ def head(ls²) = case ls² of {
//│ 	C h² t² => h²
//│ 	| N  => error⁰}
//│ def line(ls¹) = case break^27(ls¹) of {
//│ 	P fst¹ snd¹ => [C fst¹ case snd¹ of {
//│ 		C h¹ t¹ => line^32(t¹)
//│ 		| N  => [N]}]}
//│ 		---------- unoptimized ocaml gen ----------
//│ 		let rec break ls_0 =
//│ 		  (match ls_0 with
//│ 		    | `N -> 
//│ 		      (`P((`N), (`N)))
//│ 		    | `C(h_0, t_0) -> 
//│ 		      (if (h_0 = 1) then
//│ 		        (`P((`N), (`C(h_0, t_0))))
//│ 		      else
//│ 		        (match (break t_0) with
//│ 		          | `P(fst_0, snd_0) -> 
//│ 		            (`P((`C(h_0, fst_0)), snd_0)))));;
//│ 		let rec line ls_1 =
//│ 		  (match (break ls_1) with
//│ 		    | `P(fst_1, snd_1) -> 
//│ 		      (`C(fst_1, (match snd_1 with
//│ 		        | `C(h_1, t_1) -> 
//│ 		          (line t_1)
//│ 		        | `N -> 
//│ 		          (`N)))));;
//│ 		let rec head ls_2 =
//│ 		  (match ls_2 with
//│ 		    | `C(h_2, t_2) -> 
//│ 		      h_2
//│ 		    | `N -> 
//│ 		      (failwith "error"));;
//│ 		(head (line (`C(2, (`C(2, (`C(1, (`C(2, (`N)))))))))))
//│ 		....... ocaml repl result .......
//│ /!!!\ Uncaught error: java.io.IOException: Cannot run program "/Users/crescentonc/.opam/benchmarkflambda/bin/ocaml": error=2, No such file or directory
//│ 	at: java.base/java.lang.ProcessBuilder.start(ProcessBuilder.java:1128)
//│ 	at: java.base/java.lang.ProcessBuilder.start(ProcessBuilder.java:1071)
//│ 	at: mlscript.lumberhack.OCamlReplHost.<init>(DiffTestLumberhack.scala:580)
//│ 	at: mlscript.lumberhack.DiffTestLumberhack.postProcess(DiffTestLumberhack.scala:106)
//│ 	at: mlscript.DiffTests.rec$1(DiffTests.scala:396)
//│ 	at: mlscript.DiffTests.$anonfun$new$3(DiffTests.scala:803)
//│ 	at: org.scalatest.OutcomeOf.outcomeOf(OutcomeOf.scala:85)
//│ 	at: org.scalatest.OutcomeOf.outcomeOf$(OutcomeOf.scala:83)
//│ 	at: org.scalatest.OutcomeOf$.outcomeOf(OutcomeOf.scala:104)
//│ 	at: org.scalatest.Transformer.apply(Transformer.scala:22)
