:js
:llir
:cpp

:global

:sllir
:intl
:scpp
fun add(x) = y => x + y
fun add_curried(x)(y) = x + y
add(1)(2)
//│ = 3
//│ LLIR:
//│   class Lambda(lam_arg0$241) extends Callable {
//│     def apply1$242(y$222) =
//│       let x$243 = +(lam_arg0$241,y$222) in
//│       x$243
//│   }
//│   class Lambda(lam_arg0$248) extends Callable {
//│     def apply1$242(y$226) =
//│       let x$249 = +(lam_arg0$248,y$226) in
//│       x$249
//│   }
//│   def add$219(x$221) =
//│     let x$245 = Lambda$239(x$221) in
//│     x$245
//│   def add_curried$220(x$225) =
//│     let x$250 = Lambda$246(x$225) in
//│     x$250
//│   def entry$253() =
//│     let* (x$251) = add(1) in
//│     let x$252 = Callable.apply1$242(x$251,2) in
//│     x$252
//│   entry = entry$253
//│ 
//│ Cpp:
//│ #include "mlsprelude.h"
//│ struct _mls_Lambda;
//│ struct _mls_Lambda1;
//│ _mlsValue _mls_add(_mlsValue);
//│ _mlsValue _mls_add_curried(_mlsValue);
//│ _mlsValue _mls_entry1();
//│ struct _mls_Lambda: public _mls_Callable {
//│   _mlsValue _mls_lam_arg0;
//│   constexpr static inline const char *typeName = "Lambda";
//│   constexpr static inline uint32_t typeTag = nextTypeTag();
//│   virtual void print() const override { std::printf("%s", typeName); std::printf("("); this->_mls_lam_arg0.print();  std::printf(")"); }
//│   virtual void destroy() override { _mlsValue::destroy(this->_mls_lam_arg0);  operator delete (this, std::align_val_t(_mlsAlignment)); }
//│   static _mlsValue create(_mlsValue _mls_lam_arg0) { auto _mlsVal = new (std::align_val_t(_mlsAlignment)) _mls_Lambda; _mlsVal->refCount = 1; _mlsVal->tag = typeTag; _mlsVal->_mls_lam_arg0 = _mls_lam_arg0;  return _mlsValue(_mlsVal); }
//│   virtual _mlsValue _mls_apply1(_mlsValue);
//│ };
//│ struct _mls_Lambda1: public _mls_Callable {
//│   _mlsValue _mls_lam_arg0;
//│   constexpr static inline const char *typeName = "Lambda";
//│   constexpr static inline uint32_t typeTag = nextTypeTag();
//│   virtual void print() const override { std::printf("%s", typeName); std::printf("("); this->_mls_lam_arg0.print();  std::printf(")"); }
//│   virtual void destroy() override { _mlsValue::destroy(this->_mls_lam_arg0);  operator delete (this, std::align_val_t(_mlsAlignment)); }
//│   static _mlsValue create(_mlsValue _mls_lam_arg0) { auto _mlsVal = new (std::align_val_t(_mlsAlignment)) _mls_Lambda1; _mlsVal->refCount = 1; _mlsVal->tag = typeTag; _mlsVal->_mls_lam_arg0 = _mls_lam_arg0;  return _mlsValue(_mlsVal); }
//│   virtual _mlsValue _mls_apply1(_mlsValue);
//│ };
//│ _mlsValue _mls_add(_mlsValue _mls_x3) {
//│   _mlsValue _mls_retval;
//│   auto _mls_x2 = _mlsValue::create<_mls_Lambda>(_mls_x3);
//│   _mls_retval = _mls_x2;
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_add_curried(_mlsValue _mls_x5) {
//│   _mlsValue _mls_retval;
//│   auto _mls_x4 = _mlsValue::create<_mls_Lambda1>(_mls_x5);
//│   _mls_retval = _mls_x4;
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_entry1() {
//│   _mlsValue _mls_retval;
//│   auto _mls_x6 = _mls_add(_mlsValue::fromIntLit(1));
//│   auto _mls_x7 = _mlsMethodCall<_mls_Callable>(_mls_x6)->_mls_apply1(_mlsValue::fromIntLit(2));
//│   _mls_retval = _mls_x7;
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_Lambda::_mls_apply1(_mlsValue _mls_y) {
//│   _mlsValue _mls_retval;
//│   auto _mls_x = (_mls_lam_arg0 + _mls_y);
//│   _mls_retval = _mls_x;
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_Lambda1::_mls_apply1(_mlsValue _mls_y1) {
//│   _mlsValue _mls_retval;
//│   auto _mls_x1 = (_mls_lam_arg0 + _mls_y1);
//│   _mls_retval = _mls_x1;
//│   return _mls_retval;
//│ }
//│ _mlsValue _mlsMain() { return _mls_entry1(); }
//│ int main() { return _mlsLargeStack(_mlsMainWrapper); }
//│ 
//│ Interpreted:
//│ 3

:sllir
:intl
:scpp
fun add4(a, b) = (c, d) => a + b + c + d
fun add4_curried(a, b)(c, d) = a + b + c + d
add4(1, 2)(3, 4)
//│ = 10
//│ LLIR:
//│   class Lambda(lam_arg0$292,lam_arg1$293) extends Callable {
//│     def apply2$294(c$258,d$259) =
//│       let x$295 = +(lam_arg1$293,lam_arg0$292) in
//│       let x$296 = +(x$295,c$258) in
//│       let x$297 = +(x$296,d$259) in
//│       x$297
//│   }
//│   class Lambda(lam_arg0$301,lam_arg1$302) extends Callable {
//│     def apply2$294(c$266,d$267) =
//│       let x$303 = +(lam_arg1$302,lam_arg0$301) in
//│       let x$304 = +(x$303,c$266) in
//│       let x$305 = +(x$304,d$267) in
//│       x$305
//│   }
//│   def add4$255(a$256,b$257) =
//│     let x$298 = Lambda$290(b$257,a$256) in
//│     x$298
//│   def add4_curried$254(a$264,b$265) =
//│     let x$306 = Lambda$299(b$265,a$264) in
//│     x$306
//│   def entry$309() =
//│     let* (x$307) = add4(1,2) in
//│     let x$308 = Callable.apply2$294(x$307,3,4) in
//│     x$308
//│   entry = entry$309
//│ 
//│ Cpp:
//│ #include "mlsprelude.h"
//│ struct _mls_Lambda2;
//│ struct _mls_Lambda3;
//│ _mlsValue _mls_add4(_mlsValue, _mlsValue);
//│ _mlsValue _mls_add4_curried(_mlsValue, _mlsValue);
//│ _mlsValue _mls_entry2();
//│ struct _mls_Lambda2: public _mls_Callable {
//│   _mlsValue _mls_lam_arg0;
//│   _mlsValue _mls_lam_arg1;
//│   constexpr static inline const char *typeName = "Lambda";
//│   constexpr static inline uint32_t typeTag = nextTypeTag();
//│   virtual void print() const override { std::printf("%s", typeName); std::printf("("); this->_mls_lam_arg0.print(); std::printf(", "); this->_mls_lam_arg1.print();  std::printf(")"); }
//│   virtual void destroy() override { _mlsValue::destroy(this->_mls_lam_arg0); _mlsValue::destroy(this->_mls_lam_arg1);  operator delete (this, std::align_val_t(_mlsAlignment)); }
//│   static _mlsValue create(_mlsValue _mls_lam_arg0, _mlsValue _mls_lam_arg1) { auto _mlsVal = new (std::align_val_t(_mlsAlignment)) _mls_Lambda2; _mlsVal->refCount = 1; _mlsVal->tag = typeTag; _mlsVal->_mls_lam_arg0 = _mls_lam_arg0; _mlsVal->_mls_lam_arg1 = _mls_lam_arg1;  return _mlsValue(_mlsVal); }
//│   virtual _mlsValue _mls_apply2(_mlsValue, _mlsValue);
//│ };
//│ struct _mls_Lambda3: public _mls_Callable {
//│   _mlsValue _mls_lam_arg0;
//│   _mlsValue _mls_lam_arg1;
//│   constexpr static inline const char *typeName = "Lambda";
//│   constexpr static inline uint32_t typeTag = nextTypeTag();
//│   virtual void print() const override { std::printf("%s", typeName); std::printf("("); this->_mls_lam_arg0.print(); std::printf(", "); this->_mls_lam_arg1.print();  std::printf(")"); }
//│   virtual void destroy() override { _mlsValue::destroy(this->_mls_lam_arg0); _mlsValue::destroy(this->_mls_lam_arg1);  operator delete (this, std::align_val_t(_mlsAlignment)); }
//│   static _mlsValue create(_mlsValue _mls_lam_arg0, _mlsValue _mls_lam_arg1) { auto _mlsVal = new (std::align_val_t(_mlsAlignment)) _mls_Lambda3; _mlsVal->refCount = 1; _mlsVal->tag = typeTag; _mlsVal->_mls_lam_arg0 = _mls_lam_arg0; _mlsVal->_mls_lam_arg1 = _mls_lam_arg1;  return _mlsValue(_mlsVal); }
//│   virtual _mlsValue _mls_apply2(_mlsValue, _mlsValue);
//│ };
//│ _mlsValue _mls_add4(_mlsValue _mls_a, _mlsValue _mls_b) {
//│   _mlsValue _mls_retval;
//│   auto _mls_x14 = _mlsValue::create<_mls_Lambda2>(_mls_b, _mls_a);
//│   _mls_retval = _mls_x14;
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_add4_curried(_mlsValue _mls_a1, _mlsValue _mls_b1) {
//│   _mlsValue _mls_retval;
//│   auto _mls_x15 = _mlsValue::create<_mls_Lambda3>(_mls_b1, _mls_a1);
//│   _mls_retval = _mls_x15;
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_entry2() {
//│   _mlsValue _mls_retval;
//│   auto _mls_x16 = _mls_add4(_mlsValue::fromIntLit(1), _mlsValue::fromIntLit(2));
//│   auto _mls_x17 = _mlsMethodCall<_mls_Callable>(_mls_x16)->_mls_apply2(_mlsValue::fromIntLit(3), _mlsValue::fromIntLit(4));
//│   _mls_retval = _mls_x17;
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_Lambda2::_mls_apply2(_mlsValue _mls_c, _mlsValue _mls_d) {
//│   _mlsValue _mls_retval;
//│   auto _mls_x8 = (_mls_lam_arg1 + _mls_lam_arg0);
//│   auto _mls_x9 = (_mls_x8 + _mls_c);
//│   auto _mls_x10 = (_mls_x9 + _mls_d);
//│   _mls_retval = _mls_x10;
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_Lambda3::_mls_apply2(_mlsValue _mls_c1, _mlsValue _mls_d1) {
//│   _mlsValue _mls_retval;
//│   auto _mls_x11 = (_mls_lam_arg1 + _mls_lam_arg0);
//│   auto _mls_x12 = (_mls_x11 + _mls_c1);
//│   auto _mls_x13 = (_mls_x12 + _mls_d1);
//│   _mls_retval = _mls_x13;
//│   return _mls_retval;
//│ }
//│ _mlsValue _mlsMain() { return _mls_entry2(); }
//│ int main() { return _mlsLargeStack(_mlsMainWrapper); }
//│ 
//│ Interpreted:
//│ 10

:sllir
:intl
:scpp
fun add(a, b) = a + b
fun dummy() = add
dummy()(1, 2)
//│ = 3
//│ LLIR:
//│   class Lambda_add() extends Callable {
//│     def apply2$294(arg$328,arg$329) =
//│       let* (x$332) = add(arg$328,arg$329) in
//│       x$332
//│   }
//│   def add$310(a$312,b$313) =
//│     let x$327 = +(a$312,b$313) in
//│     x$327
//│   def dummy$311() =
//│     let x$333 = Lambda_add$330() in
//│     x$333
//│   def entry$336() =
//│     let* (x$334) = dummy() in
//│     let x$335 = Callable.apply2$294(x$334,1,2) in
//│     x$335
//│   entry = entry$336
//│ 
//│ Cpp:
//│ #include "mlsprelude.h"
//│ struct _mls_Lambda_add;
//│ _mlsValue _mls_add1(_mlsValue, _mlsValue);
//│ _mlsValue _mls_dummy();
//│ _mlsValue _mls_entry3();
//│ struct _mls_Lambda_add: public _mls_Callable {
//│   
//│   constexpr static inline const char *typeName = "Lambda_add";
//│   constexpr static inline uint32_t typeTag = nextTypeTag();
//│   virtual void print() const override { std::printf("%s", typeName); }
//│   virtual void destroy() override {  operator delete (this, std::align_val_t(_mlsAlignment)); }
//│   static _mlsValue create() { auto _mlsVal = new (std::align_val_t(_mlsAlignment)) _mls_Lambda_add; _mlsVal->refCount = 1; _mlsVal->tag = typeTag;  return _mlsValue(_mlsVal); }
//│   virtual _mlsValue _mls_apply2(_mlsValue, _mlsValue);
//│ };
//│ _mlsValue _mls_add1(_mlsValue _mls_a2, _mlsValue _mls_b2) {
//│   _mlsValue _mls_retval;
//│   auto _mls_x19 = (_mls_a2 + _mls_b2);
//│   _mls_retval = _mls_x19;
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_dummy() {
//│   _mlsValue _mls_retval;
//│   auto _mls_x20 = _mlsValue::create<_mls_Lambda_add>();
//│   _mls_retval = _mls_x20;
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_entry3() {
//│   _mlsValue _mls_retval;
//│   auto _mls_x21 = _mls_dummy();
//│   auto _mls_x22 = _mlsMethodCall<_mls_Callable>(_mls_x21)->_mls_apply2(_mlsValue::fromIntLit(1), _mlsValue::fromIntLit(2));
//│   _mls_retval = _mls_x22;
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_Lambda_add::_mls_apply2(_mlsValue _mls_arg, _mlsValue _mls_arg1) {
//│   _mlsValue _mls_retval;
//│   auto _mls_x18 = _mls_add1(_mls_arg, _mls_arg1);
//│   _mls_retval = _mls_x18;
//│   return _mls_retval;
//│ }
//│ _mlsValue _mlsMain() { return _mls_entry3(); }
//│ int main() { return _mlsLargeStack(_mlsMainWrapper); }
//│ 
//│ Interpreted:
//│ 3

:sllir
:intl
abstract class List[out T]: Cons[T] | Nil
class (::) Cons[out T](head: T, tail: List[T]) extends List[T]
object Nil extends List
fun map(f, l) =
  if l is
    Cons(h, t) then Cons(f(h), map(f, t))
    Nil then Nil
fun inc(x) = x + 1
fun main() =
  map(x => inc(x), 1 :: 2 :: Nil)
  map(inc, 3 :: 4 :: Nil)
main()
//│ = Cons(4, Cons(5, Nil))
//│ LLIR:
//│   class List()
//│   class Cons(head$349,tail$350) extends List
//│   class Nil() extends List
//│   class Lambda() extends Callable {
//│     def apply1$242(x$367) =
//│       let* (x$432) = inc(x$367) in
//│       x$432
//│   }
//│   class Lambda_inc() extends Callable {
//│     def apply1$242(arg$438) =
//│       let* (x$441) = inc(arg$438) in
//│       x$441
//│   }
//│   def map$338(f$353,l$354) =
//│     case l$354 of
//│       Cons$346 =>
//│         let x$418 = l$354.<Cons$346:head> in
//│         let x$419 = l$354.<Cons$346:tail> in
//│         let x$420 = Callable.apply1$242(f$353,x$418) in
//│         let* (x$421) = map(f$353,x$419) in
//│         let x$422 = Cons$346(x$420,x$421) in
//│         x$422
//│       _ =>
//│         case l$354 of
//│           Nil$351 =>
//│             let x$424 = Nil$351() in
//│             x$424
//│           _ =>
//│             panic "match error"
//│   def j$423() =
//│     jump j$417()
//│   def j$417() =
//│     null
//│   def inc$341(x$363) =
//│     let x$425 = +(x$363,1) in
//│     x$425
//│   def main$339() =
//│     let x$426 = Nil$351() in
//│     let x$427 = Cons$346(2,x$426) in
//│     let x$428 = Cons$346(1,x$427) in
//│     let x$433 = Lambda$430() in
//│     let* (x$429) = map(x$433,x$428) in
//│     let x$434 = Nil$351() in
//│     let x$435 = Cons$346(4,x$434) in
//│     let x$436 = Cons$346(3,x$435) in
//│     let x$442 = Lambda_inc$439() in
//│     let* (x$437) = map(x$442,x$436) in
//│     x$437
//│   def entry$444() =
//│     let* (x$443) = main() in
//│     x$443
//│   entry = entry$444
//│ 
//│ Interpreted:
//│ Cons(4,Cons(5,Nil()))

:scpp
:sllir
:intl
abstract class List[out T]: Cons[T] | Nil
class (::) Cons[out T](head: T, tail: List[T]) extends List[T]
object Nil extends List
fun not(c) = if c then false else true
fun filter(f, ls) = if ls is
  Nil then Nil
  h :: t and
    f(h) then h :: filter(f, t)
    else filter(f, t)
fun nubBy(eq, ls) = if ls is
  Nil then Nil
  h :: t then h :: nubBy(eq, filter(y => not(eq(h, y)), t))
nubBy((x, y) => x == y, 1 :: 2 :: 3 :: 3 :: Nil)
//│ = Cons(1, Cons(2, Cons(3, Nil)))
//│ LLIR:
//│   class List()
//│   class Cons(head$457,tail$458) extends List
//│   class Nil() extends List
//│   class Lambda(lam_arg0$564,lam_arg1$565) extends Callable {
//│     def apply1$242(y$484) =
//│       let x$566 = Callable.apply2$294(lam_arg0$564,lam_arg1$565,y$484) in
//│       let* (x$567) = not(x$566) in
//│       x$567
//│   }
//│   class Lambda() extends Callable {
//│     def apply2$294(x$489,y$490) =
//│       let x$579 = ==(x$489,y$490) in
//│       x$579
//│   }
//│   def not$448(c$461) =
//│     case c$461 of
//│       BoolLit(true) =>
//│         false
//│       _ =>
//│         true
//│   def j$545() =
//│     null
//│   def filter$447(f$463,ls$464) =
//│     case ls$464 of
//│       Nil$459 =>
//│         let x$547 = Nil$459() in
//│         x$547
//│       _ =>
//│         case ls$464 of
//│           Cons$454 =>
//│             let x$549 = ls$464.<Cons$454:head> in
//│             let x$550 = ls$464.<Cons$454:tail> in
//│             let x$551 = Callable.apply1$242(f$463,x$549) in
//│             case x$551 of
//│               BoolLit(true) =>
//│                 let* (x$553) = filter(f$463,x$550) in
//│                 let x$554 = Cons$454(x$549,x$553) in
//│                 x$554
//│               _ =>
//│                 let* (x$555) = filter(f$463,x$550) in
//│                 x$555
//│           _ =>
//│             panic "match error"
//│   def j$552() =
//│     jump j$548()
//│   def j$548() =
//│     jump j$546()
//│   def j$546() =
//│     null
//│   def nubBy$450(eq$475,ls$476) =
//│     case ls$476 of
//│       Nil$459 =>
//│         let x$557 = Nil$459() in
//│         x$557
//│       _ =>
//│         case ls$476 of
//│           Cons$454 =>
//│             let x$559 = ls$476.<Cons$454:head> in
//│             let x$560 = ls$476.<Cons$454:tail> in
//│             let x$568 = Lambda$562(eq$475,x$559) in
//│             let* (x$561) = filter(x$568,x$560) in
//│             let* (x$569) = nubBy(eq$475,x$561) in
//│             let x$570 = Cons$454(x$559,x$569) in
//│             x$570
//│           _ =>
//│             panic "match error"
//│   def j$558() =
//│     jump j$556()
//│   def j$556() =
//│     null
//│   def entry$581() =
//│     let x$571 = Nil$459() in
//│     let x$572 = Cons$454(3,x$571) in
//│     let x$573 = Cons$454(3,x$572) in
//│     let x$574 = Cons$454(2,x$573) in
//│     let x$575 = Cons$454(1,x$574) in
//│     let x$580 = Lambda$577() in
//│     let* (x$576) = nubBy(x$580,x$575) in
//│     x$576
//│   entry = entry$581
//│ 
//│ Cpp:
//│ #include "mlsprelude.h"
//│ struct _mls_List1;
//│ struct _mls_Cons1;
//│ struct _mls_Nil1;
//│ struct _mls_Lambda6;
//│ struct _mls_Lambda5;
//│ _mlsValue _mls_entry5();
//│ _mlsValue _mls_j4();
//│ _mlsValue _mls_j6();
//│ _mlsValue _mls_filter(_mlsValue, _mlsValue);
//│ _mlsValue _mls_j7();
//│ _mlsValue _mls_j5();
//│ _mlsValue _mls_not(_mlsValue);
//│ _mlsValue _mls_nubBy(_mlsValue, _mlsValue);
//│ _mlsValue _mls_j2();
//│ _mlsValue _mls_j3();
//│ struct _mls_List1: public _mlsObject {
//│   
//│   constexpr static inline const char *typeName = "List";
//│   constexpr static inline uint32_t typeTag = nextTypeTag();
//│   virtual void print() const override { std::printf("%s", typeName); }
//│   virtual void destroy() override {  operator delete (this, std::align_val_t(_mlsAlignment)); }
//│   static _mlsValue create() { auto _mlsVal = new (std::align_val_t(_mlsAlignment)) _mls_List1; _mlsVal->refCount = 1; _mlsVal->tag = typeTag;  return _mlsValue(_mlsVal); }
//│   
//│ };
//│ struct _mls_Cons1: public _mls_List1 {
//│   _mlsValue _mls_head;
//│   _mlsValue _mls_tail;
//│   constexpr static inline const char *typeName = "Cons";
//│   constexpr static inline uint32_t typeTag = nextTypeTag();
//│   virtual void print() const override { std::printf("%s", typeName); std::printf("("); this->_mls_head.print(); std::printf(", "); this->_mls_tail.print();  std::printf(")"); }
//│   virtual void destroy() override { _mlsValue::destroy(this->_mls_head); _mlsValue::destroy(this->_mls_tail);  operator delete (this, std::align_val_t(_mlsAlignment)); }
//│   static _mlsValue create(_mlsValue _mls_head, _mlsValue _mls_tail) { auto _mlsVal = new (std::align_val_t(_mlsAlignment)) _mls_Cons1; _mlsVal->refCount = 1; _mlsVal->tag = typeTag; _mlsVal->_mls_head = _mls_head; _mlsVal->_mls_tail = _mls_tail;  return _mlsValue(_mlsVal); }
//│   
//│ };
//│ struct _mls_Nil1: public _mls_List1 {
//│   
//│   constexpr static inline const char *typeName = "Nil";
//│   constexpr static inline uint32_t typeTag = nextTypeTag();
//│   virtual void print() const override { std::printf("%s", typeName); }
//│   virtual void destroy() override {  operator delete (this, std::align_val_t(_mlsAlignment)); }
//│   static _mlsValue create() { auto _mlsVal = new (std::align_val_t(_mlsAlignment)) _mls_Nil1; _mlsVal->refCount = 1; _mlsVal->tag = typeTag;  return _mlsValue(_mlsVal); }
//│   
//│ };
//│ struct _mls_Lambda6: public _mls_Callable {
//│   
//│   constexpr static inline const char *typeName = "Lambda";
//│   constexpr static inline uint32_t typeTag = nextTypeTag();
//│   virtual void print() const override { std::printf("%s", typeName); }
//│   virtual void destroy() override {  operator delete (this, std::align_val_t(_mlsAlignment)); }
//│   static _mlsValue create() { auto _mlsVal = new (std::align_val_t(_mlsAlignment)) _mls_Lambda6; _mlsVal->refCount = 1; _mlsVal->tag = typeTag;  return _mlsValue(_mlsVal); }
//│   virtual _mlsValue _mls_apply2(_mlsValue, _mlsValue);
//│ };
//│ struct _mls_Lambda5: public _mls_Callable {
//│   _mlsValue _mls_lam_arg0;
//│   _mlsValue _mls_lam_arg1;
//│   constexpr static inline const char *typeName = "Lambda";
//│   constexpr static inline uint32_t typeTag = nextTypeTag();
//│   virtual void print() const override { std::printf("%s", typeName); std::printf("("); this->_mls_lam_arg0.print(); std::printf(", "); this->_mls_lam_arg1.print();  std::printf(")"); }
//│   virtual void destroy() override { _mlsValue::destroy(this->_mls_lam_arg0); _mlsValue::destroy(this->_mls_lam_arg1);  operator delete (this, std::align_val_t(_mlsAlignment)); }
//│   static _mlsValue create(_mlsValue _mls_lam_arg0, _mlsValue _mls_lam_arg1) { auto _mlsVal = new (std::align_val_t(_mlsAlignment)) _mls_Lambda5; _mlsVal->refCount = 1; _mlsVal->tag = typeTag; _mlsVal->_mls_lam_arg0 = _mls_lam_arg0; _mlsVal->_mls_lam_arg1 = _mls_lam_arg1;  return _mlsValue(_mlsVal); }
//│   virtual _mlsValue _mls_apply1(_mlsValue);
//│ };
//│ _mlsValue _mls_not(_mlsValue _mls_c2) {
//│   _mlsValue _mls_retval;
//│   if (_mlsValue::isIntLit(_mls_c2, 1)) {
//│     _mls_retval = _mlsValue::fromIntLit(0);
//│   } else {
//│     _mls_retval = _mlsValue::fromIntLit(1);
//│   }
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_entry5() {
//│   _mlsValue _mls_retval;
//│   auto _mls_x56 = _mlsValue::create<_mls_Nil1>();
//│   auto _mls_x57 = _mlsValue::create<_mls_Cons1>(_mlsValue::fromIntLit(3), _mls_x56);
//│   auto _mls_x58 = _mlsValue::create<_mls_Cons1>(_mlsValue::fromIntLit(3), _mls_x57);
//│   auto _mls_x59 = _mlsValue::create<_mls_Cons1>(_mlsValue::fromIntLit(2), _mls_x58);
//│   auto _mls_x60 = _mlsValue::create<_mls_Cons1>(_mlsValue::fromIntLit(1), _mls_x59);
//│   auto _mls_x61 = _mlsValue::create<_mls_Lambda6>();
//│   auto _mls_x62 = _mls_nubBy(_mls_x61, _mls_x60);
//│   _mls_retval = _mls_x62;
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_j6() {
//│   _mlsValue _mls_retval;
//│   _mls_retval = _mls_j5();
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_j3() {
//│   _mlsValue _mls_retval;
//│   _mls_retval = _mlsValue::create<_mls_Unit>();
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_nubBy(_mlsValue _mls_eq, _mlsValue _mls_ls1) {
//│   _mlsValue _mls_retval;
//│   if (_mlsValue::isValueOf<_mls_Nil1>(_mls_ls1)) {
//│     auto _mls_x69 = _mlsValue::create<_mls_Nil1>();
//│     _mls_retval = _mls_x69;
//│   } else {
//│     if (_mlsValue::isValueOf<_mls_Cons1>(_mls_ls1)) {
//│       auto _mls_x63 = _mlsValue::cast<_mls_Cons1>(_mls_ls1)->_mls_head;
//│       auto _mls_x64 = _mlsValue::cast<_mls_Cons1>(_mls_ls1)->_mls_tail;
//│       auto _mls_x65 = _mlsValue::create<_mls_Lambda5>(_mls_eq, _mls_x63);
//│       auto _mls_x66 = _mls_filter(_mls_x65, _mls_x64);
//│       auto _mls_x67 = _mls_nubBy(_mls_eq, _mls_x66);
//│       auto _mls_x68 = _mlsValue::create<_mls_Cons1>(_mls_x63, _mls_x67);
//│       _mls_retval = _mls_x68;
//│     } else {
//│       throw std::runtime_error("match error");
//│     }
//│   }
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_j4() {
//│   _mlsValue _mls_retval;
//│   _mls_retval = _mls_j2();
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_j2() {
//│   _mlsValue _mls_retval;
//│   _mls_retval = _mlsValue::create<_mls_Unit>();
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_j5() {
//│   _mlsValue _mls_retval;
//│   _mls_retval = _mls_j3();
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_j7() {
//│   _mlsValue _mls_retval;
//│   _mls_retval = _mlsValue::create<_mls_Unit>();
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_filter(_mlsValue _mls_f1, _mlsValue _mls_ls) {
//│   _mlsValue _mls_retval;
//│   if (_mlsValue::isValueOf<_mls_Nil1>(_mls_ls)) {
//│     auto _mls_x55 = _mlsValue::create<_mls_Nil1>();
//│     _mls_retval = _mls_x55;
//│   } else {
//│     if (_mlsValue::isValueOf<_mls_Cons1>(_mls_ls)) {
//│       auto _mls_x49 = _mlsValue::cast<_mls_Cons1>(_mls_ls)->_mls_head;
//│       auto _mls_x50 = _mlsValue::cast<_mls_Cons1>(_mls_ls)->_mls_tail;
//│       auto _mls_x51 = _mlsMethodCall<_mls_Callable>(_mls_f1)->_mls_apply1(_mls_x49);
//│       if (_mlsValue::isIntLit(_mls_x51, 1)) {
//│         auto _mls_x53 = _mls_filter(_mls_f1, _mls_x50);
//│         auto _mls_x54 = _mlsValue::create<_mls_Cons1>(_mls_x49, _mls_x53);
//│         _mls_retval = _mls_x54;
//│       } else {
//│         auto _mls_x52 = _mls_filter(_mls_f1, _mls_x50);
//│         _mls_retval = _mls_x52;
//│       }
//│     } else {
//│       throw std::runtime_error("match error");
//│     }
//│   }
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_Lambda6::_mls_apply2(_mlsValue _mls_x46, _mlsValue _mls_y2) {
//│   _mlsValue _mls_retval;
//│   auto _mls_x45 = (_mls_x46 == _mls_y2);
//│   _mls_retval = _mls_x45;
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_Lambda5::_mls_apply1(_mlsValue _mls_y3) {
//│   _mlsValue _mls_retval;
//│   auto _mls_x47 = _mlsMethodCall<_mls_Callable>(_mls_lam_arg0)->_mls_apply2(_mls_lam_arg1, _mls_y3);
//│   auto _mls_x48 = _mls_not(_mls_x47);
//│   _mls_retval = _mls_x48;
//│   return _mls_retval;
//│ }
//│ _mlsValue _mlsMain() { return _mls_entry5(); }
//│ int main() { return _mlsLargeStack(_mlsMainWrapper); }
//│ 
//│ Interpreted:
//│ Cons(1,Cons(2,Cons(3,Nil())))

:sllir
:intl
:scpp
fun f(x) =
  fun self_rec(x) =
    if x == 0 then 0
    else x + self_rec(x - 1)
  self_rec(x)
f(3)
//│ = 6
//│ LLIR:
//│   class Lambda_self_rec() extends Callable {
//│     def apply1$242(x$585) =
//│       let x$610 = ==(x$585,0) in
//│       case x$610 of
//│         BoolLit(true) =>
//│           0
//│         _ =>
//│           let x$612 = -(x$585,1) in
//│           let x$613 = Callable.apply1$242(<this>$609,x$612) in
//│           let x$614 = +(x$585,x$613) in
//│           x$614
//│   }
//│   def f$583(x$584) =
//│     let x$615 = Lambda_self_rec$607() in
//│     let x$616 = Callable.apply1$242(x$615,x$584) in
//│     x$616
//│   def j$611() =
//│     null
//│   def entry$618() =
//│     let* (x$617) = f(3) in
//│     x$617
//│   entry = entry$618
//│ 
//│ Cpp:
//│ #include "mlsprelude.h"
//│ struct _mls_Lambda_self_rec;
//│ _mlsValue _mls_j8();
//│ _mlsValue _mls_f2(_mlsValue);
//│ _mlsValue _mls_entry6();
//│ struct _mls_Lambda_self_rec: public _mls_Callable {
//│   
//│   constexpr static inline const char *typeName = "Lambda_self_rec";
//│   constexpr static inline uint32_t typeTag = nextTypeTag();
//│   virtual void print() const override { std::printf("%s", typeName); }
//│   virtual void destroy() override {  operator delete (this, std::align_val_t(_mlsAlignment)); }
//│   static _mlsValue create() { auto _mlsVal = new (std::align_val_t(_mlsAlignment)) _mls_Lambda_self_rec; _mlsVal->refCount = 1; _mlsVal->tag = typeTag;  return _mlsValue(_mlsVal); }
//│   virtual _mlsValue _mls_apply1(_mlsValue);
//│ };
//│ _mlsValue _mls_j8() {
//│   _mlsValue _mls_retval;
//│   _mls_retval = _mlsValue::create<_mls_Unit>();
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_f2(_mlsValue _mls_x76) {
//│   _mlsValue _mls_retval;
//│   auto _mls_x75 = _mlsValue::create<_mls_Lambda_self_rec>();
//│   auto _mls_x77 = _mlsMethodCall<_mls_Callable>(_mls_x75)->_mls_apply1(_mls_x76);
//│   _mls_retval = _mls_x77;
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_entry6() {
//│   _mlsValue _mls_retval;
//│   auto _mls_x78 = _mls_f2(_mlsValue::fromIntLit(3));
//│   _mls_retval = _mls_x78;
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_Lambda_self_rec::_mls_apply1(_mlsValue _mls_x71) {
//│   _mlsValue _mls_retval;
//│   auto _mls_x70 = (_mls_x71 == _mlsValue::fromIntLit(0));
//│   if (_mlsValue::isIntLit(_mls_x70, 1)) {
//│     _mls_retval = _mlsValue::fromIntLit(0);
//│   } else {
//│     auto _mls_x72 = (_mls_x71 - _mlsValue::fromIntLit(1));
//│     auto _mls_x73 = this->_mls_apply1(_mls_x72);
//│     auto _mls_x74 = (_mls_x71 + _mls_x73);
//│     _mls_retval = _mls_x74;
//│   }
//│   return _mls_retval;
//│ }
//│ _mlsValue _mlsMain() { return _mls_entry6(); }
//│ int main() { return _mlsLargeStack(_mlsMainWrapper); }
//│ 
//│ Interpreted:
//│ 6

:sllir
:scpp
fun f(x) =
  fun even(x) =
    fun odd(x) =
      if x == 0 then true
      else if x == 1 then false
      else even(x - 1)
    if x == 0 then true
    else if x == 1 then false
    else odd(x - 1)
  even(x)
f(3)
//│ = false
//│ LLIR:
//│   class Lambda_odd(lam_arg0$660) extends Callable {
//│     def apply1$242(x$624) =
//│       let x$661 = ==(x$624,0) in
//│       case x$661 of
//│         BoolLit(true) =>
//│           true
//│         _ =>
//│           let x$663 = ==(x$624,1) in
//│           case x$663 of
//│             BoolLit(true) =>
//│               false
//│             _ =>
//│               let x$665 = -(x$624,1) in
//│               let x$666 = Callable.apply1$242(lam_arg0$660,x$665) in
//│               x$666
//│   }
//│   class Lambda_even() extends Callable {
//│     def apply1$242(x$623) =
//│       let x$667 = Lambda_odd$658(<this>$609) in
//│       let x$668 = ==(x$623,0) in
//│       case x$668 of
//│         BoolLit(true) =>
//│           true
//│         _ =>
//│           let x$670 = ==(x$623,1) in
//│           case x$670 of
//│             BoolLit(true) =>
//│               false
//│             _ =>
//│               let x$672 = -(x$623,1) in
//│               let x$673 = Callable.apply1$242(x$667,x$672) in
//│               x$673
//│   }
//│   def f$621(x$622) =
//│     let x$674 = Lambda_even$656() in
//│     let x$675 = Callable.apply1$242(x$674,x$622) in
//│     x$675
//│   def j$664() =
//│     jump j$662()
//│   def j$662() =
//│     null
//│   def j$671() =
//│     jump j$669()
//│   def j$669() =
//│     null
//│   def entry$677() =
//│     let* (x$676) = f(3) in
//│     x$676
//│   entry = entry$677
//│ 
//│ Cpp:
//│ #include "mlsprelude.h"
//│ struct _mls_Lambda_odd;
//│ struct _mls_Lambda_even;
//│ _mlsValue _mls_j11();
//│ _mlsValue _mls_entry7();
//│ _mlsValue _mls_f3(_mlsValue);
//│ _mlsValue _mls_j10();
//│ _mlsValue _mls_j9();
//│ _mlsValue _mls_j12();
//│ struct _mls_Lambda_odd: public _mls_Callable {
//│   _mlsValue _mls_lam_arg0;
//│   constexpr static inline const char *typeName = "Lambda_odd";
//│   constexpr static inline uint32_t typeTag = nextTypeTag();
//│   virtual void print() const override { std::printf("%s", typeName); std::printf("("); this->_mls_lam_arg0.print();  std::printf(")"); }
//│   virtual void destroy() override { _mlsValue::destroy(this->_mls_lam_arg0);  operator delete (this, std::align_val_t(_mlsAlignment)); }
//│   static _mlsValue create(_mlsValue _mls_lam_arg0) { auto _mlsVal = new (std::align_val_t(_mlsAlignment)) _mls_Lambda_odd; _mlsVal->refCount = 1; _mlsVal->tag = typeTag; _mlsVal->_mls_lam_arg0 = _mls_lam_arg0;  return _mlsValue(_mlsVal); }
//│   virtual _mlsValue _mls_apply1(_mlsValue);
//│ };
//│ struct _mls_Lambda_even: public _mls_Callable {
//│   
//│   constexpr static inline const char *typeName = "Lambda_even";
//│   constexpr static inline uint32_t typeTag = nextTypeTag();
//│   virtual void print() const override { std::printf("%s", typeName); }
//│   virtual void destroy() override {  operator delete (this, std::align_val_t(_mlsAlignment)); }
//│   static _mlsValue create() { auto _mlsVal = new (std::align_val_t(_mlsAlignment)) _mls_Lambda_even; _mlsVal->refCount = 1; _mlsVal->tag = typeTag;  return _mlsValue(_mlsVal); }
//│   virtual _mlsValue _mls_apply1(_mlsValue);
//│ };
//│ _mlsValue _mls_entry7() {
//│   _mlsValue _mls_retval;
//│   auto _mls_x90 = _mls_f3(_mlsValue::fromIntLit(3));
//│   _mls_retval = _mls_x90;
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_j12() {
//│   _mlsValue _mls_retval;
//│   _mls_retval = _mls_j11();
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_j11() {
//│   _mlsValue _mls_retval;
//│   _mls_retval = _mlsValue::create<_mls_Unit>();
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_j9() {
//│   _mlsValue _mls_retval;
//│   _mls_retval = _mlsValue::create<_mls_Unit>();
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_f3(_mlsValue _mls_x92) {
//│   _mlsValue _mls_retval;
//│   auto _mls_x91 = _mlsValue::create<_mls_Lambda_even>();
//│   auto _mls_x93 = _mlsMethodCall<_mls_Callable>(_mls_x91)->_mls_apply1(_mls_x92);
//│   _mls_retval = _mls_x93;
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_j10() {
//│   _mlsValue _mls_retval;
//│   _mls_retval = _mls_j9();
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_Lambda_odd::_mls_apply1(_mlsValue _mls_x80) {
//│   _mlsValue _mls_retval;
//│   auto _mls_x79 = (_mls_x80 == _mlsValue::fromIntLit(0));
//│   if (_mlsValue::isIntLit(_mls_x79, 1)) {
//│     _mls_retval = _mlsValue::fromIntLit(1);
//│   } else {
//│     auto _mls_x81 = (_mls_x80 == _mlsValue::fromIntLit(1));
//│     if (_mlsValue::isIntLit(_mls_x81, 1)) {
//│       _mls_retval = _mlsValue::fromIntLit(0);
//│     } else {
//│       auto _mls_x82 = (_mls_x80 - _mlsValue::fromIntLit(1));
//│       auto _mls_x83 = _mlsMethodCall<_mls_Callable>(_mls_lam_arg0)->_mls_apply1(_mls_x82);
//│       _mls_retval = _mls_x83;
//│     }
//│   }
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_Lambda_even::_mls_apply1(_mlsValue _mls_x86) {
//│   _mlsValue _mls_retval;
//│   auto _mls_x84 = _mlsValue::create<_mls_Lambda_odd>(_mlsValue(this, _mlsValue::inc_ref_tag{}));
//│   auto _mls_x85 = (_mls_x86 == _mlsValue::fromIntLit(0));
//│   if (_mlsValue::isIntLit(_mls_x85, 1)) {
//│     _mls_retval = _mlsValue::fromIntLit(1);
//│   } else {
//│     auto _mls_x87 = (_mls_x86 == _mlsValue::fromIntLit(1));
//│     if (_mlsValue::isIntLit(_mls_x87, 1)) {
//│       _mls_retval = _mlsValue::fromIntLit(0);
//│     } else {
//│       auto _mls_x88 = (_mls_x86 - _mlsValue::fromIntLit(1));
//│       auto _mls_x89 = _mlsMethodCall<_mls_Callable>(_mls_x84)->_mls_apply1(_mls_x88);
//│       _mls_retval = _mls_x89;
//│     }
//│   }
//│   return _mls_retval;
//│ }
//│ _mlsValue _mlsMain() { return _mls_entry7(); }
//│ int main() { return _mlsLargeStack(_mlsMainWrapper); }
