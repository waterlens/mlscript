:js

:import PredefJS.mls
//│ Imported 2 member(s)


fun foo() =
  1 + 2

foo
//│ = [Function: foo]

foo()
//│ = 3

fun foo(x) =
  x + 1

foo(123)
//│ = 124

fun foo(x) =
  x + 1 + 2

foo(123)
//│ = 126

fun foo() = bar()
fun bar() = 42

bar()
//│ = 42

foo()
//│ = 42

fun foo() = bar()
let r = foo()
fun bar() = 42
r
//│ = 42
//│ r = 42

// Note that this initializes fine
fun foo() = bar()
let r = foo()
fun bar() = r
//│ r = 42


fun outerfun(x) =
  let r = x + 1
  fun nested(y) =
    r + x + y
  log(nested(x))
  nested

let f = outerfun(100)
f(200)
//│ > 301
//│ = 401
//│ f = [Function: nested]

// f(200)

outerfun(100)
//│ > 301
//│ = [Function: nested]

outerfun(100)(200)
//│ > 301
//│ = 401


// * Notice this strange JS phenomenon:
// * functions leak from the `try` scope, although things like classes do not...

:showRepl
fun test1(x) = test2(x)
fun test2(y) = y + 1
//│ REPL> Sending: try { function test1(...args) {   globalThis.Predef.checkArgs("test1", 1, true, args.length);   let x = args[0];   return globalThis.test2(x); } function test2(...args) {   globalThis.Predef.checkArgs("test2", 1, true, args.length);   let y = args[0];   return y + 1; } null } catch (e) { console.log('\u200B' + e.stack + '\u200B'); }
//│ REPL> Collected:
//│ >  null
//│ REPL> Parsed:
//│ >  null

test1(1)
//│ = 2


