:llir

abstract class Lazy[out A](init: () -> A) with
  fun get: A
fun lazy(x) = Lazy(x)
fun force(x) = if x is Lazy then x.Lazy#get()
type LazyList[out T] = Lazy[LzList[T]]
abstract class LzList[out T]: LzCons[T] | LzNil
class LzCons[out T](head: T, tail: LazyList[T]) extends LzList[T]
object LzNil extends LzList

:sllir
:scpp
fun side_effect() =
  console.log("executed")
  1
fun main() =
  let x = lazy(() => side_effect())
  let y = force(x)
  let y1 = force(x) // force again, but should not execute side_effect again
  ()
main()
//│ LLIR:
//│   class Lambda() extends Callable {
//│     def apply0$283() =
//│       let* (x$284) = side_effect() in
//│       x$284
//│   }
//│   def side_effect$256() =
//│     let* (x$278) = <builtin>("println","executed") in
//│     1
//│   def main$255() =
//│     let x$286 = Lambda$281() in
//│     let* (x$280) = lazy(x$286) in
//│     let* (x$287) = force(x$280) in
//│     let* (x$288) = force(x$280) in
//│     undefined
//│   def entry$290() =
//│     let* (x$289) = main() in
//│     x$289
//│   entry = entry$290
//│ 
//│ Cpp:
//│ #include "mlsprelude.h"
//│ struct _mls_Lambda;
//│ _mlsValue _mls_side_effect();
//│ _mlsValue _mls_main();
//│ _mlsValue _mls_entry();
//│ struct _mls_Lambda: public _mls_Callable {
//│   
//│   constexpr static inline const char *typeName = "Lambda";
//│   constexpr static inline uint32_t typeTag = nextTypeTag();
//│   virtual void print() const override { std::printf("%s", typeName); }
//│   virtual void destroy() override {  operator delete (this, std::align_val_t(_mlsAlignment)); }
//│   static _mlsValue create() { auto _mlsVal = new (std::align_val_t(_mlsAlignment)) _mls_Lambda; _mlsVal->refCount = 1; _mlsVal->tag = typeTag;  return _mlsValue(_mlsVal); }
//│   virtual _mlsValue _mls_apply0();
//│ };
//│ _mlsValue _mls_side_effect() {
//│   _mlsValue _mls_retval;
//│   auto _mls_x1 = _mls_builtin_println(_mlsValue::create<_mls_Str>("executed"));
//│   _mls_retval = _mlsValue::fromIntLit(1);
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_main() {
//│   _mlsValue _mls_retval;
//│   auto _mls_x2 = _mlsValue::create<_mls_Lambda>();
//│   auto _mls_x3 = _mls_lazy(_mls_x2);
//│   auto _mls_x4 = _mls_force(_mls_x3);
//│   auto _mls_x5 = _mls_force(_mls_x3);
//│   _mls_retval = _mlsValue::create<_mls_Unit>();
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_entry() {
//│   _mlsValue _mls_retval;
//│   auto _mls_x6 = _mls_main();
//│   _mls_retval = _mls_x6;
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_Lambda::_mls_apply0() {
//│   _mlsValue _mls_retval;
//│   auto _mls_x = _mls_side_effect();
//│   _mls_retval = _mls_x;
//│   return _mls_retval;
//│ }
//│ _mlsValue _mlsMain() { return _mls_entry(); }
//│ int main() { return _mlsLargeStack(_mlsMainWrapper); }
