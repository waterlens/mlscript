:js
:import NofibPrelude.mls
//│ Imported 109 member(s)


let pi = globalThis.Math.PI
let epsilon  = 0.000001
let infinity = 100000000.0
//│ epsilon = 0.000001
//│ infinity = 100000000
//│ pi = 3.141592653589793

fun vecadd(a1, a2) =
  if a1 is Tup3(x1, y1, z1) and a2 is Tup3(x2, y2, z2) then
    Tup3(x1 + x2, y1 + y2, z1 + z2)

fun vecsub(a1, a2) =
  if a1 is Tup3(x1, y1, z1) and a2 is Tup3(x2, y2, z2) then
    Tup3(x1 - x2, y1 - y2, z1 - z2)

fun vecmult(a1, a2) =
  if a1 is Tup3(x1, y1, z1) and a2 is Tup3(x2, y2, z2) then
    Tup3(x1 * x2, y1 * y2, z1 * z2)

fun vecsum(param) = foldr(vecadd, Tup3(0.0, 0.0, 0.0), param)

fun vecnorm(xyz) = if xyz is Tup3(x, y, z) then
  let len = sqrt(x * x + y * y + z * z)
  Tup2(Tup3(x / len , y / len, z / len), len)

fun vecscale(xyz, a) = if xyz is Tup3(x, y, z) then Tup3(a * x, a * y, a * z)

fun vecdot(x1, x2) = if x1 is Tup3(x1, y1, z1) and x2 is Tup3(x2, y2, z2) then x1 * x2 + y1 * y2 + z1 * z2

fun veccross(x1, x2) = if x1 is Tup3(x1, y1, z1) and x2 is Tup3(x2, y2, z2) then
  Tup3((y1 * z2) - (y2 * z1), (z1 * x2) - (z2 * x1), (x1 * y2) - (x2 * y1))

fun is_zerovector(x) = if x is Tup3(x, y, z) then (x < epsilon) && (y < epsilon) && (z < epsilon)

abstract class Light: Directional | Point

class
  Directional(x: Tup3[Num, Num, Num], y: Tup3[Num, Num, Num]) extends Light
  Point(x: Tup3[Num, Num, Num], y: Tup3[Num, Num, Num]) extends Light

fun lightpos(p) = if p is Point(pos, col) then pos

fun lightdir(d) = if d is Directional(dir, col) then fst(vecnorm(dir))

fun lightcolour(x) = if x is
  Directional(dir, col) then col
  Point(pos, col) then col

abstract class Surfspec: Ambient | Diffuse | Specular | Specpow | Reflect | Transmit | Refract | Body

class
  Ambient(v: Tup3[Num, Num, Num]) extends Surfspec
  Diffuse(v: Tup3[Num, Num, Num]) extends Surfspec
  Specular(v: Tup3[Num, Num, Num]) extends Surfspec
  Specpow(v: Num) extends Surfspec
  Reflect(v: Num) extends Surfspec
  Transmit(v: Num) extends Surfspec
  Refract(v: Num) extends Surfspec
  Body(v: Tup3[Num, Num, Num]) extends Surfspec

fun ambientsurf(ss) =
  fun lscomp(ls) = if ls is
    Nil then Nil
    Cons(x, t) and
      x is Ambient(s) then Cons(s, lscomp(t))
      else lscomp(t)
  
  head(append(lscomp(ss), (Tup3(0.0, 0.0, 0.0) :: Nil)))


fun diffusesurf(ss) =
  fun lscomp(ls) = if ls is
    Nil then Nil
    Cons(x, t) and
      x is Diffuse(s) then Cons(s, lscomp(t))
      else lscomp(t)
  
  head(append(lscomp(ss), (Tup3(0.0, 0.0, 0.0) :: Nil)))


fun specularsurf(ss) =
  fun lscomp(ls) = if ls is
    Nil then Nil
    Cons(x, t) and
      x is Specular(s) then Cons(s, lscomp(t))
      else lscomp(t)
  
  head(append(lscomp(ss), (Tup3(0.0, 0.0, 0.0) :: Nil)))


fun specpowsurf(ss) =
  fun lscomp(ls) = if ls is
    Nil then Nil
    Cons(x, t) and
      x is Specpow(s) then Cons(s, lscomp(t))
      else lscomp(t)
  
  head(append(lscomp(ss), (8.0 :: Nil)))


fun reflectsurf(ss) =
  fun lscomp(ls) = if ls is
    Nil then Nil
    Cons(x, t) and
      x is Reflect(s) then Cons(s, lscomp(t))
      else lscomp(t)
  
  head(append(lscomp(ss), (0.0 :: Nil)))


fun transmitsurf(ss) =
  fun lscomp(ls) = if ls is
    Nil then Nil
    Cons(x, t) and
      x is Transmit(s) then Cons(s, lscomp(t))
      else lscomp(t)
  
  head(append(lscomp(ss), (0.0 :: Nil)))


fun refractsurf(ss) =
  fun lscomp(ls) = if ls is
    Nil then Nil
    Cons(x, t) and
      x is Refract(s) then Cons(s, lscomp(t))
      else lscomp(t)
  
  head(append(lscomp(ss), (1.0 :: Nil)))


fun bodysurf(ss) =
  fun lscomp(ls) = if ls is
    Nil then Nil
    Cons(x, t) and
      x is Body(s) then Cons(s, lscomp(t))
      else lscomp(t)
  
  head(append(lscomp(ss), (Tup3(1.0, 1.0, 1.0) :: Nil)))


class Sphere(pos: Tup3[Num, Num, Num], radius: Num, surface: List[Surfspec])

fun spheresurf(s) = if s is Sphere(pos, rad, surf) then surf

let lookat = Tup3(0.0, 0.0, 0.0)
let vup = Tup3(0.0, 0.0, 1.0)
let fov = 45.0
let s2 =
  Cons(Ambient(Tup3(0.035, 0.0325, 0.025)), Cons(Diffuse(Tup3(0.5, 0.45, 0.35)), Cons(Specular(Tup3(0.8, 0.8, 0.8)), Cons(Specpow(3.0), Cons(Reflect(0.5), Nil)))))
let testspheres = Cons(Sphere(Tup3(0.0, 0.0, 0.0), 0.5, s2), Cons(Sphere(Tup3(0.272166, 0.272166, 0.544331), 0.166667, s2), Cons(Sphere(Tup3(0.643951, 0.172546, 0.0), 0.166667, s2), Cons(Sphere(Tup3(0.172546, 0.643951, 0.0), 0.166667, s2), Cons(Sphere(Tup3(-0.371785, 0.0996195, 0.544331), 0.166667, s2), Cons(Sphere(Tup3(-0.471405, 0.471405, 0.0), 0.166667, s2), Cons(Sphere(Tup3(-0.643951, -0.172546, 0.0), 0.166667, s2), Cons(Sphere(Tup3(0.0996195, -0.371785, 0.544331), 0.166667, s2), Cons(Sphere(Tup3(-0.172546, -0.643951, 0.0), 0.166667, s2), Cons(Sphere(Tup3(0.471405, -0.471405, 0.0), 0.166667, s2), Nil))))))))))
let testlights = Cons(Point(Tup3(4.0, 3.0, 2.0), Tup3(0.288675, 0.288675, 0.288675)), Cons(Point(Tup3(1.0, -4.0, 4.0), Tup3(0.288675, 0.288675, 0.288675)), Cons(Point(Tup3(-3.0, 1.0, 5.0), Tup3(0.288675, 0.288675, 0.288675)), Nil)))
let lookfrom   = Tup3(2.1, 1.3, 1.7)
let background = Tup3(0.078, 0.361, 0.753)
//│ background = Tup3 { fst: 0.078, snd: 0.361, thd: 0.753 }
//│ fov = 45
//│ lookat = Tup3 { fst: 0, snd: 0, thd: 0 }
//│ lookfrom = Tup3 { fst: 2.1, snd: 1.3, thd: 1.7 }
//│ > Cons {
//│ >   head: Ambient { v: Tup3 { fst: 0.035, snd: 0.0325, thd: 0.025 } },
//│ >   tail: Cons {
//│ >     head: Diffuse { v: [Tup3] },
//│ >     tail: Cons { head: [Specular], tail: [Cons] }
//│ >   }
//│ s2 = }
//│ > Cons {
//│ >   head: Point {
//│ >     x: Tup3 { fst: 4, snd: 3, thd: 2 },
//│ >     y: Tup3 { fst: 0.288675, snd: 0.288675, thd: 0.288675 }
//│ >   },
//│ >   tail: Cons {
//│ >     head: Point { x: [Tup3], y: [Tup3] },
//│ >     tail: Cons { head: [Point], tail: [Nil] }
//│ >   }
//│ testlights = }
//│ > Cons {
//│ >   head: Sphere {
//│ >     pos: Tup3 { fst: 0, snd: 0, thd: 0 },
//│ >     radius: 0.5,
//│ >     surface: Cons { head: [Ambient], tail: [Cons] }
//│ >   },
//│ >   tail: Cons {
//│ >     head: Sphere { pos: [Tup3], radius: 0.166667, surface: [Cons] },
//│ >     tail: Cons { head: [Sphere], tail: [Cons] }
//│ >   }
//│ testspheres = }
//│ vup = Tup3 { fst: 0, snd: 0, thd: 1 }

fun spherenormal(pos, sp) = if sp is Sphere(spos, rad, _) then
  vecscale(vecsub(pos, spos), 1 / rad)

fun dtor(x) = x * pi / 180.0

fun camparams(lookfrom, lookat, vup, fov, winsize) =
  let initfirstray = vecsub(lookat, lookfrom)
  if vecnorm(initfirstray) is
    Tup2(lookdir, dist) and vecnorm(veccross(lookdir, vup)) is Tup2(scrni, _) and vecnorm(veccross(scrni, lookdir)) is Tup2(scrnj, _) then
      let xfov = fov
      let yfov = fov
      let xwinsize = winsize
      let ywinsize = winsize
      let magx = 2.0 * dist * tan(dtor(xfov/2)) / xwinsize
      let magy = 2.0 * dist * tan(dtor(yfov/2)) / ywinsize
      let scrnx = vecscale(scrni, magx)
      let scrny = vecscale(scrnj, magy)
      let firstray = vecsub(initfirstray, vecadd(vecscale(scrnx, (0.5 * xwinsize)), vecscale(scrny, (0.5 * ywinsize))))
      Tup3(firstray, scrnx, scrny)

fun sphereintersect(pos, dir, sp) =
  if sp is Sphere(spos, rad, _) then
    let m = vecsub(pos, spos)
    let bm = vecdot(m, dir)
    let m2 = vecdot(m, m)
    let disc = (bm * bm) - m2 + (rad * rad)
    let slo = -bm - sqrt(disc)
    let shi = -bm + sqrt(disc)
    if
      disc < 0.0 then Tup2(false, 0.0)
      slo < 0.0 and
        shi < 0.0 then Tup2(false, 0.0)
        else Tup2(true, shi)
      else Tup2(true, slo)

fun trace(spheres, pos, dir) =
  fun f(d1s1, d2s2) =
    if d1s1 is Tup2(d1, s1) and d2s2 is Tup2(d2, s2_) and
      d1 < d2 then Tup2(d1, s1)
      else Tup2(d2, s2_)
  
  fun sphmap(xss) =
    if xss is
      Nil then Nil
      Cons(x, xs) and sphereintersect(pos, dir, x) is Tup2(is_hit, where_hit) and
        is_hit then Tup2(where_hit, x) :: sphmap(xs)
        else sphmap(xs)
  
  let dists = sphmap(spheres)
  
  if (null_(dists)) then
    Tup3(false, infinity, head(spheres))
  else
    if foldr(f, head(dists), tail(dists)) is Tup2(mindist, sp) then
      Tup3(true, mindist, sp)


fun refractray(newindex, olddir, innorm) =
  let dotp = -vecdot(olddir, innorm)
  let matchIdent_17 = if dotp < 0.0 then
    Tup3(vecscale(innorm, -1.0), -dotp, 1.0 / newindex)
  else
    Tup3(innorm, dotp, newindex)
  if matchIdent_17 is
    Tup3(norm, k, nr) then
      let disc = 1.0 - nr * nr * (1.0 - (k * k))
      let t = (nr * k) - sqrt(disc)
      if disc < 0.0 then
        Tup2(true, Tup3(0.0, 0.0, 0.0))
      else
        (Tup2(false, vecadd(vecscale(norm, t), vecscale(olddir, nr))))

fun lightdirection(l, pt) = if l is
  Directional(dir, col) then Tup2(fst(vecnorm(dir)), infinity)
  Point(pos, col) then vecnorm(vecsub(pos, pt))

fun shadowed(pos, dir, lcolour) =
  if trace(testspheres, vecadd(pos, vecscale(dir, epsilon)), dir) is
    Tup3(is_hit, dist, sp) then
      if not(is_hit) then
        Tup2(false, lcolour)
      else
        Tup2(true, lcolour)

fun lightray(l, pos, norm, refl, surf) =
  if lightdirection(l, pos) is
    Tup2(ldir, dist) then
      let cosangle = vecdot(ldir, norm)
      if shadowed(pos, ldir, lightcolour(l)) is
        Tup2(is_inshadow, lcolour) then
          if
            is_inshadow then Tup3(0.0, 0.0, 0.0)
            let diff = diffusesurf(surf)
            let spow = specpowsurf(surf)
            cosangle <= 0.0 then
              let bodycol = bodysurf(surf)
              let cosalpha = -vecdot(refl, ldir)
              let diffcont = vecmult(vecscale(diff, -cosangle), lcolour)
              let speccont = if cosalpha <= 0.0 then Tup3(0.0, 0.0, 0.0) else (vecmult(vecscale(bodycol, power(cosalpha, spow)), lcolour))
              vecadd(diffcont, speccont)
            let spec = specularsurf(surf)
            let cosalpha = vecdot(refl, ldir)
            let diffcont = vecmult(vecscale(diff, cosangle), lcolour)
            let speccont = if cosalpha < 0.0 then Tup3(0.0, 0.0, 0.0) else (vecmult(vecscale(spec, power(cosalpha, spow)), lcolour))
            else vecadd(diffcont, speccont)

:...
//│ ————————————————————————————————————————————————————————————————————————————————
fun shade(lights, sp, lookpos, dir, dist, contrib) =
  let hitpos = vecadd(lookpos, vecscale(dir, dist))
  let ambientlight = Tup3(1.0, 1.0, 1.0)
  let surf = spheresurf(sp)
  let amb = vecmult(ambientlight, ambientsurf(surf))
  let norm = spherenormal(hitpos, sp)
  let refl = vecadd(dir, vecscale(norm, -2.0 * vecdot(dir, norm)))
  let diff = vecsum(map(l => (lightray(l, hitpos, norm, refl, surf)), lights))
  let transmitted = transmitsurf(surf)
  let simple = vecadd(amb, diff)
  let trintensity = vecscale(bodysurf(surf), transmitted)
  let matchIdent_1 =
    if transmitted < epsilon then
      Tup2(false, simple)
    else
      transmitray(lights, simple, hitpos, dir, refractsurf(surf), trintensity, contrib, norm)
  if matchIdent_1 is Tup2(is_tir, trcol) then
    let reflsurf = vecscale(specularsurf(surf), reflectsurf(surf))
    let reflectiv = if is_tir then vecadd(trintensity, reflsurf) else reflsurf
    let rcol = if is_zerovector(reflectiv) then trcol else (reflectray(hitpos, refl, lights, reflectiv, contrib, trcol))
    rcol

fun transmitray(lights, colour, pos, dir, index, intens, contrib, norm) =
  let newcontrib = vecmult(intens, contrib)
  if refractray(index, dir, norm) is
    Tup2(is_tir, newdir) then
      let nearpos = vecadd(pos, vecscale(newdir, epsilon))
      if trace(testspheres, nearpos, newdir) is
        Tup3(is_hit, dist, sp) then
          let newcol =
            if is_hit then
              shade(lights, sp, nearpos, newdir, dist, newcontrib)
            else
              background
          if is_zerovector(newcontrib) then
            Tup2(false, colour)
          else
            (Tup2(false, vecadd(vecmult(newcol, intens), colour)))

fun reflectray(pos, newdir, lights, intens, contrib, colour) =
  let newcontrib = vecmult(intens, contrib)
  let nearpos = vecadd(pos, vecscale(newdir, epsilon))
  if trace(testspheres, nearpos, newdir) is Tup3(is_hit, dist, sp) then
      let newcol =
        if is_hit then
          shade(lights, sp, nearpos, newdir, dist, newcontrib)
        else
          background
      if is_zerovector(newcontrib) then
        colour
      else
        (vecadd(colour, vecmult(newcol, intens)))
//│ ————————————————————————————————————————————————————————————————————————————————

fun tracepixel(spheres, lights, x, y, firstray, scrnx, scrny) =
  let pos = lookfrom
  if vecnorm(vecadd(vecadd(firstray, vecscale(scrnx, x)), vecscale(scrny, y))) is Tup2(dir, tracepixel_Tup2_1) and trace(spheres, pos, dir) is Tup3(hit, dist, sp) and
    hit then shade(lights, sp, pos, dir, dist, Tup3(1.0, 1.0, 1.0))
    else background

fun hash(param) =
  fun u8(x) = nofibBigInt(round(255 * x))
  foldr(((rgb, acc) => if rgb is Tup3(r, g, b) then u8(r) + (u8(g) * nofibBigInt(7)) + (u8(b) * nofibBigInt(23)) + (acc * nofibBigInt(61))), nofibBigInt(0), param)

fun ray(winsize) =
  let lights = testlights
  if camparams(lookfrom, lookat, vup, fov, winsize) is Tup3(firstray, scrnx, scrny) then
    fun f(i, j) = tracepixel(testspheres, lights, i, j, firstray, scrnx, scrny)
    fun lscomp1(ls1) = if ls1 is
      Nil then Nil
      Cons(i, t1) then
        fun lscomp2(ls2) = if ls2 is
          Nil then lscomp1(t1)
          Cons(j, t2) then Tup2(Tup2(i, j), f(i, j)) :: lscomp2(t2)
        lscomp2(enumFromTo(0, winsize - 1))
    lscomp1(enumFromTo(0, winsize - 1))

fun run(winsize) = hash(map(snd, ray(winsize)))

fun testSphere_nofib(n) = run(n)


testSphere_nofib(30)
//│ = 5303517076988315313332949801059915491159227238911114869988477691048042454660240028235263286419219487056215941279053460510402913638191134284712332734906453769177119866479549825710564164275378353165954211251783583776613466486364346857260327927988942302708582821755390617347892889203137614326710267631036346563969292879841889783895830486185094255970382302038580666396338511666737651046972647664365680026395064916507788381669683616268208254545568013323075147569343527502482992453415977736934966646039451380029114116189124196276320031764844380624699920031305131672697387138852897706575918870327168611841752330951914241998117147850328297747558099955601889252104175852174057287066122859365466714696330034330699419079661953966001855819730466637347813009964893758393398194456345159379187006376036876209312080525632387380670119254556148852520127502599030787981579016179740021934386773631075580149533017386555553650112461351624483964765154488441338857870911043358714412530793575995251653967501366725439356901586292297118595437194582661104059821332957540366106419721198265755243343224842512131366898546251377194773492369372328808207397107344802194547364640358333075609512226775541628703229778371160920064859614452908773471314342954366183109912759985134547433205776906834992238207194263830836275456360444786309396200054415810563334317160702817096977297265083167419253864506146719603442916146256166128051227049046678660445048488558024838465181996990391375870148258607829684558969016638984826787347541150003498463027973936442463090071589323955227296902474986841480537918878837478902992973202305608637036765245465738479448312n
