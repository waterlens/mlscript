:js
:llir
:cpp

:global

:sllir
:intl
:scpp
fun add(x) = y => x + y
fun add_curried(x)(y) = x + y
add(1)(2)
//│ = 3
//│ LLIR:
//│   class Lambda(x$199) extends Callable {
//│     def apply1$219(y$200) =
//│       let x$220 = +(x$199,y$200) in
//│       x$220
//│   }
//│   class Lambda(x$203) extends Callable {
//│     def apply1$219(y$204) =
//│       let x$226 = +(x$203,y$204) in
//│       x$226
//│   }
//│   def add$197(x$199) =
//│     let x$223 = Lambda$217(x$199) in
//│     x$223
//│   def add_curried$198(x$203) =
//│     let x$227 = Lambda$224(x$203) in
//│     x$227
//│   let* (x$228) = add(1) in
//│   let x$229 = Callable.apply1$219(x$228,2) in
//│   x$229
//│ 
//│ Cpp:
//│ #include "mlsprelude.h"
//│ struct _mls_Lambda;
//│ struct _mls_Lambda1;
//│ _mlsValue _mls_add(_mlsValue);
//│ _mlsValue _mls_add_curried(_mlsValue);
//│ _mlsValue _mlsMain();
//│ struct _mls_Lambda: public _mls_Callable {
//│   _mlsValue _mls_x;
//│   constexpr static inline const char *typeName = "Lambda";
//│   constexpr static inline uint32_t typeTag = nextTypeTag();
//│   virtual void print() const override { std::printf("%s", typeName); std::printf("("); this->_mls_x.print();  std::printf(")"); }
//│   virtual void destroy() override { _mlsValue::destroy(this->_mls_x);  operator delete (this, std::align_val_t(_mlsAlignment)); }
//│   static _mlsValue create(_mlsValue _mls_x) { auto _mlsVal = new (std::align_val_t(_mlsAlignment)) _mls_Lambda; _mlsVal->refCount = 1; _mlsVal->tag = typeTag; _mlsVal->_mls_x = _mls_x;  return _mlsValue(_mlsVal); }
//│   virtual _mlsValue _mls_apply1(_mlsValue _mls_y) {
//│     _mlsValue _mls_retval;
//│     auto _mls_x1 = (_mls_x + _mls_y);
//│     _mls_retval = _mls_x1;
//│     return _mls_retval;
//│   }
//│ };
//│ struct _mls_Lambda1: public _mls_Callable {
//│   _mlsValue _mls_x;
//│   constexpr static inline const char *typeName = "Lambda";
//│   constexpr static inline uint32_t typeTag = nextTypeTag();
//│   virtual void print() const override { std::printf("%s", typeName); std::printf("("); this->_mls_x.print();  std::printf(")"); }
//│   virtual void destroy() override { _mlsValue::destroy(this->_mls_x);  operator delete (this, std::align_val_t(_mlsAlignment)); }
//│   static _mlsValue create(_mlsValue _mls_x) { auto _mlsVal = new (std::align_val_t(_mlsAlignment)) _mls_Lambda1; _mlsVal->refCount = 1; _mlsVal->tag = typeTag; _mlsVal->_mls_x = _mls_x;  return _mlsValue(_mlsVal); }
//│   virtual _mlsValue _mls_apply1(_mlsValue _mls_y1) {
//│     _mlsValue _mls_retval;
//│     auto _mls_x3 = (_mls_x + _mls_y1);
//│     _mls_retval = _mls_x3;
//│     return _mls_retval;
//│   }
//│ };
//│ _mlsValue _mls_add(_mlsValue _mls_x) {
//│   _mlsValue _mls_retval;
//│   auto _mls_x4 = _mlsValue::create<_mls_Lambda>(_mls_x);
//│   _mls_retval = _mls_x4;
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_add_curried(_mlsValue _mls_x2) {
//│   _mlsValue _mls_retval;
//│   auto _mls_x5 = _mlsValue::create<_mls_Lambda1>(_mls_x2);
//│   _mls_retval = _mls_x5;
//│   return _mls_retval;
//│ }
//│ _mlsValue _mlsMain() {
//│   _mlsValue _mls_retval;
//│   auto _mls_x6 = _mls_add(_mlsValue::fromIntLit(1));
//│   auto _mls_x7 = _mlsMethodCall<_mls_Callable>(_mls_x6)->_mls_apply1(_mlsValue::fromIntLit(2));
//│   _mls_retval = _mls_x7;
//│   return _mls_retval;
//│ }
//│ int main() { return _mlsLargeStack(_mlsMainWrapper); }
//│ 
//│ Interpreted:
//│ 3

:sllir
:intl
:scpp
fun add4(a, b) = (c, d) => a + b + c + d
fun add4_curried(a, b)(c, d) = a + b + c + d
add4(1, 2)(3, 4)
//│ = 10
//│ LLIR:
//│   class Lambda(b$233,a$232) extends Callable {
//│     def apply2$268(c$234,d$235) =
//│       let x$269 = +(a$232,b$233) in
//│       let x$270 = +(x$269,c$234) in
//│       let x$271 = +(x$270,d$235) in
//│       x$271
//│   }
//│   class Lambda(a$240,b$241) extends Callable {
//│     def apply2$268(c$242,d$243) =
//│       let x$275 = +(a$240,b$241) in
//│       let x$276 = +(x$275,c$242) in
//│       let x$277 = +(x$276,d$243) in
//│       x$277
//│   }
//│   def add4$231(a$232,b$233) =
//│     let x$272 = Lambda$266(b$233,a$232) in
//│     x$272
//│   def add4_curried$230(a$240,b$241) =
//│     let x$278 = Lambda$273(a$240,b$241) in
//│     x$278
//│   let* (x$279) = add4(1,2) in
//│   let x$280 = Callable.apply2$268(x$279,3,4) in
//│   x$280
//│ 
//│ Cpp:
//│ #include "mlsprelude.h"
//│ struct _mls_Lambda2;
//│ struct _mls_Lambda3;
//│ _mlsValue _mls_add4(_mlsValue, _mlsValue);
//│ _mlsValue _mls_add4_curried(_mlsValue, _mlsValue);
//│ _mlsValue _mlsMain();
//│ struct _mls_Lambda2: public _mls_Callable {
//│   _mlsValue _mls_b;
//│   _mlsValue _mls_a;
//│   constexpr static inline const char *typeName = "Lambda";
//│   constexpr static inline uint32_t typeTag = nextTypeTag();
//│   virtual void print() const override { std::printf("%s", typeName); std::printf("("); this->_mls_b.print(); std::printf(", "); this->_mls_a.print();  std::printf(")"); }
//│   virtual void destroy() override { _mlsValue::destroy(this->_mls_b); _mlsValue::destroy(this->_mls_a);  operator delete (this, std::align_val_t(_mlsAlignment)); }
//│   static _mlsValue create(_mlsValue _mls_b, _mlsValue _mls_a) { auto _mlsVal = new (std::align_val_t(_mlsAlignment)) _mls_Lambda2; _mlsVal->refCount = 1; _mlsVal->tag = typeTag; _mlsVal->_mls_b = _mls_b; _mlsVal->_mls_a = _mls_a;  return _mlsValue(_mlsVal); }
//│   virtual _mlsValue _mls_apply2(_mlsValue _mls_c, _mlsValue _mls_d) {
//│     _mlsValue _mls_retval;
//│     auto _mls_x8 = (_mls_a + _mls_b);
//│     auto _mls_x9 = (_mls_x8 + _mls_c);
//│     auto _mls_x10 = (_mls_x9 + _mls_d);
//│     _mls_retval = _mls_x10;
//│     return _mls_retval;
//│   }
//│ };
//│ struct _mls_Lambda3: public _mls_Callable {
//│   _mlsValue _mls_a;
//│   _mlsValue _mls_b;
//│   constexpr static inline const char *typeName = "Lambda";
//│   constexpr static inline uint32_t typeTag = nextTypeTag();
//│   virtual void print() const override { std::printf("%s", typeName); std::printf("("); this->_mls_a.print(); std::printf(", "); this->_mls_b.print();  std::printf(")"); }
//│   virtual void destroy() override { _mlsValue::destroy(this->_mls_a); _mlsValue::destroy(this->_mls_b);  operator delete (this, std::align_val_t(_mlsAlignment)); }
//│   static _mlsValue create(_mlsValue _mls_a, _mlsValue _mls_b) { auto _mlsVal = new (std::align_val_t(_mlsAlignment)) _mls_Lambda3; _mlsVal->refCount = 1; _mlsVal->tag = typeTag; _mlsVal->_mls_a = _mls_a; _mlsVal->_mls_b = _mls_b;  return _mlsValue(_mlsVal); }
//│   virtual _mlsValue _mls_apply2(_mlsValue _mls_c1, _mlsValue _mls_d1) {
//│     _mlsValue _mls_retval;
//│     auto _mls_x11 = (_mls_a + _mls_b);
//│     auto _mls_x12 = (_mls_x11 + _mls_c1);
//│     auto _mls_x13 = (_mls_x12 + _mls_d1);
//│     _mls_retval = _mls_x13;
//│     return _mls_retval;
//│   }
//│ };
//│ _mlsValue _mls_add4(_mlsValue _mls_a, _mlsValue _mls_b) {
//│   _mlsValue _mls_retval;
//│   auto _mls_x14 = _mlsValue::create<_mls_Lambda2>(_mls_b, _mls_a);
//│   _mls_retval = _mls_x14;
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_add4_curried(_mlsValue _mls_a1, _mlsValue _mls_b1) {
//│   _mlsValue _mls_retval;
//│   auto _mls_x15 = _mlsValue::create<_mls_Lambda3>(_mls_a1, _mls_b1);
//│   _mls_retval = _mls_x15;
//│   return _mls_retval;
//│ }
//│ _mlsValue _mlsMain() {
//│   _mlsValue _mls_retval;
//│   auto _mls_x16 = _mls_add4(_mlsValue::fromIntLit(1), _mlsValue::fromIntLit(2));
//│   auto _mls_x17 = _mlsMethodCall<_mls_Callable>(_mls_x16)->_mls_apply2(_mlsValue::fromIntLit(3), _mlsValue::fromIntLit(4));
//│   _mls_retval = _mls_x17;
//│   return _mls_retval;
//│ }
//│ int main() { return _mlsLargeStack(_mlsMainWrapper); }
//│ 
//│ Interpreted:
//│ 10

:sllir
:intl
:scpp
fun add(a, b) = a + b
fun dummy() = add
dummy()(1, 2)
//│ = 3
//│ LLIR:
//│   class Lambda_add() extends Callable {
//│     def apply2$268(arg$299,arg$300) =
//│       let* (x$303) = add(arg$299,arg$300) in
//│       x$303
//│   }
//│   def add$281(a$283,b$284) =
//│     let x$298 = +(a$283,b$284) in
//│     x$298
//│   def dummy$282() =
//│     let x$304 = Lambda_add$301() in
//│     x$304
//│   let* (x$305) = dummy() in
//│   let x$306 = Callable.apply2$268(x$305,1,2) in
//│   x$306
//│ 
//│ Cpp:
//│ #include "mlsprelude.h"
//│ struct _mls_Lambda_add;
//│ _mlsValue _mls_add1(_mlsValue, _mlsValue);
//│ _mlsValue _mls_dummy();
//│ _mlsValue _mlsMain();
//│ struct _mls_Lambda_add: public _mls_Callable {
//│   
//│   constexpr static inline const char *typeName = "Lambda_add";
//│   constexpr static inline uint32_t typeTag = nextTypeTag();
//│   virtual void print() const override { std::printf("%s", typeName); }
//│   virtual void destroy() override {  operator delete (this, std::align_val_t(_mlsAlignment)); }
//│   static _mlsValue create() { auto _mlsVal = new (std::align_val_t(_mlsAlignment)) _mls_Lambda_add; _mlsVal->refCount = 1; _mlsVal->tag = typeTag;  return _mlsValue(_mlsVal); }
//│   virtual _mlsValue _mls_apply2(_mlsValue _mls_arg, _mlsValue _mls_arg1) {
//│     _mlsValue _mls_retval;
//│     auto _mls_x18 = _mls_add1(_mls_arg, _mls_arg1);
//│     _mls_retval = _mls_x18;
//│     return _mls_retval;
//│   }
//│ };
//│ _mlsValue _mls_add1(_mlsValue _mls_a2, _mlsValue _mls_b2) {
//│   _mlsValue _mls_retval;
//│   auto _mls_x19 = (_mls_a2 + _mls_b2);
//│   _mls_retval = _mls_x19;
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_dummy() {
//│   _mlsValue _mls_retval;
//│   auto _mls_x20 = _mlsValue::create<_mls_Lambda_add>();
//│   _mls_retval = _mls_x20;
//│   return _mls_retval;
//│ }
//│ _mlsValue _mlsMain() {
//│   _mlsValue _mls_retval;
//│   auto _mls_x21 = _mls_dummy();
//│   auto _mls_x22 = _mlsMethodCall<_mls_Callable>(_mls_x21)->_mls_apply2(_mlsValue::fromIntLit(1), _mlsValue::fromIntLit(2));
//│   _mls_retval = _mls_x22;
//│   return _mls_retval;
//│ }
//│ int main() { return _mlsLargeStack(_mlsMainWrapper); }
//│ 
//│ Interpreted:
//│ 3

:sllir
:intl
abstract class List[out T]: Cons[T] | Nil
class (::) Cons[out T](head: T, tail: List[T]) extends List[T]
object Nil extends List
fun map(f, l) =
  if l is
    Cons(h, t) then Cons(f(h), map(f, t))
    Nil then Nil
fun inc(x) = x + 1
fun main() =
  map(x => inc(x), 1 :: 2 :: Nil)
  map(inc, 3 :: 4 :: Nil)
main()
//│ = Cons(4, Cons(5, Nil))
//│ LLIR:
//│   class List()
//│   class Cons(head$319,tail$320) extends List
//│   class Nil() extends List
//│   class Lambda() extends Callable {
//│     def apply1$219(x$337) =
//│       let* (x$401) = inc(x$337) in
//│       x$401
//│   }
//│   class Lambda_inc() extends Callable {
//│     def apply1$219(arg$407) =
//│       let* (x$410) = inc(arg$407) in
//│       x$410
//│   }
//│   def map$308(f$323,l$324) =
//│     case l$324 of
//│       Cons$316 =>
//│         let x$388 = l$324.<Cons$316:head> in
//│         let x$389 = l$324.<Cons$316:tail> in
//│         let x$390 = Callable.apply1$219(f$323,x$388) in
//│         let* (x$391) = map(f$323,x$389) in
//│         let x$392 = Cons$316(x$390,x$391) in
//│         x$392
//│       _ =>
//│         case l$324 of
//│           Nil$321 =>
//│             let x$394 = Nil$321() in
//│             x$394
//│           _ =>
//│             panic "match error"
//│   def j$393() =
//│     jump j$387()
//│   def j$387() =
//│     null
//│   def inc$311(x$333) =
//│     let x$395 = +(x$333,1) in
//│     x$395
//│   def main$309() =
//│     let x$396 = Nil$321() in
//│     let x$397 = Cons$316(2,x$396) in
//│     let x$398 = Cons$316(1,x$397) in
//│     let x$402 = Lambda$399() in
//│     let* (x$403) = map(x$402,x$398) in
//│     let x$404 = Nil$321() in
//│     let x$405 = Cons$316(4,x$404) in
//│     let x$406 = Cons$316(3,x$405) in
//│     let x$411 = Lambda_inc$408() in
//│     let* (x$412) = map(x$411,x$406) in
//│     x$412
//│   let* (x$413) = main() in
//│   x$413
//│ 
//│ Interpreted:
//│ Cons(4,Cons(5,Nil()))

